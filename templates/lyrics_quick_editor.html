<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>å¿«é€Ÿç¼–è¾‘æ­Œè¯{% if display_name %} Â· {{ display_name }}{% endif %}</title>
  <!-- å¯é€‰ï¼šä¸ºè·¨åŸŸåç«¯æä¾› API åŸºå€ï¼Œä¾‹å¦‚ https://your-backend.example.com -->
  <meta name="api-base" content="/quick-editor" />
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #1f2328;
      --muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 1px 2px rgba(0,0,0,0.04), 0 4px 12px rgba(0,0,0,0.06);
      --primary: #2563eb;
      --primary-600: #1d4ed8;
      --primary-50: #eff6ff;
      --accent: #8b5cf6;
      --accent-50: #f5f3ff;
      --radius: 10px;
      --radius-sm: 8px;
      --radius-xs: 6px;
      --token: #f9fafb;
      --token-border: #e5e7eb;
      --token-hover: #eef2ff;
      --token-selected: #f3e8ff;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0f15;
        --card: #0f1722;
        --text: #e5e7eb;
        --muted: #9aa4b2;
        --border: #1f2937;
        --shadow: 0 1px 2px rgba(0,0,0,0.5), 0 8px 24px rgba(0,0,0,0.45);
        --primary: #3b82f6;
        --primary-600: #2563eb;
        --primary-50: #0b1220;
        --accent: #a78bfa;
        --accent-50: #141327;
        --token: #0f1722;
        --token-border: #1f2937;
        --token-hover: #111827;
        --token-selected: #18122b;
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans', Arial, 'PingFang SC', 'Hiragino Sans GB', sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 800px at 10% -10%, rgba(37,99,235,0.05), transparent 40%),
                  radial-gradient(900px 600px at 100% 0%, rgba(139,92,246,0.06), transparent 45%),
                  var(--bg);
    }

    header {
      position: sticky; top: 0; z-index: 20;
      padding: 14px 18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.75)) no-repeat,
                  var(--card);
      backdrop-filter: saturate(1.2) blur(6px);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    @media (prefers-color-scheme: dark) {
      header { background: linear-gradient(180deg, rgba(15,23,34,0.8), rgba(15,23,34,0.75)) no-repeat, var(--card); }
    }

    h1 { margin: 0 0 10px 0; font-size: 20px; font-weight: 650; letter-spacing: 0.2px; }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .controls input[type=file] {
      padding: 6px 8px; border: 1px dashed var(--border); border-radius: var(--radius-xs);
      background: var(--card); color: var(--muted);
    }
    .controls button {
      padding: 8px 12px; border: 1px solid var(--border); background: var(--card);
      border-radius: var(--radius); cursor: pointer; color: var(--text);
      transition: background .2s ease, border-color .2s ease, box-shadow .2s ease, transform .06s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .controls button:hover { border-color: #cbd5e1; box-shadow: 0 4px 10px rgba(2,6,23,0.05); }
    .controls button:active { transform: translateY(1px); }
    .controls button:disabled { opacity: 0.6; cursor: not-allowed; }
    /* Primary emphasis */
    #btnImport, #btnSave {
      background: linear-gradient(180deg, var(--primary), var(--primary-600));
      color: #fff; border-color: transparent; box-shadow: 0 6px 18px rgba(37,99,235,0.25);
    }
    #btnImport:hover, #btnSave:hover { box-shadow: 0 8px 22px rgba(37,99,235,0.3); }
    #btnImport:disabled, #btnSave:disabled { background: #aab4c6; box-shadow: none; }

    main {
      display: grid; grid-template-columns: minmax(0, 1fr) 360px; gap: 18px; padding: 18px; max-width: 1200px; margin: 0 auto;
    }
    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
    }

    .panel {
      border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; background: var(--card);
      box-shadow: var(--shadow);
    }
    .panel > h2 { margin: 2px 0 10px; font-size: 16px; color: var(--muted); font-weight: 600; }

    #docInfo { color: var(--muted); margin-bottom: 10px; font-size: 13px; }

    #lines { display: flex; flex-direction: column; gap: 10px; }

    .line {
      display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
      padding: 10px; border: 1px dashed var(--border); border-radius: var(--radius-sm);
      background: color-mix(in srgb, var(--card) 92%, transparent);
      transition: border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }
    .line:hover { border-color: #cbd5e1; box-shadow: 0 2px 10px rgba(2,6,23,0.04); }
    .line.meta { background: var(--primary-50); border-style: solid; }

    .prefix { color: var(--muted); margin-right: 6px; font-variant-numeric: tabular-nums; }

    .tok {
      display: inline-block; padding: 6px 10px; border: 1px solid var(--token-border);
      border-radius: 999px; cursor: grab; user-select: none;
      background: var(--token); color: var(--text);
      transition: border-color .15s ease, box-shadow .15s ease, background .15s ease, transform .06s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
      outline: none;
    }
    .tok:hover { border-color: #c7d2fe; background: var(--token-hover); }
    .tok:active { cursor: grabbing; transform: translateY(1px); }
    .tok.selected {
      background: var(--token-selected);
      border-color: #c084fc;
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent);
    }
    .tok.anchor { outline: 2px solid var(--primary); }
    .tok:focus-visible { box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 30%, transparent); }

    .tok.drop-left { box-shadow: -3px 0 0 0 var(--primary) inset, 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
    .tok.drop-right { box-shadow:  3px 0 0 0 var(--primary) inset, 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }

    .box { background: linear-gradient(180deg, var(--accent-50), transparent 80%); padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); }
    #status { margin-top: 10px; color: var(--muted); min-height: 1.4em; font-size: 13px; transition: color .2s ease; }
    #status.success { color: #0c8599; }
    #status.error { color: #c92a2a; }
    .muted { color: var(--muted); font-size: 12px; }

    /* Smooth scrollbars */
    ::-webkit-scrollbar { height: 10px; width: 10px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 999px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

    /* Line drop highlight */
    .line.drop-left { box-shadow: inset 4px 0 0 0 var(--primary); border-style: solid; }
    .line.drop-right { box-shadow: inset -4px 0 0 0 var(--primary); border-style: solid; }
    .line.selected { border-color: #93c5fd; background: color-mix(in srgb, var(--primary-50) 65%, var(--card)); }

    /* Prefix editor */
    .prefix-editor { width: 64px; min-width: 56px; padding: 4px 6px; border: 1px dashed var(--border); border-radius: 7px; background: var(--card); color: var(--text); text-align: center; font-variant-numeric: tabular-nums; }
    .prefix-editor::placeholder { color: var(--muted); }
    .prefix-editor:focus { outline: none; border-color: #cbd5e1; box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
    /* Playing highlight */
    .tok.active {
      background: #fef3c7; /* amber-100 */
      border-color: #f59e0b; /* amber-500 */
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25);
    }
    .line.playing {
      outline: 2px solid rgba(245, 158, 11, 0.35);
    }
  </style>
</head>
<body>
  <header>
    <h1>.lys æ­Œè¯é¡ºåºç¼–è¾‘å™¨ï¼ˆå¤šé€‰æ‹–æ”¾ï¼Œå‰ç«¯ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰</h1>
    <div class="controls">
      <input type="file" id="fileInput" accept=".lys,.lrc,.txt" />
      <button id="btnImport">å¯¼å…¥ .lys</button>
      <button id="btnUndo" disabled>æ’¤é”€</button>
      <button id="btnRedo" disabled>é‡åš</button>
      <button id="btnSortLines" disabled>æ’åºæ­Œè¯è¡Œ</button>
      <button id="btnSave" disabled>ä¿å­˜</button>
      <button id="btnUndoImport" style="display:none;">æ’¤é”€å¯¼å…¥</button>
      <span style="flex:1"></span>
      <!-- æ–°å¢ï¼šæŒ‰é”®å»¶è¿Ÿ(ms) è®¾ç½® -->
      <label class="muted" style="display:flex; align-items:center; gap:6px;">
        å»¶è¿Ÿ(ms)
        <input id="keyDelayInput" type="number" step="1" placeholder="0"
               style="width:90px; padding:4px 6px; border:1px dashed var(--border); border-radius:6px;">
      </label>
      <input type="file" id="mediaInput" accept="audio/*,video/*" />
      <button id="btnPlayPause" disabled>æ’­æ”¾</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2>æ–‡æ¡£</h2>
      <div id="docInfo"></div>
      <div id="lines"></div>
    </section>

    <section class="panel">
      <h2>ç”¨æ³•è¯´æ˜</h2>
      <div class="box">
        <h3 style="margin-top: 0; color: var(--primary);">ğŸµ åŸºç¡€æ“ä½œ</h3>
        <p><strong>é€‰æ‹©æ­Œè¯å—ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>å•å‡»ä¸€ä¸ªæ­Œè¯å—è¿›è¡Œå•é€‰</li>
          <li><strong>Ctrl/âŒ˜ + ç‚¹å‡»</strong>è¿›è¡Œå¤šé€‰ï¼ˆå¯è·¨è¡Œé€‰æ‹©ï¼‰</li>
          <li>å•å‡»è¡Œå†…çš„ç©ºç™½åŒºåŸŸå¯é€‰ä¸­æ•´è¡Œï¼ˆä¾¿äºæ•´è¡Œå¤åˆ¶/ç²˜è´´ï¼‰</li>
          <li>ç‚¹å‡»ç©ºç™½å¤„æ¸…ç©ºæ‰€æœ‰é€‰æ‹©</li>
        </ul>
        
        <p><strong>æ‹–æ”¾è°ƒæ•´é¡ºåºï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>é€‰ä¸­æ–‡æœ¬å—åç›´æ¥æ‹–åŠ¨åˆ°ç›®æ ‡ä½ç½®</li>
          <li>æ‹–åŠ¨åˆ°å¦ä¸€ä¸ªå—çš„å·¦åŠåŒºï¼šæ’å…¥åˆ°è¯¥å—å‰é¢</li>
          <li>æ‹–åŠ¨åˆ°å¦ä¸€ä¸ªå—çš„å³åŠåŒºï¼šæ’å…¥åˆ°è¯¥å—åé¢</li>
          <li>æ‹–åŠ¨åˆ°è¡Œçš„å·¦åŠåŒºï¼šç§»åŠ¨åˆ°è¯¥è¡Œå¼€å¤´</li>
          <li>æ‹–åŠ¨åˆ°è¡Œçš„å³åŠåŒºï¼šç§»åŠ¨åˆ°è¯¥è¡Œç»“å°¾</li>
          <li class="muted">æ‹–æ”¾æ—¶ä¼šæœ‰è“è‰²é«˜äº®æç¤ºæ’å…¥ä½ç½®</li>
        </ul>
        
        <h3 style="color: var(--primary);">âœï¸ ç¼–è¾‘åŠŸèƒ½</h3>
        <p><strong>å¤åˆ¶ç²˜è´´ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>Ctrl+C / Ctrl+Vï¼ˆMac: âŒ˜C / âŒ˜Vï¼‰å¤åˆ¶ç²˜è´´</li>
          <li>å¯å¤åˆ¶å•ä¸ªè¯å—æˆ–å¤šé€‰è¯å—</li>
          <li>å¯å¤åˆ¶æ•´è¡Œæ­Œè¯ï¼ˆå…ˆç‚¹å‡»è¡Œç©ºç™½å¤„ï¼‰</li>
          <li>ç²˜è´´åˆ°è¯å—å³ä¾§æˆ–è¡Œå¼€å¤´</li>
        </ul>
        
        <p><strong>å‰ç¼€ç¼–è¾‘ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>æ­Œè¯è¡Œå·¦ä¾§çš„æ•°å­—å‰ç¼€å¯ç›´æ¥ç¼–è¾‘</li>
          <li>è¾“å…¥æ•°å­—åæŒ‰ Enter æˆ–ç‚¹å‡»å…¶ä»–åœ°æ–¹ç¡®è®¤</li>
          <li>ç•™ç©ºåˆ™æ˜¾ç¤ºä¸º []ï¼ˆæ— å‰ç¼€ï¼‰</li>
        </ul>
        
        <p><strong>æ’å…¥ç©ºè¡Œï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>åœ¨è¡Œçš„ç©ºç™½åŒºåŸŸå¿«é€Ÿä¸‰å‡»ï¼Œåœ¨è¯¥è¡Œä¸‹æ–¹æ’å…¥æ–°ç©ºè¡Œ</li>
          <li>æ–°æ’å…¥çš„ç©ºè¡Œå¯ç¼–è¾‘å‰ç¼€å’Œæ·»åŠ å†…å®¹</li>
        </ul>
        
        <h3 style="color: var(--primary);">ğŸ® æ’­æ”¾æ§åˆ¶</h3>
        <p><strong>æ’­æ”¾å™¨åŠŸèƒ½ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>å¯é€‰åŠ è½½ éŸ³é¢‘/è§†é¢‘ æ–‡ä»¶è¿›è¡ŒåŒæ­¥æ’­æ”¾</li>
          <li>ç‚¹å‡»ã€Œæ’­æ”¾ã€æŒ‰é’®æˆ–æŒ‰ç©ºæ ¼é”®æ’­æ”¾/æš‚åœ</li>
          <li>åŒå‡»æŸè¡Œçš„ç©ºç™½åŒºåŸŸä¼šä»è¯¥è¡Œå¼€å§‹æ’­æ”¾</li>
          <li>å•å‡»æ•´è¡Œåªä¼šé€‰ä¸­è¯¥è¡Œï¼Œä¸å†è§¦å‘æ’­æ”¾</li>
          <li>å³ä¸Šè§’ã€Œå»¶è¿Ÿ(ms)ã€å¯è®¾ç½®æŒ‰é”®åç§»ï¼Œåº”ç”¨äº F/H ç­‰å¯¹é½å¿«æ·é”®</li>
          <li>å½“å‰æ’­æ”¾çš„æ­Œè¯è¡Œå’Œè¯å—ä¼šé«˜äº®æ˜¾ç¤º</li>
          <li>ä¸åŠ è½½åª’ä½“æ–‡ä»¶æ—¶ä½¿ç”¨æ—¶é’Ÿæ¨¡å¼æ’­æ”¾</li>
        </ul>
        
        <h3 style="color: var(--primary);">ğŸ› ï¸ é«˜çº§åŠŸèƒ½</h3>
        <p><strong>æ’¤é”€é‡åšï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>ä½¿ç”¨ã€Œæ’¤é”€ã€å’Œã€Œé‡åšã€æŒ‰é’®æ¢å¤æ“ä½œ</li>
          <li>æ”¯æŒå¤šæ­¥æ’¤é”€å’Œé‡åš</li>
        </ul>
        
        <p><strong>æ­Œè¯è¡Œæ’åºï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>ç‚¹å‡»ã€Œæ’åºæ­Œè¯è¡Œã€æŒ‰å¼€å§‹æ—¶é—´è‡ªåŠ¨æ’åº</li>
          <li>ä¿ç•™åŸæœ‰æ—¶é—´æˆ³ï¼Œåªè°ƒæ•´è¡Œçš„å…ˆåé¡ºåº</li>
        </ul>
        
        <h3 style="color: var(--primary);">ğŸ“ æ–‡ä»¶æ”¯æŒ</h3>
        <p><strong>å¯¼å…¥æ ¼å¼ï¼š</strong> .lysã€.lrcã€.txt æ–‡ä»¶</p>
        <p><strong>ä¿å­˜æ ¼å¼ï¼š</strong> ä¿å­˜å› .lys æ–‡ä»¶ï¼Œæ—¶é—´æˆ³å®Œæ•´ä¿ç•™</p>
        <p class="muted">ğŸ’¡ æç¤ºï¼šé¡µé¢ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œä½†æ‰€æœ‰æ“ä½œéƒ½ä¼šä¿ç•™åŸæ—¶é—´æˆ³ï¼›ä¿å­˜åç®¡ç†é¡µä¼šç›´æ¥ä½¿ç”¨æœ€æ–°å†…å®¹ã€‚</p>
        
        <h3 style="color: var(--primary);">âŒ¨ï¸ å¿«æ·é”®</h3>
        <div style="background: var(--primary-50); padding: 12px; border-radius: 8px; margin-top: 12px;">
          <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">Ctrl+C / âŒ˜C</td>
              <td style="padding: 6px 8px; color: var(--muted);">å¤åˆ¶é€‰ä¸­çš„æ­Œè¯å†…å®¹</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">Ctrl+V / âŒ˜V</td>
              <td style="padding: 6px 8px; color: var(--muted);">ç²˜è´´åˆ°é€‰ä¸­çš„ä½ç½®</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">Space (ç©ºæ ¼)</td>
              <td style="padding: 6px 8px; color: var(--muted);">æ’­æ”¾/æš‚åœ</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">F</td>
              <td style="padding: 6px 8px; color: var(--muted);">
                è®©"é€‰ä¸­è¡Œ"çš„æ­Œè¯ä»æ­¤åˆ»å¼€å§‹ï¼ˆå«æŒ‰é”®å»¶è¿Ÿï¼‰
              </td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">H</td>
              <td style="padding: 6px 8px; color: var(--muted);">
                è®©"é€‰ä¸­è¡Œ"çš„æœ€åä¸€ä¸ªå­—åœ¨æ­¤åˆ»ç»“æŸï¼ˆåªæ”¹æŒç»­æ—¶é—´ï¼‰
              </td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">W</td>
              <td style="padding: 6px 8px; color: var(--muted);">å°†é€‰ä¸­è¡Œå‰ç¼€æ¸…ç©ºä¸º []</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">A</td>
              <td style="padding: 6px 8px; color: var(--muted);">å°†é€‰ä¸­è¡Œå‰ç¼€è®¾ç½®ä¸º 4</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">S</td>
              <td style="padding: 6px 8px; color: var(--muted);">å°†é€‰ä¸­è¡Œå‰ç¼€è®¾ç½®ä¸º 6</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">D</td>
              <td style="padding: 6px 8px; color: var(--muted);">å°†é€‰ä¸­è¡Œå‰ç¼€è®¾ç½®ä¸º 5</td>
            </tr>
            <tr>
              <td style="padding: 6px 8px; font-weight: 600;">Ctrl+ç‚¹å‡» / âŒ˜+ç‚¹å‡»</td>
              <td style="padding: 6px 8px; color: var(--muted);">å¤šé€‰æ­Œè¯å—</td>
            </tr>
          </table>
        </div>
      </div>
      <div id="status"></div>
    </section>
  </main>


  <script>
    const PRELOAD_JSON_FILE = {{ json_file|tojson|safe }};
    const PRELOAD_DISPLAY_NAME = {{ display_name|tojson|safe }};
    const PRELOADED_DATA = {{ preload_data|tojson|safe }};
    const $ = (sel) => document.querySelector(sel);
    // API åŸºå€ï¼ˆé»˜è®¤åŒæºï¼‰ã€‚å¯åœ¨éƒ¨ç½²åˆ° GitHub Pages æ—¶ï¼Œé€šè¿‡æ³¨å…¥ window.API_BASE æˆ–è®¾ç½® <meta name="api-base" content="..."> æ¥æŒ‡å®šåç«¯åŸŸåã€‚
    const API_BASE = (window.API_BASE || (document.querySelector('meta[name="api-base"]')?.content || '')).replace(/\/$/, '');
    const BASE_TITLE = document.title || 'å¿«é€Ÿç¼–è¾‘æ­Œè¯';
    const apiUrl = (path) => API_BASE + path;
    const apiFetch = (path, init) => fetch(apiUrl(path), init);

    let state = {
      doc: null,
      selectedTokenIds: new Set(),
      selectedLineId: null, // é€‰ä¸­çš„æ•´è¡Œï¼ˆç”¨äºè¡Œçº§å¤åˆ¶/ç²˜è´´ï¼‰
      clipboard: null,      // { tokens: [{text, ts}], fromLineId }
      settings: {
        keyDelayMs: 0,
      },
      // æ’­æ”¾ç›¸å…³
      playback: {
        usingMedia: false,
        mediaEl: null,
        playing: false,
        rafId: 0,
        clockStartEpoch: 0,
        clockStartOffset: 0, // ms
      },
      tokenCache: [], // [{id, lineId, start, end, el}]
      // é¡µé¢çŠ¶æ€
      unsaved: false,                // æ˜¯å¦æœ‰æœªä¿å­˜å˜æ›´ï¼ˆç”¨äºå…³é—­ç¡®è®¤ï¼‰
      lastImportBackup: null,        // { doc, selectedTokenIds, selectedLineId, unsaved }
      context: {
        jsonFile: '',
        lyricsPath: '',
        translationPath: '',
        songUrl: '',
        displayName: PRELOAD_DISPLAY_NAME || '',
        updatedJson: false
      }
    };

    const hasDocData = () => !!(state.doc && Array.isArray(state.doc.lines) && state.doc.lines.length > 0);

    function setStatus(msg, type = 'info') {
      const el = $('#status');
      el.textContent = msg || '';
      el.classList.remove('success', 'error');
      if (type === 'success') el.classList.add('success');
      if (type === 'error') el.classList.add('error');
    }

    function updateDocInfo() {
      if (!state.doc) {
        $('#docInfo').textContent = 'æš‚æ— æ–‡æ¡£';
        return;
      }
      const fileLabel = state.context.displayName || state.context.jsonFile || 'æœªå‘½å';
      $('#docInfo').textContent = `æ–‡ä»¶: ${fileLabel} | DocID: ${state.doc.id} â€” version: ${state.doc.version} â€” è¡Œæ•°: ${state.doc.lines.length}`;
    }

    function applyDoc(doc, contextOverrides = {}) {
      state.doc = doc;
      state.selectedTokenIds.clear();
      state.selectedLineId = null;
      if (contextOverrides && Object.keys(contextOverrides).length > 0) {
        state.context = { ...state.context, ...contextOverrides };
      }
      renderDoc();
      $('#btnSave').disabled = false;
      $('#btnUndo').disabled = false;
      $('#btnRedo').disabled = false;
      $('#btnSortLines').disabled = false;
      $('#btnPlayPause').disabled = false;
      clearDirty();
    }

    function renderDoc() {
      const c = $('#lines');
      c.innerHTML = '';
      if (!state.doc) {
        updateDocInfo();
        return;
      }
      // æ ‡é¢˜ä¸Šçš„å°åœ†ç‚¹æç¤ºï¼ˆæœ‰æ— å˜æ›´ï¼‰
      const titleSuffix = state.context.displayName ? ` Â· ${state.context.displayName}` : '';
      document.title = (state.unsaved ? 'â— ' : '') + BASE_TITLE + titleSuffix;

      updateDocInfo();

      state.tokenCache = [];
      state.doc.lines.forEach((line) => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'line' + (line.is_meta ? ' meta' : '');
        lineDiv.dataset.lineId = line.id;
        if (state.selectedLineId === line.id) lineDiv.classList.add('selected');

        // å¯ç¼–è¾‘çš„å‰ç¼€æ•°å­—è¾“å…¥ï¼ˆä»…é meta è¡Œï¼‰
        if (!line.is_meta) {
          const preWrap = document.createElement('div');
          preWrap.className = 'prefix';
          const input = document.createElement('input');
          input.className = 'prefix-editor';
          input.type = 'number';
          input.placeholder = '[ ]';
          const m = /\[([^\]]*)\]/.exec(line.prefix || '');
          input.value = m ? m[1] : '';
          input.title = 'å¯ç¼–è¾‘çš„å‰ç¼€æ•°å­—ï¼ˆç•™ç©ºä¸ºæ— å‰ç¼€ï¼‰';
          input.addEventListener('click', (e) => { e.stopPropagation(); });
          input.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') { await commitPrefix(line.id, input.value); }
            e.stopPropagation();
          });
          input.addEventListener('blur', async () => { await commitPrefix(line.id, input.value); });
          input.addEventListener('focus', () => {              // âœ… æ–°å¢
            state.selectedLineId = line.id;
          });
          preWrap.appendChild(input);
          lineDiv.appendChild(preWrap);
        } else if (line.prefix) {
          const pre = document.createElement('span');
          pre.className = 'prefix';
          pre.textContent = line.prefix;
          lineDiv.appendChild(pre);
        }

        line.tokens.forEach((tok) => {
          const span = document.createElement('span');
          span.className = 'tok';
          // ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œåªæ˜¾ç¤ºæ–‡æœ¬
          span.textContent = tok.text || '(ç©º)';
          span.title = `tokenId=${tok.id}`; // ä¸æ˜¾ç¤ºæ—¶é—´æˆ³
          span.dataset.tokenId = tok.id;
          span.dataset.lineId = line.id;
          span.draggable = !line.is_meta;  // meta è¡Œä¸å…è®¸æ‹–æ‹½

          // è§£ææ—¶é—´æˆ³ï¼ˆstart,durationï¼‰
          let sMs = null, dMs = null;
          if (tok.ts && typeof tok.ts === 'string' && tok.ts.includes(',')) {
            const parts = tok.ts.split(',');
            sMs = parseInt(parts[0], 10);
            dMs = parseInt(parts[1], 10);
            if (!Number.isFinite(sMs) || !Number.isFinite(dMs)) { sMs = null; dMs = null; }
          }
          if (sMs != null && dMs != null) {
            span.dataset.startMs = String(sMs);
            span.dataset.durMs = String(dMs);
            state.tokenCache.push({ id: tok.id, lineId: line.id, start: sMs, end: sMs + dMs, el: span });
          }

          if (state.selectedTokenIds.has(tok.id)) span.classList.add('selected');

          // ç‚¹å‡»ï¼šå¤šé€‰/å–æ¶ˆ
          span.addEventListener('click', (e) => {
            const multi = e.metaKey || e.ctrlKey;
            if (multi) {
              if (state.selectedTokenIds.has(tok.id)) state.selectedTokenIds.delete(tok.id);
              else state.selectedTokenIds.add(tok.id);
            } else {
              // å•å‡»åˆ‡æ¢é€‰æ‹©åˆ°è¿™ä¸ª tokenï¼ˆä¾¿äºå•é€‰æ‹–åŠ¨ï¼‰
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
            }
            renderDoc();
          });

          // æ‹–æ‹½å¼€å§‹ï¼šè‹¥å½“å‰ token ä¸åœ¨é€‰æ‹©ä¸­ï¼Œåˆ™å°†é€‰æ‹©é‡ç½®ä¸ºè¯¥ token
          span.addEventListener('dragstart', (e) => {
            if (!state.selectedTokenIds.has(tok.id)) {
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
              renderDoc();
            }
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'drag'); // å ä½ä»¥å¯ç”¨æ‹–æ‹½
          });

          // åœ¨ token ä¸Šæ–¹æ‚¬åœï¼šå†³å®š before / after çš„è§†è§‰æç¤º
          span.addEventListener('dragover', (e) => {
            if (!state.doc) return;
            e.preventDefault(); // å…è®¸ drop
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.toggle('drop-left', isLeft);
            span.classList.toggle('drop-right', !isLeft);
          });

          // ç¦»å¼€æ—¶æ¸…ç†æ ·å¼
          span.addEventListener('dragleave', () => {
            span.classList.remove('drop-left', 'drop-right');
          });

          // æ”¾ä¸‹ï¼šè®¡ç®— before/afterï¼Œæ„é€  selection + targetï¼Œè°ƒç”¨ /api/move
          span.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.remove('drop-left', 'drop-right');
            await doDropMove({
              anchorLineId: span.dataset.lineId,
              anchorTokenId: span.dataset.tokenId,
              position: isLeft ? 'before' : 'after',
            });
          });

          lineDiv.appendChild(span);
        });

        // â€”â€” å•/åŒ/ä¸‰å‡»ï¼š1=åªé€‰ä¸­ï¼›2=è·³è½¬æ’­æ”¾ï¼›>=3=åœ¨è¯¥è¡Œåæ–°å»ºç©ºè¡Œ â€”â€” //
        if (!line.is_meta) {
          lineDiv.addEventListener('click', (e) => {
            // ç‚¹åˆ° token æˆ–å‰ç¼€è¾“å…¥æ¡†æ—¶ï¼Œä¸èµ°è¡Œçº§ç‚¹å‡»
            if (e.target.classList.contains('tok') || e.target.classList.contains('prefix-editor')) return;
            e.stopPropagation();

            const CLICK_DECISION_DELAY = 300; // msï¼Œç”¨äºåŒºåˆ†åŒå‡»/ä¸‰å‡»

            // åœ¨ DOM èŠ‚ç‚¹ä¸Šåšä¸€ä¸ªç®€å•çš„ç‚¹å‡»è®¡æ•°å™¨
            if (lineDiv._clickTimer) clearTimeout(lineDiv._clickTimer);
            lineDiv._clickCount = (lineDiv._clickCount || 0) + 1;

            lineDiv._clickTimer = setTimeout(async () => {
              const count = lineDiv._clickCount || 0;
              lineDiv._clickCount = 0;
              lineDiv._clickTimer = null;

              if (count >= 3) {
                // ä¸‰å‡»ï¼šåœ¨æ­¤è¡Œåæ–°å»ºç©ºè¡Œ
                await createEmptyLineAfter(line.id);
              } else if (count === 2) {
                // åŒå‡»ï¼šé€‰ä¸­å¹¶è·³è½¬æ’­æ”¾
                state.selectedTokenIds.clear();
                state.selectedLineId = line.id;
                renderDoc();
                startFromLine(line.id); // â† åŸæœ¬å•å‡»è§¦å‘çš„"è·³è½¬"ï¼Œç§»åˆ°åŒå‡»é‡Œ
              } else {
                // å•å‡»ï¼šåªé€‰ä¸­è¯¥è¡Œï¼Œä¸è·³è½¬
                state.selectedTokenIds.clear();
                state.selectedLineId = line.id;
                renderDoc();
              }
            }, CLICK_DECISION_DELAY);
          });

          lineDiv.addEventListener('dragover', (e) => {
            if (!state.doc) return; e.preventDefault();
            const rect = lineDiv.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            lineDiv.classList.toggle('drop-left', isLeft);
            lineDiv.classList.toggle('drop-right', !isLeft);
          });
          lineDiv.addEventListener('dragleave', () => {
            lineDiv.classList.remove('drop-left', 'drop-right');
          });
          lineDiv.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = lineDiv.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            lineDiv.classList.remove('drop-left', 'drop-right');
            await doDropMoveLine({ lineId: line.id, position: isLeft ? 'start' : 'end' });
          });
        }

        c.appendChild(lineDiv);
      });
      // æ¸²æŸ“ååˆ·æ–°ä¸€æ¬¡é«˜äº®ï¼ˆä¿æŒæ’­æ”¾ä¸­æ—¶ UI åŒæ­¥ï¼‰
      updateHighlight(getNowMs());
    }

    // å°†é€‰ä¸­çš„ token ID é›†åˆåˆå¹¶æˆè‹¥å¹²ä¸ª [start_id, end_id] çš„è¿ç»­åŒºé—´ï¼ˆé€è¡Œï¼‰
    function groupSelectionIntoRanges() {
      if (!state.doc) return [];
      const idToIndex = new Map();
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToIndex.set(tok.id, { li, ti, line_id: line.id });
        });
      });

      const selected = Array.from(state.selectedTokenIds)
        .map((id) => idToIndex.get(id))
        .filter(Boolean)
        .sort((a, b) => (a.li - b.li) || (a.ti - b.ti));

      const ranges = [];
      let i = 0;
      while (i < selected.length) {
        const { li, line_id } = selected[i];
        let startTi = selected[i].ti;
        let endTi = startTi;

        let j = i + 1;
        while (j < selected.length && selected[j].li === li && selected[j].ti === endTi + 1) {
          endTi = selected[j].ti;
          j++;
        }
        const line = state.doc.lines[li];
        const start_token_id = line.tokens[startTi].id;
        const end_token_id = line.tokens[endTi].id;
        ranges.push({ line_id, start_token_id, end_token_id });
        i = j;
      }
      return ranges;
    }

    async function doDropMove({ anchorLineId, anchorTokenId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) {
        setStatus('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„æ­Œè¯å—ï¼ˆå¯ Ctrl/âŒ˜ å¤šé€‰ï¼‰');
        return;
      }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: {
          type: 'anchor',
          line_id: anchorLineId,
          anchor_token_id: anchorTokenId,
          position: position // 'before' | 'after'
        }
      };

      const res = await apiFetch('/api/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('ç§»åŠ¨å¤±è´¥ï¼š' + text);
        return;
      }
      const doc = await res.json();
      state.doc = doc;
      // æˆåŠŸåé»˜è®¤æ¸…ç©ºé€‰æ‹©ï¼Œé¿å…è¯¯æ‹–
      state.selectedTokenIds.clear();
      renderDoc();
      setStatus('å·²å®Œæˆæ‹–æ”¾ç§»åŠ¨ã€‚');
      markDirty();
    }

    async function doDropMoveLine({ lineId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) { setStatus('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„æ­Œè¯å—ï¼ˆå¯ Ctrl/âŒ˜ å¤šé€‰ï¼‰'); return; }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: { type: 'line', line_id: lineId, position } // 'start' | 'end'
      };
      const res = await apiFetch('/api/move', {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });
      if (!res.ok) { const text = await res.text(); setStatus('ç§»åŠ¨å¤±è´¥ï¼š' + text); return; }
      const doc = await res.json();
      state.doc = doc; state.selectedTokenIds.clear(); renderDoc(); setStatus('å·²å®Œæˆæ‹–æ”¾ç§»åŠ¨ã€‚');
    }

    async function createEmptyLineAfter(afterLineId) {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }

      // è®°å½•å˜æ›´å‰çš„è¡Œ id é›†åˆï¼Œç”¨æ¥æ‰¾å‡º"æ–°è¡Œ"çš„ id
      const beforeIds = new Set(state.doc.lines.map(l => l.id));

      const res = await apiFetch('/api/newline', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          document_id: state.doc.id,
          base_version: state.doc.version,
          insert_after_line_id: afterLineId
        })
      });

      if (!res.ok) {
        const text = await res.text();
        setStatus('åˆ›å»ºç©ºè¡Œå¤±è´¥ï¼š' + text);
        return;
      }

      const newDoc = await res.json();
      // æ‰¾å‡ºæ–°å¢çš„é‚£ä¸€è¡Œ id
      let newLineId = null;
      for (const l of newDoc.lines) {
        if (!beforeIds.has(l.id)) { newLineId = l.id; break; }
      }

      state.doc = newDoc;
      state.selectedTokenIds.clear();
      state.selectedLineId = newLineId || afterLineId; // å…œåº•ï¼šæ‰¾ä¸åˆ°å°±é€‰åŸè¡Œ
      renderDoc();

      setStatus('å·²åœ¨è¯¥è¡Œååˆ›å»ºç©ºè¡Œ');
      markDirty();
    }

    async function insertEmptyLineBelow(afterLineId) {
      const res = await apiFetch('/api/newline', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, insert_after_line_id: afterLineId })
      });
      if (!res.ok) { const text = await res.text(); setStatus('æ’å…¥ç©ºè¡Œå¤±è´¥ï¼š' + text); return; }
      const doc = await res.json(); state.doc = doc; renderDoc(); setStatus('å·²æ’å…¥ç©ºè¡Œã€‚');
      markDirty();
    }

    async function commitPrefix(lineId, value) {
      if (!state.doc) return;
      const v = String(value || '').trim();
      const res = await apiFetch('/api/set_prefix', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, line_id: lineId, prefix_int: v === '' ? "" : v })
      });
      if (!res.ok) { return; }
      const doc = await res.json(); state.doc = doc; renderDoc();
      markDirty();
    }

    function collectSelectedTokens() {
      if (!state.doc) return [];
      const idToTok = new Map();
      const order = [];
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToTok.set(tok.id, { tok, li, ti, line_id: line.id });
          order.push({ id: tok.id, li, ti });
        });
      });
      const arr = Array.from(state.selectedTokenIds).map(id => idToTok.get(id)).filter(Boolean);
      arr.sort((a,b)=> (a.li-b.li)||(a.ti-b.ti));
      return arr;
    }

    function handleCopy() {
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        const tokens = sels.map(s => ({ text: s.tok.text, ts: s.tok.ts }));
        state.clipboard = { tokens, fromLineId: sels[0].line_id };
        setStatus('å·²å¤åˆ¶æ‰€é€‰æ­Œè¯å—ã€‚');
        return true;
      }
      if (state.selectedLineId) {
        const line = state.doc.lines.find(ln => ln.id === state.selectedLineId);
        if (line && !line.is_meta && line.tokens.length) {
          const tokens = line.tokens.map(t => ({ text: t.text, ts: t.ts }));
          state.clipboard = { tokens, fromLineId: line.id };
          setStatus('å·²å¤åˆ¶æ•´è¡Œæ­Œè¯ã€‚');
          return true;
        }
      }
      setStatus('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹');
      return false;
    }

    function resolveActiveLineId() {
      if (!state.doc) return null;
      if (state.selectedLineId) return state.selectedLineId;
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        return sels[0].line_id;
      }
      return null;
    }

    async function setSelectedLineQuickPrefix(prefixValue) {
      const lineId = resolveActiveLineId();
      if (!lineId) {
        setStatus('è¯·å…ˆé€‰ä¸­è¦è°ƒæ•´å‰ç¼€çš„æ­Œè¯è¡Œã€‚');
        return;
      }
      const currentLineIndex = state.doc.lines.findIndex((ln) => ln.id === lineId);
      if (currentLineIndex === -1) {
        setStatus('æœªæ‰¾åˆ°ç›®æ ‡æ­Œè¯è¡Œã€‚');
        return;
      }
      const line = state.doc.lines[currentLineIndex];
      if (!line || line.is_meta) {
        setStatus('è¯¥å¿«æ·é”®ä»…é€‚ç”¨äºæ™®é€šæ­Œè¯è¡Œã€‚');
        return;
      }
      const current = line.prefix ? (/\[([^\]]*)\]/.exec(line.prefix || '')?.[1] ?? '') : '';
      const desired = (prefixValue === null || typeof prefixValue === 'undefined') ? '' : String(prefixValue);
      const nextLineId = (() => {
        for (let i = currentLineIndex + 1; i < state.doc.lines.length; i++) {
          const candidate = state.doc.lines[i];
          if (!candidate.is_meta) return candidate.id;
        }
        return null;
      })();
      const displayValue = desired === '' ? '[]' : desired;
      if (current === desired) {
        state.selectedLineId = nextLineId || lineId;
        state.selectedTokenIds.clear();
        renderDoc();
        setStatus(`è¯¥è¡Œå‰ç¼€å·²æ˜¯ ${displayValue}ï¼Œå·²é€‰ä¸­${nextLineId ? 'ä¸‹ä¸€è¡Œ' : 'å½“å‰è¡Œ'}ã€‚`);
        return;
      }
      state.selectedLineId = lineId;
      await commitPrefix(lineId, desired);
      if (nextLineId) {
        state.selectedLineId = nextLineId;
      }
      state.selectedTokenIds.clear();
      renderDoc();
      setStatus(`å·²å°†è¯¥è¡Œå‰ç¼€è®¾ç½®ä¸º ${displayValue}ï¼Œå·²é€‰ä¸­${nextLineId ? 'ä¸‹ä¸€è¡Œ' : 'å½“å‰è¡Œ'}ã€‚`);
    }

    async function handlePaste() {
      if (!state.clipboard || !state.doc) { setStatus('å‰ªè´´æ¿ä¸ºç©º'); return; }
      const items = state.clipboard.tokens || [];
      if (items.length === 0) { setStatus('å‰ªè´´æ¿ä¸ºç©º'); return; }

      // ä¼˜å…ˆï¼šè‹¥é€‰ä¸­äº† tokenï¼Œåˆ™ç²˜è´´åˆ°å…¶å³è¾¹ï¼ˆå–è¯¥è¡Œä¸­é€‰ä¸­çš„æœ€å³ä¸€ä¸ª token ç´¢å¼•+1ï¼‰
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        const lineId = sels[0].line_id;
        const line = state.doc.lines.find(ln => ln.id === lineId);
        const lastTi = Math.max(...sels.filter(s=>s.line_id===lineId).map(s=>s.ti));
        await insertTokens(lineId, lastTi + 1, items);
        return;
      }
      // å¦åˆ™ï¼šè‹¥é€‰ä¸­è¡Œï¼Œåˆ™ç²˜è´´åˆ°è¯¥è¡Œæœ€å·¦
      if (state.selectedLineId) {
        await insertTokens(state.selectedLineId, 0, items);
        return;
      }
      setStatus('è¯·å…ˆé€‰ä¸­ä¸€ä¸ªç›®æ ‡ï¼ˆtokenæˆ–è¡Œï¼‰å†ç²˜è´´');
    }

    async function insertTokens(lineId, insertAt, tokens) {
      const res = await apiFetch('/api/insert_tokens', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, line_id: lineId, insert_at: insertAt, tokens })
      });
      if (!res.ok) { const text = await res.text(); setStatus('ç²˜è´´å¤±è´¥ï¼š' + text); return; }
      const doc = await res.json(); state.doc = doc; state.selectedTokenIds.clear(); renderDoc(); setStatus('å·²ç²˜è´´ã€‚');
      markDirty();
    }

    // ---- åŸºç¡€ API è°ƒç”¨ï¼ˆå¯¼å…¥ã€ä¿å­˜ã€æ’¤é”€ã€é‡åšï¼‰ ----
    async function loadFromServer(jsonFile) {
      if (!jsonFile) {
        setStatus('ç¼ºå°‘ JSON æ–‡ä»¶å');
        return;
      }
      setStatus('æ­£åœ¨åŠ è½½æ­Œæ›²æ•°æ®...');
      const res = await apiFetch('/api/load', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonFile })
      });
      const data = await res.json();
      if (!res.ok || data.status !== 'success') {
        throw new Error(data.message || 'åŠ è½½å¤±è´¥');
      }
      applyDoc(data.doc, {
        jsonFile,
        lyricsPath: data.lyricsPath || '',
        translationPath: data.translationPath || '',
        songUrl: data.songUrl || '',
        displayName: data.title || data.jsonFile || jsonFile,
        updatedJson: !!data.updatedJson
      });
      if (data.songUrl) {
        loadMediaUrl(data.songUrl);
      }
      setStatus(`å·²åŠ è½½ï¼š${state.context.displayName || jsonFile}`);
    }

    async function importLys(file) {
      // è‹¥å·²æœ‰æ•°æ®ï¼Œå…ˆè¯¢é—®ï¼›å…è®¸æ’¤é”€æœ¬æ¬¡å¯¼å…¥
      if (hasDocData()) {
        const ok = confirm('å½“å‰é¡µé¢å·²æœ‰æ•°æ®ï¼Œå¯¼å…¥æ–°æ–‡ä»¶å°†æ›¿æ¢å½“å‰æ–‡æ¡£ã€‚\nç¡®å®šç»§ç»­ï¼Ÿ\nï¼ˆæç¤ºï¼šå¯¼å…¥åå¯ç‚¹å‡»"æ’¤é”€å¯¼å…¥"æ¢å¤ï¼‰');
        if (!ok) { setStatus('å·²å–æ¶ˆå¯¼å…¥'); return; }
        // è®°å½•å¯¼å…¥å‰å¿«ç…§ï¼Œä»¥ä¾¿æ’¤é”€å¯¼å…¥
        state.lastImportBackup = {
          doc: state.doc,
          selectedLineId: state.selectedLineId,
          selectedTokenIds: new Set(state.selectedTokenIds),
          unsaved: state.unsaved,
          context: { ...state.context },
        };
        $('#btnUndoImport').style.display = 'inline-block';
      } else {
        state.lastImportBackup = null;
        $('#btnUndoImport').style.display = 'none';
      }
      const fd = new FormData();
      fd.append('file', file);
      const res = await apiFetch('/api/import', { method: 'POST', body: fd });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || 'å¯¼å…¥å¤±è´¥');
      }
      const doc = await res.json();
      applyDoc(doc, {
        jsonFile: '',
        lyricsPath: '',
        translationPath: '',
        songUrl: '',
        displayName: file.name || ''
      });
    }

    async function saveToServer() {
      if (!state.doc) { setStatus('è¯·å…ˆåŠ è½½æ­Œè¯'); return; }
      if (!state.context.jsonFile) {
        setStatus('å½“å‰æ–‡æ¡£æœªç»‘å®šç®¡ç†æ­Œæ›²ï¼Œæ— æ³•ä¿å­˜', 'error');
        return;
      }
      const res = await apiFetch('/api/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ doc_id: state.doc.id })
      });
      const data = await res.json();
      if (!res.ok || data.status !== 'success') {
        setStatus('ä¿å­˜å¤±è´¥ï¼š' + (data.message || res.statusText), 'error');
        return;
      }
      clearDirty();
      setStatus('ä¿å­˜æˆåŠŸï¼š' + (data.lyricsPath || 'æ­Œè¯æ–‡ä»¶'), 'success');
    }

    function undoImport() {
      if (!state.lastImportBackup) { setStatus('æ²¡æœ‰å¯æ’¤é”€çš„å¯¼å…¥'); return; }
      const b = state.lastImportBackup;
      state.doc = b.doc;
      state.selectedLineId = b.selectedLineId || null;
      state.selectedTokenIds = new Set(b.selectedTokenIds || []);
      state.unsaved = !!b.unsaved;
      state.context = b.context ? { ...b.context } : state.context;
      renderDoc();
      $('#btnUndoImport').style.display = 'none';
      setStatus('å·²æ’¤é”€å¯¼å…¥ï¼Œæ¢å¤åˆ°å¯¼å…¥å‰çš„æ–‡æ¡£ã€‚');
    }

    function markDirty() {
      state.unsaved = true;
      // æœ‰æ•°æ®å³æ‹¦æˆªå…³é—­ï¼Œè¿™é‡Œä¸é¢å¤–è®¾ç½®ï¼›ç»Ÿä¸€åœ¨ beforeunload å›è°ƒé‡Œåˆ¤æ–­
      renderDoc(); // åˆ·æ–°æ ‡é¢˜æç¤ºå°åœ†ç‚¹
    }
    function clearDirty() {
      state.unsaved = false;
      renderDoc();
    }

    async function undo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/undo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('æ— æ³•æ’¤é”€'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
      markDirty();
    }

    async function redo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/redo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('æ— æ³•é‡åš'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
      markDirty();
    }

    async function sortLines() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥æ–‡æ¡£'); return; }
      
      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version
      };
      
      const res = await apiFetch('/api/sort_lines', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (!res.ok) {
        const text = await res.text();
        setStatus('æ’åºå¤±è´¥ï¼š' + text);
        return;
      }
      
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
      setStatus('æ­Œè¯è¡Œå·²æŒ‰æ—¶é—´é¡ºåºæ’åºå®Œæˆ');
      markDirty();
    }

    // ======== æ’­æ”¾å™¨é€»è¾‘ ========
    function ensureMediaEl() {
      if (!state.playback.mediaEl) {
        const v = document.createElement('video');
        v.id = 'player';
        v.controls = true; // å…è®¸ç”¨æˆ·æ§åˆ¶
        v.style.maxWidth = '100%';
        v.style.display = 'block';
        v.style.marginTop = '10px';
        // æ”¾åˆ°ç”¨æ³•é¢æ¿ä¸‹ï¼ˆæ›´è‡ªç„¶ï¼‰
        const panel = document.querySelectorAll('.panel')[1];
        panel.appendChild(v);
        state.playback.mediaEl = v;
        // å½“åª’ä½“æ’­æ”¾/æš‚åœæ—¶ï¼ŒåŒæ­¥æŒ‰é’®çŠ¶æ€
        v.addEventListener('play', () => { state.playback.playing = true; startLoop(); syncPlayButton(); });
        v.addEventListener('pause', () => { state.playback.playing = false; stopLoop(); syncPlayButton(); });
        v.addEventListener('seeked', () => { updateHighlight(getNowMs()); });
        v.addEventListener('timeupdate', () => { updateHighlight(getNowMs()); });
        v.addEventListener('ended', () => { state.playback.playing = false; stopLoop(); syncPlayButton(); });
      }
      return state.playback.mediaEl;
    }

    function loadMediaUrl(url) {
      if (!url) return;
      const v = ensureMediaEl();
      v.src = url;
      v.load();
      state.playback.usingMedia = true;
      $('#btnPlayPause').disabled = false;
      setStatus('å·²åŠ è½½éŸ³ä¹ï¼š' + url);
    }

    function loadMediaFile(file) {
      const v = ensureMediaEl();
      const url = URL.createObjectURL(file);
      v.src = url;
      v.load();
      state.playback.usingMedia = true;
      $('#btnPlayPause').disabled = false;
      setStatus('å·²åŠ è½½åª’ä½“ï¼š' + (file.name || '')); 
    }

    function getNowMs() {
      if (state.playback.usingMedia && state.playback.mediaEl) {
        return (state.playback.mediaEl.currentTime || 0) * 1000;
      }
      // æ—¶é’Ÿæ¨¡å¼
      return state.playback.clockStartOffset + (state.playback.playing ? (performance.now() - state.playback.clockStartEpoch) : 0);
    }

    function play() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.play();
      } else {
        // æ— åª’ä½“ï¼Œä½¿ç”¨æ—¶é’Ÿ
        state.playback.playing = true;
        state.playback.clockStartEpoch = performance.now();
        startLoop();
        syncPlayButton();
      }
    }

    function pause() {
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.pause();
      } else {
        // æ—¶é’Ÿæš‚åœ
        state.playback.clockStartOffset = getNowMs();
        state.playback.playing = false;
        stopLoop();
        syncPlayButton();
      }
    }

    function togglePlay() {
      if (state.playback.playing) pause(); else play();
    }

    function seekMs(ms) {
      ms = Math.max(0, ms|0);
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.currentTime = ms / 1000;
      } else {
        state.playback.clockStartOffset = ms;
        if (state.playback.playing) state.playback.clockStartEpoch = performance.now();
        updateHighlight(getNowMs());
      }
    }

    function startFromLine(lineId) {
      if (!state.doc) return;
      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || !line.tokens || line.tokens.length === 0) return;
      // æ‰¾åˆ°è¯¥è¡Œæœ€æ—©çš„ start
      let minStart = Infinity;
      for (const t of line.tokens) {
        if (!t.ts) continue;
        const [s, d] = String(t.ts).split(',').map(x=>parseInt(x,10));
        if (Number.isFinite(s)) minStart = Math.min(minStart, s);
      }
      if (!Number.isFinite(minStart)) return;
      seekMs(minStart);
      // è‹¥æœªæ’­æ”¾åˆ™å¼€å§‹
      if (!state.playback.playing) play();
    }

    function syncPlayButton() {
      $('#btnPlayPause').textContent = state.playback.playing ? 'æš‚åœ' : 'æ’­æ”¾';
    }

    function startLoop() {
      cancelAnimationFrame(state.playback.rafId);
      const loop = () => {
        updateHighlight(getNowMs());
        state.playback.rafId = requestAnimationFrame(loop);
      };
      state.playback.rafId = requestAnimationFrame(loop);
    }

    function stopLoop() {
      cancelAnimationFrame(state.playback.rafId);
    }

    function updateHighlight(nowMs) {
      // é«˜äº® tokenï¼ŒåŠå…¶æ‰€åœ¨è¡Œ
      const activeLines = new Set();
      for (const item of state.tokenCache) {
        const active = nowMs >= item.start && nowMs < item.end;
        item.el.classList.toggle('active', !!active);
        if (active) activeLines.add(item.lineId);
      }
      // è¡Œçº§æ ‡è®°
      document.querySelectorAll('.line').forEach(ln => {
        const lid = ln.dataset.lineId;
        ln.classList.toggle('playing', activeLines.has(lid));
      });
    }

    // âœ… æ–°å¢ï¼šä¼˜å…ˆä»¥"é€‰ä¸­çš„æœ€é å‰è¯æ‰€åœ¨è¡Œ"ä¸ºç›®æ ‡ï¼›å¦åˆ™å›é€€åˆ°é€‰ä¸­è¡Œ
    async function alignSelectedToNow() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }

      // 1) è‹¥æœ‰é€‰ä¸­ tokenï¼Œåˆ™å–æ–‡æ¡£é¡ºåºæœ€é å‰çš„é‚£ä¸ª
      const sels = collectSelectedTokens();
      let lineId = null;
      if (sels.length > 0) {
        lineId = sels[0].line_id;
      } else if (state.selectedLineId) {
        // 2) å¦åˆ™ç”¨é€‰ä¸­çš„è¡Œ
        lineId = state.selectedLineId;
      } else {
        setStatus('è¯·å…ˆé€‰ä¸­ä¸€ä¸ªè¯æˆ–ç‚¹å‡»é€‰ä¸­ä¸€è¡Œ');
        return;
      }

      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || line.is_meta) { setStatus('è¯¥è¡Œä¸å¯å¯¹é½ï¼ˆmetaæˆ–ä¸å­˜åœ¨ï¼‰'); return; }
      if (!line.tokens || line.tokens.length === 0) { setStatus('è¯¥è¡Œæ²¡æœ‰å¯å¯¹é½çš„æ­Œè¯'); return; }

      // â€”â€” å–"è¯¥è¡Œä¸­ç¬¬ä¸€ä¸ªæœ‰åˆæ³•æ—¶é—´æˆ³çš„è¯"çš„å¼€å§‹æ—¶é—´ï¼ˆé¡ºåºæ‰«æï¼‰
      let firstStart = null;
      for (const t of line.tokens) {
        const ts = (t.ts || '');
        if (!ts.includes(',')) continue;
        const s = parseInt(ts.split(',')[0], 10);
        if (Number.isFinite(s)) { firstStart = s; break; }
      }
      if (!Number.isFinite(firstStart)) { setStatus('è¯¥è¡Œæ²¡æœ‰åˆæ³•æ—¶é—´æˆ³å¯å¯¹é½'); return; }

      const now = getNowMs();
      const delay = Number(state.settings.keyDelayMs || 0);
      const delta = Math.round((now + delay) - firstStart);

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        line_id: lineId,
        delta_ms: delta
      };

      const res = await apiFetch('/api/shift_line', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) { const text = await res.text(); setStatus('å¯¹é½å¤±è´¥ï¼š' + text); return; }

      state.doc = await res.json();
      renderDoc();
      const sign = delta >= 0 ? '+' : '';
      setStatus(`å·²å¯¹é½ï¼šä»¥è¯¥è¡Œç¬¬ä¸€ä¸ªè¯ä¸ºå‚ç…§ï¼ˆå»¶è¿Ÿ ${delay|0}msï¼ŒÎ”=${sign}${delta}msï¼‰ã€‚`);
      markDirty();
    }

    // æ—§å‡½æ•°å¯ä¿ç•™ä½œä¸ºåå¤‡
    async function alignSelectedLineToNow() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }
      const lineId = state.selectedLineId;
      if (!lineId) { setStatus('è¯·å…ˆé€‰ä¸­ä¸€æ•´è¡Œï¼ˆç‚¹å‡»è¡Œç©ºç™½å¤„å³å¯é€‰ä¸­è¯¥è¡Œï¼‰'); return; }

      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || line.is_meta) { setStatus('è¯¥è¡Œä¸å¯å¯¹é½ï¼ˆmetaæˆ–ä¸å­˜åœ¨ï¼‰'); return; }
      if (!line.tokens || line.tokens.length === 0) { setStatus('è¯¥è¡Œæ²¡æœ‰å¯å¯¹é½çš„æ­Œè¯'); return; }

      // æ‰¾åˆ°è¯¥è¡Œ"é¦–ä¸ª"åˆæ³•æ—¶é—´æˆ³çš„å¼€å§‹æ—¶é—´ï¼ˆå–æœ€å° startï¼‰
      let firstStart = Infinity;
      for (const t of line.tokens) {
        const ts = (t.ts || '');
        if (!ts.includes(',')) continue;
        const parts = ts.split(',');
        const s = parseInt(parts[0], 10);
        if (Number.isFinite(s)) firstStart = Math.min(firstStart, s);
      }
      if (!Number.isFinite(firstStart)) { setStatus('è¯¥è¡Œæ²¡æœ‰åˆæ³•æ—¶é—´æˆ³å¯å¯¹é½'); return; }

      const now = getNowMs();
      const delay = Number(state.settings.keyDelayMs || 0);
      const delta = Math.round((now + delay) - firstStart); // è®© firstStart å¯¹é½åˆ° now+delay

      // Î” ä¸º 0 ä¹Ÿå…è®¸æäº¤ï¼Œä»¥ä¾¿è¿›å…¥æ’¤é”€æ ˆï¼›ä½†åšä¸ªæç¤º
      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        line_id: lineId,
        delta_ms: delta
      };

      const res = await apiFetch('/api/shift_line', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('å¯¹é½å¤±è´¥ï¼š' + text);
        return;
      }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();

      const sign = delta >= 0 ? '+' : '';
      setStatus(`å·²å¯¹é½è¯¥è¡Œåˆ°å½“å‰æ—¶é—´ï¼ˆå»¶è¿Ÿ ${delay|0}msï¼ŒÎ”=${sign}${delta}msï¼‰ã€‚`);
      markDirty();
    }

    async function setLastTokenDurationToNow() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }

      // åªæ¥å—"é€‰ä¸­è¡Œ"ã€‚è‹¥æœªé€‰ä¸­è¡Œï¼Œå°è¯•ä»æ‰€é€‰ token æ¨æ–­å…¶æ‰€åœ¨è¡Œï¼ˆå…œåº•ï¼‰ã€‚
      let lineId = state.selectedLineId;
      if (!lineId) {
        const sels = collectSelectedTokens();
        if (sels.length > 0) {
          lineId = sels[sels.length - 1].line_id; // å–æœ€åä¸€ä¸ªæ‰€é€‰ token æ‰€åœ¨è¡Œ
        } else {
          setStatus('è¯·å…ˆé€‰ä¸­ä¸€è¡Œï¼ˆç‚¹å‡»è¡Œç©ºç™½å¤„å³å¯é€‰ä¸­è¯¥è¡Œï¼‰');
          return;
        }
      }

      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || line.is_meta) { setStatus('è¯¥è¡Œä¸å¯æ“ä½œï¼ˆmetaæˆ–ä¸å­˜åœ¨ï¼‰'); return; }
      if (!line.tokens || line.tokens.length === 0) { setStatus('è¯¥è¡Œæ²¡æœ‰å¯æ“ä½œçš„æ­Œè¯'); return; }

      // ä»åå¾€å‰æ‰¾"æœ€åä¸€ä¸ªå¸¦åˆæ³•æ—¶é—´æˆ³"çš„ token
      let lastTok = null;
      let startMs = null;
      for (let i = line.tokens.length - 1; i >= 0; i--) {
        const t = line.tokens[i];
        const ts = (t.ts || '');
        if (!ts.includes(',')) continue;
        const s = parseInt(ts.split(',')[0], 10);
        if (Number.isFinite(s)) { lastTok = t; startMs = s; break; }
      }
      if (!lastTok || !Number.isFinite(startMs)) { setStatus('è¯¥è¡Œæ²¡æœ‰åˆæ³•æ—¶é—´æˆ³å¯è®¾ç½®'); return; }

      const now = getNowMs();                // å½“å‰æ’­æ”¾æ—¶é—´ï¼ˆåª’ä½“æˆ–æ—¶é’Ÿï¼‰
      const newDur = Math.max(0, Math.round(now - startMs));  // åªæ”¹æŒç»­æ—¶é—´

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        line_id: lineId,
        duration_ms: newDur
      };

      const res = await apiFetch('/api/set_last_token_duration', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('è®¾ç½®å¤±è´¥ï¼š' + text);
        return;
      }
      state.doc = await res.json();
      renderDoc();
      setStatus(`å·²è®¾ç½®ï¼šæœ€åä¸€å­—æŒç»­ ${newDur}msï¼ˆstart=${startMs}ms â†’ end=${startMs + newDur}msï¼‰`);
      markDirty();
    }

    function init() {
      updateDocInfo();
      $('#btnImport').addEventListener('click', async () => {
        const f = $('#fileInput').files[0];
        if (!f) { setStatus('è¯·é€‰æ‹©ä¸€ä¸ª .lys æ–‡ä»¶'); return; }
        try {
          await importLys(f);
          setStatus('å¯¼å…¥æˆåŠŸã€‚');
        } catch (e) {
          setStatus(String(e));
        }
      });
      // æ’¤é”€å¯¼å…¥
      $('#btnUndoImport').addEventListener('click', undoImport);

      $('#btnSave').addEventListener('click', saveToServer);
      $('#btnUndo').addEventListener('click', undo);
      $('#btnRedo').addEventListener('click', redo);
      $('#btnSortLines').addEventListener('click', sortLines);
      $('#btnPlayPause').addEventListener('click', togglePlay);
      $('#mediaInput').addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) loadMediaFile(f);
      });

      // âœ… åªåœ¨ç‚¹å‡»å®¹å™¨çœŸæ­£çš„ç©ºç™½å¤„ï¼ˆä¸åœ¨ä»»ä½• .line å†…éƒ¨ï¼‰æ—¶æ¸…ç©ºé€‰æ‹©
      $('#lines').addEventListener('click', (e) => {
        if (e.target.closest('.line')) return;  // â† åœ¨æŸä¸€è¡Œå†…éƒ¨å°±åˆ«æ¸…
        state.selectedTokenIds.clear();
        state.selectedLineId = null;
        renderDoc();
      });

      // â€”â€” æŒ‰é”®å»¶è¿Ÿè®¾ç½® â€”â€” //
      const delayInput = $('#keyDelayInput');
      // è¯»å–æœ¬åœ°ä¿å­˜
      const savedDelay = parseInt(localStorage.getItem('keyDelayMs') || '0', 10);
      if (Number.isFinite(savedDelay)) {
        state.settings.keyDelayMs = savedDelay;
        delayInput.value = String(savedDelay);
      }
      // å˜æ›´å³ä¿å­˜
      delayInput.addEventListener('change', () => {
        const v = parseInt(delayInput.value, 10);
        if (Number.isFinite(v)) {
          state.settings.keyDelayMs = v;
          localStorage.setItem('keyDelayMs', String(v));
        } else {
          state.settings.keyDelayMs = 0;
          delayInput.value = '';
          localStorage.removeItem('keyDelayMs');
        }
      });

      // é”®ç›˜å¤åˆ¶/ç²˜è´´
      document.addEventListener('keydown', async (e) => {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC')>=0;
        const key = e.key.toLowerCase();
        const copyCombo = (isMac ? e.metaKey : e.ctrlKey) && key === 'c';
        const pasteCombo = (isMac ? e.metaKey : e.ctrlKey) && key === 'v';
        if (copyCombo) { e.preventDefault(); handleCopy(); }
        if (pasteCombo) { e.preventDefault(); await handlePaste(); }
        // ç©ºæ ¼ æ’­æ”¾/æš‚åœ
        if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
        // Fï¼šè®©"é€‰ä¸­çš„ç¬¬ä¸€ä¸ªè¯æ‰€åœ¨è¡Œ"æˆ–"é€‰ä¸­è¡Œ"ä»æ­¤åˆ»å¼€å§‹ï¼ˆåŒ…å«æŒ‰é”®å»¶è¿Ÿï¼‰
        const prefixKeyMap = { w: '', a: '4', s: '6', d: '5' };
        if (!e.repeat && Object.prototype.hasOwnProperty.call(prefixKeyMap, key)) {
          const tag = (e.target && e.target.tagName) || '';
          if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
          e.preventDefault();
          await setSelectedLineQuickPrefix(prefixKeyMap[key]);
          return;
        }
        if (!e.repeat && key === 'f') {
          const tag = (e.target && e.target.tagName) || '';
          if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
          e.preventDefault();
          await alignSelectedToNow();    // â† æ”¹æˆè¿™ä¸ª
        }
        // ğŸ‘‰ æ–°å¢ï¼šH é”®â€”â€”æŠŠé€‰ä¸­è¡Œçš„"æœ€åä¸€ä¸ªå­—"ç»“æŸåˆ°æ­¤åˆ»ï¼ˆåªæ”¹æŒç»­æ—¶é—´ï¼‰
        if (!e.repeat && key === 'h') {
          const tag = (e.target && e.target.tagName) || '';
          if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;
          e.preventDefault();
          await setLastTokenDurationToNow();
        }
      });

      // è‡ªåŠ¨åŠ è½½æ¥è‡ªç®¡ç†é¡µçš„ JSON æˆ–åç«¯é¢„æ¸²æŸ“æ•°æ®
      if (PRELOADED_DATA && PRELOADED_DATA.status === 'success' && PRELOADED_DATA.doc) {
        applyDoc(PRELOADED_DATA.doc, {
          jsonFile: PRELOADED_DATA.jsonFile || PRELOAD_JSON_FILE || '',
          lyricsPath: PRELOADED_DATA.lyricsPath || '',
          translationPath: PRELOADED_DATA.translationPath || '',
          songUrl: PRELOADED_DATA.songUrl || '',
          displayName: PRELOADED_DATA.title || PRELOADED_DATA.jsonFile || PRELOAD_JSON_FILE || '',
          updatedJson: !!PRELOADED_DATA.updatedJson
        });
        if (PRELOADED_DATA.songUrl) {
          loadMediaUrl(PRELOADED_DATA.songUrl);
        }
        setStatus(`å·²åŠ è½½ï¼š${state.context.displayName || PRELOAD_JSON_FILE}`);
      } else if (PRELOAD_JSON_FILE) {
        loadFromServer(PRELOAD_JSON_FILE).catch((err) => {
          setStatus(err.message || String(err));
        });
      }

      // åˆå§‹ï¼šè‹¥æœªåŠ è½½åª’ä½“ï¼Œä¹Ÿå…è®¸æ—¶é’Ÿæ’­æ”¾ï¼ˆä½†éœ€å¯¼å…¥ doc åæ‰èƒ½æ’­æ”¾ï¼‰
      $('#btnPlayPause').disabled = true;

      // å…³é—­/åˆ·æ–°è¯¢é—®ï¼šä»…åœ¨å­˜åœ¨æœªä¿å­˜å˜æ›´æ—¶æé†’
      window.addEventListener('beforeunload', (e) => {
        if (state.unsaved) {
          e.preventDefault();
          e.returnValue = '';
          return '';
        }
      });
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
