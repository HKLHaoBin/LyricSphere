<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态歌词展示</title>
    <style>
        :root {
            --rcolor: 1;
            --color: 0.25;
            --lyric-scale: 1;
            --lyric-scale-duration: 360ms;
            --lyric-scale-easing: cubic-bezier(0.32, 0.78, 0.12, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #121212;
            color: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            cursor: pointer;
            position: relative; /* 为背景容器提供定位上下文 */
        }

        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .background-container img,
        .background-container video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 等比缩放填充，无裁切 */
            opacity: 0.2; /* 20% 不透明度 */
            display: block;
        }

        .background-container canvas {
            width: 100%;
            height: 100%;
            display: block;
            opacity: 0.45;
        }

        .player-container {
            width: 90%;
            text-align: center;
        }

        :where(#albumSidePanel, #amll-stub-host, body) .song-info-container {
            box-sizing: border-box;
            width: min(100%, 520px);
            max-width: min(100%, 520px);
            margin: 0 auto;
        }

        :where(#albumSidePanel, #amll-stub-host, body) #albumCoverContainer {
            width: min(320px, 60vw);
            max-width: min(320px, 60vw);
        }

        :where(#albumSidePanel, #amll-stub-host, body) #albumInfo {
            width: 100% !important;
            max-width: 100% !important;
        }

        :where(#albumSidePanel, #amll-stub-host, body) #songTitle,
        :where(#albumSidePanel, #amll-stub-host, body) #songArtist {
            display: block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-container.paused-mode {
            height: 100%;
            overflow: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE 10+ */
        }

        .player-container.paused-mode::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        /* 隐藏音频控件 */
        audio {
            display: none;
        }

        .lyrics-container {
            min-height: 15em; /* 使用 min-height 保证初始高度 */
            overflow: hidden; /* 隐藏动画中可能溢出的部分 */
            position: relative; /* 为绝对定位的子元素提供基准 */
            display: -webkit-flex;
            display: flex;
            -webkit-flex-direction: column;
            flex-direction: column;
            -webkit-justify-content: center;
            justify-content: center;
            -webkit-align-items: center;
            align-items: center;
        }

        .lyric-line {
            position: relative;
            font-size: calc(4.5em * var(--lyric-scale, 1));
            font-weight: bold;
            line-height: 1.5;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.2); /* 白色 20% 不透明 */
            width: 100%;
            word-break: keep-all;
            white-space: normal;
            overflow: hidden;
            transition:
                font-size var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1)),
                line-height var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1));
        }

        /* 对于“侵入式”连体字体，允许溢出显示，避免字形被裁 */
        .lyric-line.allow-overflow {
            overflow: visible;
        }
        .lyric-line.allow-overflow .blur-layer,
        .lyric-line.allow-overflow .syllable,
        .lyric-line.allow-overflow .blur-text,
        .lyric-line.allow-overflow .word-wrapper {
            overflow: visible !important;
        }

        /* 模糊层容器 */
        .blur-layer {
            position: absolute;
            left: 0;
            width: 100%;
            --blur-safe-pad: 24px; /* 更大的垂直安全边距以适配高 x-height 字体 */
            top: calc(var(--blur-safe-pad) * -0.5);
            height: calc(100% + var(--blur-safe-pad));
            display: flex;
            flex-wrap: wrap;
            justify-content: inherit;
            align-items: inherit;
            z-index: -1;
            pointer-events: none;
        }

        .lyric-line.allow-overflow .blur-layer {
            overflow: visible;
        }

        /* 模糊文本 */
        .blur-text {
            color: white;
            opacity: 0.1;
            filter: blur(8px);
            font-size: inherit;
            font-weight: inherit;
            line-height: inherit;
        }

        .lyric-line.left-aligned {
            justify-content: flex-start;
            text-align: left;
        }

        .lyric-line.center-aligned {
            justify-content: center;
            text-align: center;
        }

        .lyric-line.right-aligned {
            justify-content: flex-end;
            text-align: right;
        }

        .lyric-line.small-font {
            font-size: calc(2.25em * var(--lyric-scale, 1)); /* 继承缩放比，保持背景歌词更小 */
        }

        .syllable {
            position: relative;
            display: inline-block;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.4); /* 柔和发光效果 */
            filter: blur(0);
            -webkit-filter: blur(0);
            background-repeat: no-repeat;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            flex-shrink: 0;
            white-space: nowrap;
            transform: translateY(0); /* 为逐音节上浮动画设定基线 */
            will-change: transform, background-position;
            margin-top: 0.05em;
            margin-bottom: 0.05em;
        }

        /* 自定义字体行：禁用卡拉OK渐变，直接用纯色，防止字形互相遮挡 */
        .syllable.no-gradient {
            background: none !important;
            background-image: none !important;
            background-size: auto !important;
            background-position: initial !important;
            background-repeat: initial !important;
            background-clip: initial !important;
            -webkit-background-clip: initial !important;
            color: rgba(255, 255, 255, 0.95);
            -webkit-text-fill-color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.35);
        }

        .syllable.non-latin,
        .blur-text.non-latin {
            white-space: normal;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .syllable.non-latin {
            flex-shrink: 1;
        }

        .word-wrapper {
            display: inline-flex;
            flex: 0 0 auto;
            flex-wrap: nowrap;
        }

        .word-space {
            display: inline-flex;
            flex: 0 0 auto;
            white-space: pre;
        }

        .lyric-line.active {
            /*background: rgba(255,255,255,0.08);  可选：高亮当前行 */
            border-radius: 0.2em;
        }

        .amll-main-line {
            margin: -1em;
            padding: 1em;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.35);
        }

        .amll-main-line span {
            display: inline-block;
        }

        .amll-main-line > span,
        .amll-emphasize-wrapper {
            white-space: pre-wrap;
            display: inline-block;
            padding: 1em;
            margin: -1em;
            will-change: transform;
        }

        .amll-emphasize,
        .amll-emphasize-wrapper span.amll-emphasize {
            padding: 1em;
            margin: -1em;
            backface-visibility: hidden;
        }

        .amll-emphasize > span {
            padding: 1em;
            margin: -1em;
            will-change: transform;
            backface-visibility: hidden;
        }

        .amll-roman-word {
            font-size: 0.5em;
            line-height: 1em;
        }
        /* 新增：翻译行对齐样式 */
        .translation-line.left-aligned {
            text-align: left;
        }
        .translation-line.center-aligned {
            text-align: center;
        }
        .translation-line.right-aligned {
            text-align: right;
        }
        .translation-line {
            transition:
                font-size var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1)),
                line-height var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1));
        }

        .font-slider-container {
            display: none; /* 默认隐藏 */
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        #font-load-tip {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 14px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1200;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }
        
        /* 仅在手机等小屏幕设备上显示滑块 */
        @media screen and (max-width: 768px), screen and (orientation: portrait) {
            .font-slider-container {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="player-container" id="player-container">
        <audio id="audio-player"></audio>
        <div id="lyrics-container"></div>
    </div>
    <div class="font-slider-container">
        <input type="range" min="0.5" max="1.5" value="1" step="0.05" id="fontSlider">
    </div>

    <script>
        const AMLL_SETTINGS_STORAGE_KEY = 'amll_background_settings';
        const fontLoadPromises = new Map();
        const fontClassCache = new Map();
        let fontTipTimer = null;

        function showFontTip(message) {
            if (!message) return;
            let el = document.getElementById('font-load-tip');
            if (!el) {
                el = document.createElement('div');
                el.id = 'font-load-tip';
                document.body.appendChild(el);
            }
            el.textContent = message;
            el.style.opacity = '1';
            if (fontTipTimer) clearTimeout(fontTipTimer);
            fontTipTimer = setTimeout(() => {
                el.style.opacity = '0';
            }, 4000);
        }

        async function loadFontFromGoogle(fontName) {
            const encodedName = encodeURIComponent(fontName).replace(/%20/g, '+');
            const cssUrl = `https://fonts.googleapis.com/css2?family=${encodedName}:wght@400;500;600;700&display=swap`;
            const res = await fetch(cssUrl, { mode: 'cors' });
            if (!res.ok) {
                throw new Error(`Google Fonts responded ${res.status}`);
            }
            const cssText = await res.text();
            if (!cssText || !cssText.includes('@font-face')) {
                throw new Error('Google Fonts returned empty CSS');
            }
            const styleEl = document.createElement('style');
            styleEl.textContent = cssText;
            document.head.appendChild(styleEl);
        }

        async function loadFontFromCdnFonts(fontName) {
            const encodedName = encodeURIComponent(fontName);
            const cssUrl = `https://fonts.cdnfonts.com/css/${encodedName}`;
            const res = await fetch(cssUrl, { mode: 'cors' });
            if (!res.ok) {
                throw new Error(`cdnfonts responded ${res.status}`);
            }
            const cssText = await res.text();
            if (!cssText || !cssText.includes('@font-face')) {
                throw new Error('cdnfonts returned empty CSS');
            }
            const styleEl = document.createElement('style');
            styleEl.textContent = cssText;
            document.head.appendChild(styleEl);
        }

        async function tryLocalFont(fontName, aliases) {
            const encodedName = encodeURIComponent(fontName);
            const candidates = [
                `/songs/${encodedName}.woff2`,
                `/songs/${encodedName}.ttf`,
                `/songs/${encodedName}.otf`,
                `/fonts/${encodedName}.woff2`,
                `/fonts/${encodedName}.ttf`,
                `/fonts/${encodedName}.otf`
            ];
            for (const url of candidates) {
                try {
                    const res = await fetch(url, { method: 'GET', cache: 'force-cache' });
                    if (!res.ok) continue;
                    const styleEl = document.createElement('style');
                    const localParts = (aliases || [fontName]).map(a => `local('${a}')`).join(', ');
                    styleEl.textContent = `
@font-face {
    font-family: '${fontName}';
    src: ${localParts ? localParts + ',' : ''} url('${url}');
    font-display: swap;
}`;
                    document.head.appendChild(styleEl);
                    return url;
                } catch (err) {
                    console.warn('Local font fetch failed', fontName, url, err);
                }
            }
            return '';
        }

        function isFontAvailable(fontName) {
            if (!fontName || !document.fonts || !document.fonts.check) return false;
            try {
                return document.fonts.check(`1em "${fontName}"`);
            } catch (err) {
                return false;
            }
        }

        function measureFontDifference(fontName) {
            const name = (fontName || '').trim();
            if (!name) return false;
            const tester = document.createElement('span');
            tester.textContent = 'ABCDEFGHIJKLMnopqrstuvwxyz 1234567890 汉字かなカナ';
            tester.style.position = 'absolute';
            tester.style.visibility = 'hidden';
            tester.style.fontSize = '32px';
            tester.style.left = '-9999px';
            tester.style.fontFamily = 'serif';
            document.body.appendChild(tester);
            const serifWidth = tester.getBoundingClientRect().width;
            tester.style.fontFamily = `"${name}", serif`;
            const customWidth = tester.getBoundingClientRect().width;
            document.body.removeChild(tester);
            return Math.abs(customWidth - serifWidth) > 0.5;
        }

        function buildFontAliases(fontName) {
            const raw = (fontName || '').trim();
            if (!raw) return [];
            const aliases = new Set();
            aliases.add(raw);
            aliases.add(raw.replace(/[-_]+/g, ' '));
            aliases.add(raw.replace(/[-_]+/g, ''));
            const dashSplit = raw.split(/[-_ ]+/);
            if (dashSplit.length > 1) {
                aliases.add(dashSplit[0]);
            }
            return Array.from(aliases).filter(Boolean);
        }

        function parseFontStack(fontValue) {
            if (!fontValue) return [];
            return fontValue.split(',')
                .map((name) => (name || '').trim())
                .filter(Boolean);
        }

        const SCRIPT_CHECKERS = {
            ja: /[\u3040-\u30ff\u31f0-\u31ff\u4e00-\u9fff]/,
            en: /[A-Za-z]/
        };

        function detectScript(text) {
            if (!text) return '';
            if (SCRIPT_CHECKERS.ja.test(text)) return 'ja';
            if (SCRIPT_CHECKERS.en.test(text)) return 'en';
            return '';
        }

        function selectFontForText(text, fontMap, defaultFont, fallbackStack) {
            const script = detectScript(text);
            const hasMap = fontMap && script && Object.prototype.hasOwnProperty.call(fontMap, script);
            if (hasMap) {
                const mapped = fontMap[script];
                if (mapped) return mapped; // 显式指定
                return ''; // 显式空：使用系统默认
            }
            if (defaultFont && (!script || script === 'en')) return defaultFont;
            return '';
        }

        function buildFontValue(primary, fallbackList, bodyFont, allowFallback = true) {
            const esc = (v) => v.replace(/'/g, "\\'");
            const ordered = [];
            if (primary) ordered.push(`'${esc(primary)}'`);
            if (allowFallback && primary) {
                (fallbackList || []).forEach((f) => {
                    if (f && f !== primary) {
                        ordered.push(`'${esc(f)}'`);
                    }
                });
            }
            if (bodyFont) {
                ordered.push(bodyFont);
            }
            return ordered.join(', ');
        }

        function fontClassName(fontName) {
            return `custom-font-${fontName.replace(/[^a-zA-Z0-9_-]/g, '-') || 'unknown'}`;
        }

        function ensureFontClass(fontName, fontFamilyValue) {
            const name = (fontName || '').trim();
            if (!name || !fontFamilyValue) return '';
            if (fontClassCache.has(name)) return fontClassCache.get(name);
            const cls = fontClassName(name);
            const styleEl = document.createElement('style');
            styleEl.textContent = `
.${cls} {
    font-family: ${fontFamilyValue} !important;
}`;
            document.head.appendChild(styleEl);
            fontClassCache.set(name, cls);
            return cls;
        }

        function ensureFontLoaded(fontName) {
            const name = (fontName || '').trim();
            if (!name) return Promise.resolve();
            if (fontLoadPromises.has(name)) {
                return fontLoadPromises.get(name);
            }
            showFontTip(`尝试加载字体 ${name} ...`);
            const loader = (async () => {
                try {
                    let loaded = false;
                    let localUrl = '';
                    const fontStack = parseFontStack(name);
                    for (const fontCandidate of fontStack.length ? fontStack : [name]) {
                        const candidateAliases = buildFontAliases(fontCandidate);
                        const url = await tryLocalFont(fontCandidate, candidateAliases);
                        localUrl = localUrl || url;
                        if (url && document.fonts && document.fonts.load) {
                            try {
                                await document.fonts.load(`1em "${fontCandidate}"`);
                            } catch (err) {
                                console.warn('fonts.load failed', fontCandidate, err);
                            }
                        }
                    }
                    if (localUrl && isFontAvailable(name)) {
                        loaded = true;
                        showFontTip(`字体 ${name} 已加载（本地文件 ${localUrl}）`);
                    }
                    try {
                        await loadFontFromGoogle(name);
                        loaded = true;
                    } catch (err1) {
                        console.warn('Google Fonts load failed', name, err1);
                    }
                    if (!loaded) {
                        try {
                            await loadFontFromCdnFonts(name);
                            loaded = true;
                        } catch (err2) {
                            console.warn('cdnfonts load failed', name, err2);
                        }
                    }

                    // 触发一次测量，确保浏览器开始请求字体文件
                    if (document.fonts && document.fonts.load) {
                        try {
                            await document.fonts.load(`1em "${name}"`);
                        } catch (err) {
                            console.warn('fonts.load failed', name, err);
                        }
                    }

                    const finalAvailable = isFontAvailable(name);
                    const visuallyDifferent = finalAvailable && measureFontDifference(name);
                    if (finalAvailable && visuallyDifferent) {
                        const source = localUrl ? `本地文件 ${localUrl}` : (loaded ? '远程字体' : '系统/本地字体');
                        showFontTip(`字体 ${name} 已可用（${source}）`);
                    } else if (finalAvailable) {
                        showFontTip(`字体 ${name} 已检测到，但显示效果与系统字体无差异，可能未实际生效`);
                    } else {
                        showFontTip(`字体 ${name} 加载失败或未找到，请确认文件存在 /songs 或 /fonts 目录`);
                    }
                } catch (err) {
                    console.warn('Font load failed', name, err);
                    showFontTip(`字体 ${name} 加载失败，请确认已安装或手动引入`);
                }
            })();
            fontLoadPromises.set(name, loader);
            return loader;
        }

        function guardAmllSettingsStorage() {
            try {
                const storage = window.localStorage;
                if (!storage) {
                    return () => { };
                }

                const originalObject = {
                    getItem: storage.getItem,
                    setItem: storage.setItem,
                    removeItem: storage.removeItem,
                    clear: storage.clear
                };

                let mirror = originalObject.getItem
                    ? originalObject.getItem.call(storage, AMLL_SETTINGS_STORAGE_KEY)
                    : null;

                const normalizeKey = (key) => (typeof key === 'string' ? key : String(key));

                const guardedGet = function (key) {
                    if (normalizeKey(key) === AMLL_SETTINGS_STORAGE_KEY) {
                        return mirror;
                    }
                    return originalObject.getItem
                        ? originalObject.getItem.call(this, key)
                        : null;
                };

                const guardedSet = function (key, value) {
                    if (normalizeKey(key) === AMLL_SETTINGS_STORAGE_KEY) {
                        mirror = String(value);
                        return undefined;
                    }
                    return originalObject.setItem
                        ? originalObject.setItem.call(this, key, value)
                        : undefined;
                };

                const guardedRemove = function (key) {
                    if (normalizeKey(key) === AMLL_SETTINGS_STORAGE_KEY) {
                        mirror = null;
                        return undefined;
                    }
                    return originalObject.removeItem
                        ? originalObject.removeItem.call(this, key)
                        : undefined;
                };

                const guardedClear = function () {
                    if (originalObject.clear) {
                        originalObject.clear.call(this);
                    }
                    if (mirror !== null && mirror !== undefined && originalObject.setItem) {
                        try {
                            originalObject.setItem.call(this, AMLL_SETTINGS_STORAGE_KEY, mirror);
                        } catch (error) {
                            console.warn('[AMLL] 恢复 AMLL 缓存失败', error);
                        }
                    }
                };

                storage.getItem = guardedGet;
                storage.setItem = guardedSet;
                storage.removeItem = guardedRemove;
                storage.clear = guardedClear;

                return () => {
                    storage.getItem = originalObject.getItem;
                    storage.setItem = originalObject.setItem;
                    storage.removeItem = originalObject.removeItem;
                    storage.clear = originalObject.clear;
                };
            } catch (error) {
                console.warn('[AMLL] 设置缓存保护失败', error);
                return () => { };
            }
        }

        if (!window.__AMLL_DEFAULT_ALBUM__) {
            window.__AMLL_DEFAULT_ALBUM__ = "{{ url_for('static', filename='icons/icon-512x512.png') }}";
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const restoreAmllStorage = guardAmllSettingsStorage();
            window.addEventListener('beforeunload', () => {
                try {
                    restoreAmllStorage();
                } catch (error) {
                    console.warn('[AMLL] 恢复 Storage 失败', error);
                }
            }, { once: true });

            const audioPlayer = document.getElementById('audio-player');
            const lyricsContainer = document.getElementById('lyrics-container');
            const playerContainer = document.getElementById('player-container');
            const fontSlider = document.getElementById('fontSlider');
            let lyricsData = [];
            let forceCenterAlign = false; // 新增
            let translationData = [];
            let backgroundCleanup = null;
            let backgroundVideo = null;
            const VIDEO_SYNC_DRIFT = 0.25;

            const AMLL_MODULE_URL = "{{ url_for('static', filename='assets/amll-player.js') }}";
            const amllStubState = { patched: false, restore: null, host: null, skeleton: null };
            const amllBackgroundState = { promise: null, host: null, element: null };
            const urlParams = new URLSearchParams(window.location.search);
            const queryBackground = urlParams.get('background') || null;
            const queryCover = urlParams.get('cover') || null;
            const AMLL_SKELETON_IDS = new Set([
                'player',
                'lyricsPanel',
                'albumSidePanel',
                'songTitle',
                'songArtist',
                'albumInfo',
                'albumCoverContainer',
                'albumCoverLarge',
                'progressBar',
                'progressFill',
                'waveformCanvas'
            ]);

            function clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            const LYRIC_SCALE_MIN = 0.35;
            const LYRIC_SCALE_MAX = 1.6;
            const AUTO_SCALE_SAFETY_RATIO = 0.97;
            const AUTO_SCALE_SAFETY_PADDING = 48;
            const AUTO_SCALE_EPS = 0.01;
            const LYRIC_SCALE_EASING = 'cubic-bezier(0.32, 0.78, 0.12, 1)';
            const LYRIC_SCALE_DURATION_MS = 360;
            let userLyricScale = parseFloat(fontSlider?.value || '1') || 1;
            let appliedLyricScale = userLyricScale;
            let autoScaleRaf = null;
            let suppressAnimations = false;
            let autoScaleLocked = false;
            let lyricScaleResyncTimer = null;

            function createAmllStubElement(id) {
                if (!id) {
                    return document.createElement('div');
                }
                const normalizedId = id.toLowerCase();
                if (normalizedId === 'waveformcanvas') {
                    const canvas = document.createElement('canvas');
                    canvas.width = 0;
                    canvas.height = 0;
                    return canvas;
                }
                return document.createElement('div');
            }

            function selectById(root, id) {
                if (!root) return null;
                if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
                    return root.querySelector(`#${CSS.escape(id)}`);
                }
                return root.querySelector(`[id="${id.replace(/"/g, '\\"')}"]`);
            }

            function ensureAmllSkeleton(stubMap, host) {
                if (amllStubState.skeleton && amllStubState.skeleton.isConnected) {
                    return;
                }
                const skeleton = document.createElement('div');
                skeleton.setAttribute('data-amll-skeleton', '1');
                skeleton.style.display = 'none';
                skeleton.innerHTML = `
                    <div id="player" data-amll-stub="1">
                        <div id="albumSidePanel" data-amll-stub="1">
                            <div class="song-info-container" data-amll-stub="1">
                                <div id="albumCoverContainer" data-amll-stub="1">
                                    <img id="albumCoverLarge" data-amll-stub="1" alt="" />
                                </div>
                                <div id="albumInfo" data-amll-stub="1">
                                    <div id="songTitle" data-amll-stub="1"></div>
                                    <div id="songArtist" data-amll-stub="1"></div>
                                </div>
                            </div>
                        </div>
                        <div id="lyricsPanel" data-amll-stub="1"></div>
                    </div>
                    <div id="progressBar" data-amll-stub="1">
                        <canvas id="waveformCanvas" data-amll-stub="1"></canvas>
                        <div id="progressFill" data-amll-stub="1"></div>
                    </div>
                `;
                host.appendChild(skeleton);
                amllStubState.skeleton = skeleton;
                AMLL_SKELETON_IDS.forEach((elementId) => {
                    const el = selectById(skeleton, elementId);
                    if (el) {
                        if (elementId === 'waveformCanvas' && el instanceof HTMLCanvasElement) {
                            el.width = 0;
                            el.height = 0;
                        }
                        stubMap.set(elementId, el);
                    }
                });
            }

            function ensureAmllStubs() {
                if (amllStubState.patched) {
                    return;
                }
                const host = document.createElement('div');
                host.id = 'amll-stub-host';
                host.style.display = 'none';
                document.documentElement.appendChild(host);

                const stubMap = new Map();
                const originalGetElementById = document.getElementById.bind(document);

                document.getElementById = function (id) {
                    const existing = originalGetElementById(id);
                    if (existing) return existing;
                    if (AMLL_SKELETON_IDS.has(id)) {
                        ensureAmllSkeleton(stubMap, host);
                    }
                    if (stubMap.has(id)) return stubMap.get(id);
                    if (amllStubState.skeleton) {
                        const skeletonMatch = selectById(amllStubState.skeleton, id);
                        if (skeletonMatch) {
                            stubMap.set(id, skeletonMatch);
                            return skeletonMatch;
                        }
                    }
                    const stub = createAmllStubElement(id);
                    stub.id = id;
                    stub.setAttribute('data-amll-stub', '1');
                    host.appendChild(stub);
                    stubMap.set(id, stub);
                    return stub;
                };

                amllStubState.patched = true;
                amllStubState.host = host;
                amllStubState.restore = () => {
                    document.getElementById = originalGetElementById;
                };
            }

            function ensureMediaCapabilitiesCompat() {
                const mediaCapabilities = navigator.mediaCapabilities;
                if (!mediaCapabilities) {
                    return;
                }
                const originalEncodingInfo = mediaCapabilities.encodingInfo;
                if (typeof originalEncodingInfo !== 'function' || originalEncodingInfo.__amllPatched) {
                    return;
                }
                const wrapped = async (...args) => {
                    try {
                        return await originalEncodingInfo.apply(mediaCapabilities, args);
                    } catch (error) {
                        const message = String(error || '');
                        const isEnumError = error instanceof TypeError && message.includes('encodingInfo');
                        if (!isEnumError) {
                            console.warn('[AMLL] MediaCapabilities encodingInfo fallback applied', error);
                        }
                        return { supported: false, smooth: false, powerEfficient: false };
                    }
                };
                Object.defineProperty(wrapped, '__amllPatched', {
                    value: true,
                    writable: false
                });
                try {
                    Object.defineProperty(mediaCapabilities, 'encodingInfo', {
                        configurable: true,
                        enumerable: true,
                        value: wrapped
                    });
                } catch (error) {
                    try {
                        mediaCapabilities.encodingInfo = wrapped;
                    } catch (assignError) {
                        console.warn('[AMLL] Unable to patch MediaCapabilities.encodingInfo', assignError);
                    }
                }
            }

            function waitFor(predicate, timeout = 8000, interval = 50) {
                return new Promise((resolve, reject) => {
                    const start = Date.now();
                    const step = () => {
                        let value = null;
                        try {
                            value = predicate();
                        } catch (error) {
                            // 忽略 predicate 内部异常
                        }
                        if (value) {
                            resolve(value);
                            return;
                        }
                        if (Date.now() - start >= timeout) {
                            reject(new Error('waitFor timeout'));
                            return;
                        }
                        setTimeout(step, interval);
                    };
                    step();
                });
            }

            function removeExistingBackground() {
                if (backgroundCleanup) {
                    try {
                        backgroundCleanup();
                    } catch (e) { /* 忽略清理异常 */ }
                    backgroundCleanup = null;
                }
                clearBackgroundVideo();
                document.querySelectorAll('.background-container').forEach((el) => el.remove());
            }

            function clearBackgroundVideo() {
                if (!backgroundVideo) {
                    return;
                }
                try {
                    backgroundVideo.pause();
                } catch (e) { /* 忽略暂停异常 */ }
                backgroundVideo = null;
            }

            function setBackgroundVideo(video) {
                backgroundVideo = video;
                if (!backgroundVideo) {
                    return;
                }
                backgroundVideo.muted = true;
                backgroundVideo.playsInline = true;
                backgroundVideo.loop = true;
                syncBackgroundVideo(true);
                if (audioPlayer.paused) {
                    backgroundVideo.pause();
                } else {
                    backgroundVideo.play().catch(() => {});
                }
            }

            function syncBackgroundVideo(force = false) {
                if (!backgroundVideo) {
                    return;
                }
                const audioTime = Number.isFinite(audioPlayer.currentTime) ? audioPlayer.currentTime : 0;
                const duration = Number.isFinite(backgroundVideo.duration) ? backgroundVideo.duration : 0;
                if (duration > 0) {
                    let target = audioTime;
                    if (target > duration) {
                        target = target % duration;
                    }
                    const delta = Math.abs(backgroundVideo.currentTime - target);
                    if (force || delta > VIDEO_SYNC_DRIFT) {
                        try {
                            backgroundVideo.currentTime = target;
                        } catch (e) { /* 忽略同步异常 */ }
                    }
                }
                if (!audioPlayer.paused && backgroundVideo.paused) {
                    backgroundVideo.play().catch(() => {});
                } else if (audioPlayer.paused && !backgroundVideo.paused) {
                    backgroundVideo.pause();
                }
            }

            function resolveMediaUrl(rawPath) {
                if (!rawPath || typeof rawPath !== 'string') {
                    return null;
                }
                const trimmed = rawPath.trim();
                if (!trimmed) {
                    return null;
                }
                const normalized = trimmed.replace(/^\.\//, '');
                if (/^https?:\/\//i.test(normalized) || normalized.startsWith('data:') || normalized.startsWith('blob:')) {
                    return normalized;
                }
                return normalized.startsWith('/') ? normalized : '/' + normalized;
            }

            async function prepareAmllBackground() {
                if (amllBackgroundState.promise) {
                    return amllBackgroundState.promise;
                }

                amllBackgroundState.promise = (async () => {
                    try {
                        ensureMediaCapabilitiesCompat();
                        ensureAmllStubs();
                        if (!window.globalBackground) {
                            await import(AMLL_MODULE_URL);
                        }
                        const background = await waitFor(() => window.globalBackground, 10000);
                        if (!background) {
                            return null;
                        }

                        if (amllStubState.restore) {
                            try {
                                amllStubState.restore();
                            } catch (error) {
                                console.warn('[AMLL] 恢复 getElementById 失败', error);
                            }
                            amllStubState.restore = null;
                        }

                        amllBackgroundState.host = amllStubState.host;
                        const element = background.getElement();
                        element.setAttribute('data-amll-background-element', '1');
                        element.style.position = 'absolute';
                        element.style.top = '0';
                        element.style.left = '0';
                        element.style.width = '100%';
                        element.style.height = '100%';
                        element.style.pointerEvents = 'none';
                        element.style.opacity = '1';
                        amllBackgroundState.element = element;

                        const audio = window.player?.getAudio?.();
                        if (audio) {
                            try {
                                audio.pause();
                            } catch (error) { /* 忽略 */ }
                            audio.remove?.();
                        }

                        return background;
                    } catch (error) {
                        console.error('[AMLL] 加载 AMLL 背景失败', error);
                        if (amllStubState.restore) {
                            try {
                                amllStubState.restore();
                            } catch (restoreError) {
                                console.warn('[AMLL] 回退 getElementById 时出错', restoreError);
                            }
                            amllStubState.restore = null;
                        }
                        return null;
                    }
                })();

                return amllBackgroundState.promise;
            }

            async function initAmllBackgroundFromAlbum(coverPath) {
                const url = resolveMediaUrl(coverPath);
                if (!url) {
                    return false;
                }

                const background = await prepareAmllBackground();
                if (!background || !amllBackgroundState.element) {
                    return false;
                }

                removeExistingBackground();

                const container = document.createElement('div');
                container.className = 'background-container';
                container.appendChild(amllBackgroundState.element);
                document.body.appendChild(container);

                backgroundCleanup = () => {
                    try {
                        background.pause();
                    } catch (error) { /* 忽略 */ }
                    if (amllBackgroundState.element.parentElement) {
                        amllBackgroundState.element.parentElement.removeChild(amllBackgroundState.element);
                    }
                    if (amllBackgroundState.host) {
                        amllBackgroundState.host.appendChild(amllBackgroundState.element);
                    }
                    container.remove();
                };

                try {
                    await background.setAlbum(url);
                    background.setStaticMode(false);
                    background.setFlowSpeed(4);
                    const dpr = window.devicePixelRatio || 1;
                    background.setRenderScale(dpr);
                    background.resume();
                    return true;
                } catch (error) {
                    console.warn('[AMLL] AMLL 背景初始化失败，将回退其他方案', error);
                    if (backgroundCleanup) {
                        backgroundCleanup();
                        backgroundCleanup = null;
                    }
                    return false;
                }
            }

            async function loadBackground(backgroundPath) {
                const url = resolveMediaUrl(backgroundPath);
                if (!url) {
                    return false;
                }

                removeExistingBackground();

                return new Promise((resolve) => {
                    const container = document.createElement('div');
                    container.className = 'background-container';
                    document.body.appendChild(container);

                    const handleFailure = () => {
                        container.remove();
                        backgroundCleanup = null;
                        resolve(false);
                    };

                    const extension = (url.split('.').pop() || '').toLowerCase();
                    const isVideo = ['mp4', 'webm', 'ogg', 'm4v', 'mov'].includes(extension);

                    if (isVideo) {
                        const video = document.createElement('video');
                        video.src = url;
                        video.muted = true;
                        video.loop = true;
                        video.autoplay = true;
                        video.playsInline = true;
                        video.addEventListener('loadedmetadata', () => {
                            setBackgroundVideo(video);
                        }, { once: true });
                        video.addEventListener('loadeddata', () => {
                            backgroundCleanup = () => {
                                clearBackgroundVideo();
                                video.pause();
                                video.removeAttribute('src');
                                video.load();
                                container.remove();
                            };
                            resolve(true);
                            video.play().catch(() => {});
                        }, { once: true });
                        video.addEventListener('error', handleFailure, { once: true });
                        container.appendChild(video);
                    } else {
                        clearBackgroundVideo();
                        const img = document.createElement('img');
                        img.src = url;
                        img.addEventListener('load', () => {
                            backgroundCleanup = () => {
                                container.remove();
                            };
                            resolve(true);
                        }, { once: true });
                        img.addEventListener('error', handleFailure, { once: true });
                        container.appendChild(img);
                    }
                });
            }

            // 动画时长控制（前端硬编码，同时由后端解析保持一致）
            const enterDuration = 600;           // 歌词行进入动画时长（毫秒）
            const moveDuration = 600;            // 歌词行移动动画时长（毫秒）
            const exitDuration = 600;            // 歌词行退出动画时长（毫秒）
            const placeholderDuration = 50;      // 占位符（消失行）延时
            const lineDisplayOffset = 0.5;       // 歌词行提前显示时间（秒）
            const useComputedDisappear = false;  // 是否使用后端计算的消失时机
            const SYLLABLE_FADE_RATIO = 0.3;     // 逐字渐变的淡入范围比例
            const SYLLABLE_FLOAT_ASCEND_EASING = 'cubic-bezier(0.55, 0.05, 0.85, 0.25)'; // 逐音节上浮阶段使用缓慢起步后逐渐加速的曲线
            const SYLLABLE_FLOAT_SETTLE_EASING = 'cubic-bezier(0.0, 0.6, 0.2, 1.0)';     // 逐音节悬停阶段使用深度缓出的曲线
            const SYLLABLE_FLOAT_SETTLE_TAIL_MS = 100000000000; // 逐音节悬停阶段至少保留的时长（毫秒），制造“无限趋近”感
            const SYLLABLE_FLOAT_MAX_SPEED = 0.01314520; // 像素/毫秒，逐音节上浮速度上限，可按需求调整

            async function syncAnimationConfig() {
                try {
                    await fetch('/player/animation-config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            enterDuration,
                            moveDuration,
                            exitDuration,
                            placeholderDuration,
                            lineDisplayOffset,
                            useComputedDisappear
                        })
                    });
                } catch (error) {
                    console.warn('上传动画配置失败，将使用后端的默认值', error);
                }
            }

            let displayedLines = new Map(); // 使用 Map 跟踪所有显示的行
            let placeholderLines = new Map(); // 跟踪正在消失的行的占位符
            const customEasing = 'cubic-bezier(.27,.14,0,.99)';
            let showAllLinesWhenPaused = false; // 是否暂停时展示所有歌词行
            let rafId = null; // requestAnimationFrame ID
            const moveTransitionCleanup = new WeakMap(); // 存储当前运行的位移动画信息

            function refreshDisplayedLineAnimations() {
                requestAnimationFrame(() => {
                    displayedLines.forEach((lineInfo, index) => {
                        const lineData = lyricsData[index];
                        if (lineInfo?.element && lineData) {
                            prepareSyllableAnimations(index, lineInfo.element, lineInfo, lineData);
                        }
                    });
                });
            }

            function requestLyricAnimationResync() {
                refreshDisplayedLineAnimations();
                if (lyricScaleResyncTimer) {
                    clearTimeout(lyricScaleResyncTimer);
                }
                lyricScaleResyncTimer = setTimeout(() => {
                    lyricScaleResyncTimer = null;
                    refreshDisplayedLineAnimations();
                }, LYRIC_SCALE_DURATION_MS + 80);
            }

            function withAnimationsSuppressed(fn) {
                suppressAnimations = true;
                try {
                    fn();
                } finally {
                    suppressAnimations = false;
                }
            }

            function setLyricScale(scale) {
                const upperBound = Math.min(userLyricScale, LYRIC_SCALE_MAX);
                const clamped = clamp(scale, LYRIC_SCALE_MIN, upperBound);
                appliedLyricScale = clamped;
                if (playerContainer) {
                    playerContainer.style.setProperty('--lyric-scale', clamped);
                    playerContainer.style.setProperty('--lyric-scale-easing', LYRIC_SCALE_EASING);
                    playerContainer.style.setProperty('--lyric-scale-duration', `${LYRIC_SCALE_DURATION_MS}ms`);
                }
                requestLyricAnimationResync();
            }

            const lineMetricCache = { metrics: null };

            function measureLineMetrics() {
                const cache = lineMetricCache.metrics;
                if (cache) return cache;

                const host = document.createElement('div');
                host.style.position = 'absolute';
                host.style.left = '-9999px';
                host.style.top = '0';
                host.style.width = '1000px';
                host.style.pointerEvents = 'none';
                host.style.visibility = 'hidden';
                host.style.setProperty('--lyric-scale', '1');
                document.body.appendChild(host);

                const buildLine = (isSmall, withTranslation) => {
                    const line = document.createElement('div');
                    line.className = 'lyric-line center-aligned';
                    if (isSmall) line.classList.add('small-font');
                    const word = document.createElement('span');
                    word.className = 'word-wrapper';
                    const syllable = document.createElement('span');
                    syllable.className = 'syllable';
                    syllable.textContent = 'Sample words here';
                    word.appendChild(syllable);
                    line.appendChild(word);
                    if (withTranslation) {
                        const trans = document.createElement('div');
                        trans.className = 'translation-line center-aligned';
                        trans.style.fontSize = isSmall ? '0.8em' : '0.5em';
                        trans.style.color = '#ffffff';
                        trans.style.fontWeight = 'normal';
                        trans.style.lineHeight = '1.2';
                        trans.style.marginTop = '0.1em';
                        trans.style.width = '100%';
                        trans.style.paddingBottom = '0.2em';
                        trans.textContent = 'translation';
                        line.appendChild(trans);
                    }
                    return line;
                };

                const lines = [
                    { key: 'normal', el: buildLine(false, false) },
                    { key: 'small', el: buildLine(true, false) },
                    { key: 'normalTrans', el: buildLine(false, true) },
                    { key: 'smallTrans', el: buildLine(true, true) }
                ];

                lines.forEach(({ el }) => host.appendChild(el));

                const metrics = {};
                lines.forEach(({ key, el }) => {
                    metrics[key] = el.offsetHeight || el.getBoundingClientRect().height || 0;
                });

                host.remove();
                lineMetricCache.metrics = metrics;
                return metrics;
            }

            function computeAutoScaleTarget() {
                if (autoScaleLocked) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }
                const viewportHeight = window.innerHeight
                    || document.documentElement.clientHeight
                    || (playerContainer ? playerContainer.clientHeight : 0)
                    || 0;
                if (!viewportHeight) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }
                const availableHeight = Math.max(0, viewportHeight - AUTO_SCALE_SAFETY_PADDING);
                if (availableHeight === 0) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }

                const metrics = measureLineMetrics();
                const lines = Array.from(lyricsContainer?.querySelectorAll('.lyric-line') || []);
                if (lines.length === 0) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }

                let normal = 0;
                let small = 0;
                let normalTrans = 0;
                let smallTrans = 0;
                lines.forEach((line) => {
                    const isSmall = line.classList.contains('small-font');
                    const hasTrans = !!line.querySelector('.translation-line');
                    if (isSmall) {
                        if (hasTrans) {
                            smallTrans += 1;
                        } else {
                            small += 1;
                        }
                    } else {
                        if (hasTrans) {
                            normalTrans += 1;
                        } else {
                            normal += 1;
                        }
                    }
                });

                const baseSum =
                    normal * (metrics.normal || 0) +
                    small * (metrics.small || 0) +
                    normalTrans * (metrics.normalTrans || 0) +
                    smallTrans * (metrics.smallTrans || 0);

                if (baseSum <= 0) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }

                const baselineTotal = baseSum * userLyricScale;
                const ratio = availableHeight / baselineTotal;
                const adjustedRatio = ratio * AUTO_SCALE_SAFETY_RATIO;
                const upperBound = Math.min(userLyricScale, LYRIC_SCALE_MAX);
                const target = clamp(
                    userLyricScale * adjustedRatio,
                    LYRIC_SCALE_MIN,
                    upperBound
                );
                if (Math.abs(target - appliedLyricScale) < AUTO_SCALE_EPS) {
                    return appliedLyricScale;
                }
                return target;
            }

            function scheduleAutoScale() {
                if (autoScaleLocked) return;
                if (autoScaleRaf) return;
                autoScaleRaf = requestAnimationFrame(() => {
                    autoScaleRaf = null;
                    const targetScale = computeAutoScaleTarget();
                    if (Math.abs(targetScale - appliedLyricScale) > AUTO_SCALE_EPS) {
                        setLyricScale(targetScale);
                    }
                });
            }
            setLyricScale(userLyricScale);

            function clearMoveTransition(element) {
                if (!element) {
                    return { residualX: 0, residualY: 0, progress: 0 };
                }
                const record = moveTransitionCleanup.get(element);
                if (!record) {
                    return { residualX: 0, residualY: 0, progress: 0 };
                }

                moveTransitionCleanup.delete(element);

                let progress = 0;
                let residualX = 0;
                let residualY = 0;

                const { animation, fromX = 0, fromY = 0 } = record;
                if (animation && animation.effect && typeof animation.effect.getComputedTiming === 'function') {
                    try {
                        const timing = animation.effect.getComputedTiming();
                        if (timing && typeof timing.progress === 'number') {
                            progress = Math.max(0, Math.min(1, timing.progress));
                        }
                    } catch (e) { /* 忽略 */ }
                }

                const remaining = 1 - progress;
                residualX = fromX * remaining;
                residualY = fromY * remaining;

                try {
                    animation.cancel();
                } catch (e) { /* 忽略 */ }

                element.style.transform = '';
                element.style.willChange = '';

                return { residualX, residualY, progress };
            }

            function runFlipTransition(element, deltaX, deltaY) {
                if (suppressAnimations) return;
                if (!element) return;
                const { residualX, residualY, progress } = clearMoveTransition(element);

                const adjustedDeltaX = deltaX + residualX;
                const adjustedDeltaY = deltaY + residualY;

                if (Math.abs(adjustedDeltaX) <= 0.5 && Math.abs(adjustedDeltaY) <= 0.5) return;

                // 若上一段动画未完成，则缩短时长并使用线性缓动以平滑衔接
                const durationFactor = progress > 0 ? Math.max(0.35, 1 - progress * 0.6) : 1;
                const animationDuration = Math.max(180, moveDuration * durationFactor);
                const easing = progress > 0.2 ? 'linear' : customEasing;

                element.style.willChange = 'transform';
                const animation = element.animate(
                    [
                        { transform: `translate(${adjustedDeltaX}px, ${adjustedDeltaY}px)` },
                        { transform: 'translate(0, 0)' }
                    ],
                    {
                        duration: animationDuration,
                        easing,
                        fill: 'forwards',
                        composite: 'add'
                    }
                );

                const record = {
                    animation,
                    fromX: adjustedDeltaX,
                    fromY: adjustedDeltaY
                };

                const finalize = () => {
                    if (moveTransitionCleanup.get(element) !== record) return;
                    moveTransitionCleanup.delete(element);
                    element.style.transform = '';
                    element.style.willChange = '';
                };

                animation.addEventListener('finish', finalize, { once: true });
                animation.addEventListener('cancel', finalize, { once: true });


                moveTransitionCleanup.set(element, record);
            }

            const SUPPORT_MASK_IMAGE =
                (typeof CSS !== 'undefined' && CSS.supports && CSS.supports('mask-image', 'none'))
                || (typeof CSS !== 'undefined' && CSS.supports && CSS.supports('-webkit-mask-image', 'none'));
            const ANIMATION_FRAME_QUANTITY = 32;
            const EMP_EASING_MID = 0.5;

            function bezierEasing(mX1, mY1, mX2, mY2) {
                if (mX1 === mY1 && mX2 === mY2) {
                    return (x) => x;
                }
                const NEWTON_ITERATIONS = 4;
                const NEWTON_MIN_SLOPE = 0.001;
                const SUBDIVISION_PRECISION = 0.0000001;
                const SUBDIVISION_MAX_ITERATIONS = 10;
                const kSplineTableSize = 11;
                const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
                const sampleValues = new Float32Array(kSplineTableSize);

                const A = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;
                const B = (a1, a2) => 3.0 * a2 - 6.0 * a1;
                const C = (a1) => 3.0 * a1;
                const calcBezier = (t, a1, a2) => ((A(a1, a2) * t + B(a1, a2)) * t + C(a1)) * t;
                const getSlope = (t, a1, a2) => 3.0 * A(a1, a2) * t * t + 2.0 * B(a1, a2) * t + C(a1);

                for (let i = 0; i < kSplineTableSize; ++i) {
                    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                }

                const binarySubdivide = (x, a, b) => {
                    let currentX, currentT, i = 0;
                    do {
                        currentT = a + (b - a) / 2.0;
                        currentX = calcBezier(currentT, mX1, mX2) - x;
                        if (currentX > 0.0) {
                            b = currentT;
                        } else {
                            a = currentT;
                        }
                    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
                    return currentT;
                };

                const newtonRaphsonIterate = (x, guessT) => {
                    for (let i = 0; i < NEWTON_ITERATIONS; ++i) {
                        const currentSlope = getSlope(guessT, mX1, mX2);
                        if (currentSlope === 0.0) return guessT;
                        const currentX = calcBezier(guessT, mX1, mX2) - x;
                        guessT -= currentX / currentSlope;
                    }
                    return guessT;
                };

                const getTForX = (x) => {
                    let intervalStart = 0.0;
                    let currentSample = 1;
                    const lastSample = kSplineTableSize - 1;

                    for (; currentSample !== lastSample && sampleValues[currentSample] <= x; ++currentSample) {
                        intervalStart += kSampleStepSize;
                    }
                    --currentSample;
                    const dist = (x - sampleValues[currentSample]) /
                        (sampleValues[currentSample + 1] - sampleValues[currentSample]);
                    const guessT = intervalStart + dist * kSampleStepSize;
                    const initialSlope = getSlope(guessT, mX1, mX2);
                    if (initialSlope >= NEWTON_MIN_SLOPE) {
                        return newtonRaphsonIterate(x, guessT);
                    }
                    if (initialSlope === 0.0) {
                        return guessT;
                    }
                    return binarySubdivide(x, intervalStart, intervalStart + kSampleStepSize);
                };

                return (x) => {
                    if (x === 0 || x === 1) return x;
                    return calcBezier(getTForX(x), mY1, mY2);
                };
            }

            const bezIn = bezierEasing(0.2, 0.4, 0.58, 1.0);
            const bezOut = bezierEasing(0.3, 0.0, 0.58, 1.0);
            const norNum = (min, max) => (x) => Math.min(1, Math.max(0, (x - min) / (max - min)));
            const beginNum = norNum(0, EMP_EASING_MID);
            const endNum = norNum(EMP_EASING_MID, 1);
            const makeEmpEasing = (mid) => {
                return (x) => (x < mid ? bezIn(beginNum(x)) : 1 - bezOut(endNum(x)));
            };

            function createMatrix4() {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            }

            function scaleMatrix4(m, scale = 1) {
                return [
                    m[0] * scale, m[1] * scale, m[2] * scale, m[3],
                    m[4] * scale, m[5] * scale, m[6] * scale, m[7],
                    m[8] * scale, m[9] * scale, m[10] * scale, m[11],
                    m[12], m[13], m[14], m[15]
                ];
            }

            function matrix4ToCSS(m, fractionDigits = 4) {
                const format = (n) => n.toFixed(fractionDigits);
                return `matrix3d(${m.map(format).join(", ")})`;
            }

            function isCJK(text) {
                return /^[\p{Unified_Ideograph}\u0800-\u9FFC]+$/u.test(text || '');
            }

            function shouldEmphasize(word) {
                if (!word || !word.word) return false;
                const duration = word.endTime - word.startTime;
                if (isCJK(word.word)) return duration >= 1000;
                const trimmed = word.word.trim();
                return duration >= 1000 && trimmed.length <= 7 && trimmed.length > 1;
            }

            function chunkAndSplitLyricWords(words) {
                const resplitedWords = [];
                for (const w of words) {
                    const realLength = (w.word || '').replace(/\s/g, '').length || 1;
                    const splited = (w.word || '').split(' ').filter((v) => v.trim().length > 0);
                    if (splited.length > 1) {
                        if (w.word.startsWith(' ')) {
                            resplitedWords.push({
                                word: ' ',
                                romanWord: '',
                                startTime: 0,
                                endTime: 0,
                                obscene: false,
                                fontFamily: w.fontFamily,
                                fontClass: w.fontClass
                            });
                        }
                        let charPos = 0;
                        for (const s of splited) {
                            resplitedWords.push({
                                word: s,
                                romanWord: '',
                                obscene: w.obscene,
                                startTime: w.startTime + (charPos / realLength) * (w.endTime - w.startTime),
                                endTime: w.startTime + ((charPos + s.length) / realLength) * (w.endTime - w.startTime),
                                fontFamily: w.fontFamily,
                                fontClass: w.fontClass
                            });
                            resplitedWords.push({
                                word: ' ',
                                romanWord: '',
                                startTime: 0,
                                endTime: 0,
                                obscene: false,
                                fontFamily: w.fontFamily,
                                fontClass: w.fontClass
                            });
                            charPos += s.length;
                        }
                        if (!w.word.endsWith(' ')) {
                            resplitedWords.pop();
                        }
                    } else {
                        resplitedWords.push({ ...w });
                    }
                }

                let wordChunk = [];
                let wChunk = [];
                const result = [];

                const CJKEXP = /^[\p{Unified_Ideograph}\u0800-\u9FFC]+$/u;

                for (const w of resplitedWords) {
                    const word = w.word;
                    wordChunk.push(word);
                    wChunk.push(w);
                    if (word.length > 0 && word.trim().length === 0) {
                        wordChunk.pop();
                        wChunk.pop();
                        if (wChunk.length === 1) {
                            result.push(wChunk[0]);
                        } else if (wChunk.length > 1) {
                            result.push(wChunk);
                        }
                        result.push(w);
                        wordChunk = [];
                        wChunk = [];
                    } else if (!/^\s*[^\s]*\s*$/.test(wordChunk.join('')) || CJKEXP.test(word)) {
                        wordChunk.pop();
                        wChunk.pop();
                        if (wChunk.length === 1) {
                            result.push(wChunk[0]);
                        } else if (wChunk.length > 1) {
                            result.push(wChunk);
                        }
                        wordChunk = [word];
                        wChunk = [w];
                    }
                }

                if (wChunk.length === 1) {
                    result.push(wChunk[0]);
                } else if (wChunk.length > 1) {
                    result.push(wChunk);
                }

                return result;
            }

            function generateFadeGradient(width, padding = 0, bright = 'rgba(0,0,0,var(--rcolor))', dark = 'rgba(0,0,0,var(--color))') {
                const totalAspect = 2 + width + padding;
                const widthInTotal = width / totalAspect;
                const leftPos = (1 - widthInTotal) / 2;
                return [
                    `linear-gradient(to right,${bright} ${leftPos * 100}%,${dark} ${(leftPos + widthInTotal) * 100}%)`,
                    totalAspect
                ];
            }

            const NORMAL_FLOAT_UP_EM = 0.1;
            const EMPHASIZE_FLOAT_UP_EM = 0.05;

            function initFloatAnimation(word, wordEl, lineStartMs, isBg, upEm) {
                const delay = word.startTime - lineStartMs;
                const duration = Math.max(1000, word.endTime - word.startTime);
                let up = Number.isFinite(upEm) ? upEm : NORMAL_FLOAT_UP_EM;
                if (isBg) {
                    up *= 2;
                }
                const a = wordEl.animate([
                    { transform: 'translateY(0px)' },
                    { transform: `translateY(${-up}em)` }
                ], {
                    duration: Number.isFinite(duration) ? duration : 0,
                    delay: Number.isFinite(delay) ? delay : 0,
                    id: 'float-word',
                    composite: 'add',
                    fill: 'both',
                    easing: 'ease-out'
                });
                a.pause();
                return a;
            }

            function initEmphasizeAnimation(word, characterElements, duration, delay, isBg, lineWords) {
                const de = Math.max(0, delay);
                let du = Math.max(1000, duration);
                let amount = du / 2000;
                amount = amount > 1 ? Math.sqrt(amount) : amount ** 3;
                let blur = du / 3000;
                blur = blur > 1 ? Math.sqrt(blur) : blur ** 3;
                amount *= 0.6;
                blur *= 0.5;
                if (lineWords && lineWords.length > 0 && word.word.includes(lineWords[lineWords.length - 1].word)) {
                    amount *= 1.6;
                    blur *= 1.5;
                    du *= 1.2;
                }
                amount = Math.min(1.2, amount);
                blur = Math.min(0.8, blur);

                const animateDu = Number.isFinite(du) ? du : 0;
                const empEasing = makeEmpEasing(EMP_EASING_MID);

                return characterElements.flatMap((el, i, arr) => {
                    const wordDe = de + (du / 2.5 / arr.length) * i;
                    const frames = new Array(ANIMATION_FRAME_QUANTITY).fill(0).map((_, j) => {
                        const x = (j + 1) / ANIMATION_FRAME_QUANTITY;
                        const transX = empEasing(x);
                        const glowLevel = empEasing(x) * blur;
                        const mat = scaleMatrix4(createMatrix4(), 1 + transX * 0.1 * amount);
                        const offsetX = -transX * 0.03 * amount * (arr.length / 2 - i);
                        const offsetY = -transX * 0.025 * amount;
                        return {
                            offset: x,
                            transform: `${matrix4ToCSS(mat, 4)} translate(${offsetX}em, ${offsetY}em)`,
                            textShadow: `0 0 ${Math.min(0.3, blur * 0.3)}em rgba(255, 255, 255, ${glowLevel})`
                        };
                    });

                    const glow = el.animate(frames, {
                        duration: animateDu,
                        delay: Number.isFinite(wordDe) ? wordDe : 0,
                        id: `emphasize-word-${el.innerText}-${i}`,
                        iterations: 1,
                        composite: 'replace',
                        fill: 'both'
                    });
                    glow.onfinish = () => {
                        glow.pause();
                    };
                    glow.pause();

                    const floatFrames = new Array(ANIMATION_FRAME_QUANTITY).fill(0).map((_, j) => {
                        const x = (j + 1) / ANIMATION_FRAME_QUANTITY;
                        let y = Math.sin(x * Math.PI);
                        if (isBg) {
                            y *= 2;
                        }
                        return {
                            offset: x,
                            transform: `translateY(${-y * EMPHASIZE_FLOAT_UP_EM}em)`
                        };
                    });
                    const float = el.animate(floatFrames, {
                        duration: animateDu * 1.4,
                        delay: Number.isFinite(wordDe) ? wordDe - 400 : 0,
                        id: 'emphasize-word-float',
                        iterations: 1,
                        composite: 'add',
                        fill: 'both'
                    });
                    float.onfinish = () => {
                        float.pause();
                    };
                    float.pause();

                    return [glow, float];
                });
            }

            function buildAmllWords(line, mainEl, fontMeta) {
                const syllables = Array.isArray(line.syllables) ? line.syllables : [];
                if (syllables.length === 0) {
                    return { realWords: [], lineStartMs: 0, lineEndMs: 0 };
                }
                const lineStartMs = Math.round(parseFloat(syllables[0].startTime) * 1000);
                const lastSyllable = syllables[syllables.length - 1];
                const lineEndMs = Math.round((parseFloat(lastSyllable.startTime) + parseFloat(lastSyllable.duration)) * 1000);
                const isBgLine = Boolean(line.isBackground || line.isBG || line.is_background || line.isbg);

                const words = syllables.map((syllable) => {
                    const startMs = Math.round(parseFloat(syllable.startTime) * 1000);
                    const durationMs = Math.round(parseFloat(syllable.duration) * 1000);
                    const endMs = startMs + durationMs;
                    const fontFamily = syllable.fontFamily || '';
                    const fontClass = fontFamily ? ensureFontClass(fontFamily, buildFontValue(fontFamily, fontMeta.aliases, fontMeta.bodyFont, true)) : '';
                    return {
                        word: syllable.text || '',
                        romanWord: '',
                        startTime: startMs,
                        endTime: endMs,
                        obscene: false,
                        fontFamily,
                        fontClass
                    };
                });

                const chunked = chunkAndSplitLyricWords(words);
                mainEl.innerHTML = '';
                const realWords = [];

                const applyWordFont = (el, word) => {
                    if (!word) return;
                    if (word.fontFamily) {
                        el.style.fontFamily = buildFontValue(word.fontFamily, fontMeta.aliases, fontMeta.bodyFont, true);
                    }
                    if (word.fontClass) {
                        el.classList.add(word.fontClass);
                    }
                };

                const buildChunkGroup = (chunk) => {
                    const merged = chunk.reduce((a, b) => {
                        a.endTime = Math.max(a.endTime, b.endTime);
                        a.startTime = Math.min(a.startTime, b.startTime);
                        a.word += b.word;
                        return a;
                    }, {
                        word: '',
                        romanWord: '',
                        startTime: Number.POSITIVE_INFINITY,
                        endTime: Number.NEGATIVE_INFINITY,
                        obscene: false
                    });

                    const emp = chunk.map((word) => shouldEmphasize(word)).reduce((a, b) => a || b, shouldEmphasize(merged));
                    const wrapperWordEl = document.createElement('span');
                    wrapperWordEl.classList.add('amll-emphasize-wrapper');

                    const characterElements = [];
                    chunk.forEach((word) => {
                        const mainWordEl = document.createElement('span');
                        if (emp) {
                            mainWordEl.classList.add('amll-emphasize');
                            const charEls = [];
                            for (const char of (word.word || '').trim()) {
                                const charEl = document.createElement('span');
                                charEl.innerText = char;
                                charEls.push(charEl);
                                characterElements.push(charEl);
                                mainWordEl.appendChild(charEl);
                            }
                            applyWordFont(mainWordEl, word);
                            realWords.push({
                                ...word,
                                mainElement: mainWordEl,
                                subElements: charEls,
                                elementAnimations: [initFloatAnimation(word, mainWordEl, lineStartMs, isBgLine, NORMAL_FLOAT_UP_EM)],
                                maskAnimations: [],
                                width: 0,
                                height: 0,
                                padding: 0,
                                shouldEmphasize: emp
                            });
                        } else {
                            mainWordEl.innerText = word.word || '';
                            applyWordFont(mainWordEl, word);
                            realWords.push({
                                ...word,
                                mainElement: mainWordEl,
                                subElements: [],
                                elementAnimations: [initFloatAnimation(word, mainWordEl, lineStartMs, isBgLine, NORMAL_FLOAT_UP_EM)],
                                maskAnimations: [],
                                width: 0,
                                height: 0,
                                padding: 0,
                                shouldEmphasize: emp
                            });
                        }
                        wrapperWordEl.appendChild(mainWordEl);
                    });

                    if (emp && realWords.length > 0) {
                        realWords[realWords.length - 1].elementAnimations.push(
                            ...initEmphasizeAnimation(merged, characterElements, merged.endTime - merged.startTime, merged.startTime - lineStartMs, isBgLine, words)
                        );
                    }

                    if (merged.word.trimStart() !== merged.word) {
                        mainEl.appendChild(document.createTextNode(' '));
                    }
                    mainEl.appendChild(wrapperWordEl);
                    if (merged.word.trimEnd() !== merged.word && shouldEmphasize(merged)) {
                        mainEl.appendChild(document.createTextNode(' '));
                    }
                };

                const buildSingleWord = (chunk) => {
                    const emp = shouldEmphasize(chunk);
                    const mainWordEl = document.createElement('span');
                    const realWord = {
                        ...chunk,
                        mainElement: mainWordEl,
                        subElements: [],
                        elementAnimations: [initFloatAnimation(chunk, mainWordEl, lineStartMs, isBgLine, NORMAL_FLOAT_UP_EM)],
                        maskAnimations: [],
                        width: 0,
                        height: 0,
                        padding: 0,
                        shouldEmphasize: emp
                    };

                    if (emp) {
                        mainWordEl.classList.add('amll-emphasize');
                        const charEls = [];
                        for (const char of (chunk.word || '').trim()) {
                            const charEl = document.createElement('span');
                            charEl.innerText = char;
                            charEls.push(charEl);
                            mainWordEl.appendChild(charEl);
                        }
                        realWord.subElements = charEls;
                        const duration = Math.abs(realWord.endTime - realWord.startTime);
                        realWord.elementAnimations.push(
                            ...initEmphasizeAnimation(chunk, charEls, duration, realWord.startTime - lineStartMs, isBgLine, words)
                        );
                    } else {
                        mainWordEl.innerText = (chunk.word || '').trim();
                    }

                    applyWordFont(mainWordEl, chunk);

                    if (chunk.word.trimStart() !== chunk.word) {
                        mainEl.appendChild(document.createTextNode(' '));
                    }
                    mainEl.appendChild(mainWordEl);
                    if (chunk.word.trimEnd() !== chunk.word) {
                        mainEl.appendChild(document.createTextNode(' '));
                    }
                    realWords.push(realWord);
                };

                chunked.forEach((chunk) => {
                    if (Array.isArray(chunk)) {
                        if (chunk.length === 0) return;
                        buildChunkGroup(chunk);
                    } else if (chunk.word.trim().length === 0) {
                        mainEl.appendChild(document.createTextNode(' '));
                    } else {
                        buildSingleWord(chunk);
                    }
                });

                return { realWords, lineStartMs, lineEndMs };
            }

            function updateWordMetrics(realWords) {
                realWords.forEach((word) => {
                    const el = word.mainElement;
                    if (el) {
                        word.padding = Number.parseFloat(getComputedStyle(el).paddingLeft) || 0;
                        word.width = el.clientWidth - word.padding * 2;
                        word.height = el.clientHeight - word.padding * 2;
                    } else {
                        word.width = 0;
                        word.height = 0;
                        word.padding = 0;
                    }
                });
            }

            function generateCalcBasedMaskImage(realWords, lineStartMs) {
                realWords.forEach((word) => {
                    const wordEl = word.mainElement;
                    if (!wordEl) return;
                    const fadeWidth = word.height * (SYLLABLE_FADE_RATIO || 0.3);
                    const [maskImage, totalAspect] = generateFadeGradient(fadeWidth / Math.max(1, word.width));
                    const totalAspectStr = `${totalAspect * 100}% 100%`;
                    wordEl.style.maskImage = maskImage;
                    wordEl.style.maskRepeat = 'no-repeat';
                    wordEl.style.maskOrigin = 'left';
                    wordEl.style.maskSize = totalAspectStr;
                    wordEl.style.webkitMaskImage = maskImage;
                    wordEl.style.webkitMaskRepeat = 'no-repeat';
                    wordEl.style.webkitMaskOrigin = 'left';
                    wordEl.style.webkitMaskSize = totalAspectStr;
                    const w = word.width + fadeWidth;
                    const maskPos = `clamp(${-w}px,calc(${-w}px + (var(--amll-player-time) - ${word.startTime - lineStartMs})*${w / Math.max(1, Math.abs(word.endTime - word.startTime))}px),0px) 0px`;
                    wordEl.style.maskPosition = maskPos;
                    wordEl.style.webkitMaskPosition = maskPos;
                });
            }

            function generateWebAnimationBasedMaskImage(realWords, lineStartMs, lineEndMs) {
                const totalFadeDuration = Math.max(
                    realWords.reduce((pv, w) => Math.max(w.endTime, pv), 0),
                    lineEndMs
                ) - lineStartMs;

                realWords.forEach((word, i) => {
                    const wordEl = word.mainElement;
                    if (!wordEl) return;
                    const fadeWidth = word.height * (SYLLABLE_FADE_RATIO || 0.3);
                    const [maskImage, totalAspect] = generateFadeGradient(
                        fadeWidth / Math.max(1, word.width + word.padding * 2)
                    );
                    const totalAspectStr = `${totalAspect * 100}% 100%`;
                    wordEl.style.maskImage = maskImage;
                    wordEl.style.maskRepeat = 'no-repeat';
                    wordEl.style.maskOrigin = 'left';
                    wordEl.style.maskSize = totalAspectStr;
                    wordEl.style.webkitMaskImage = maskImage;
                    wordEl.style.webkitMaskRepeat = 'no-repeat';
                    wordEl.style.webkitMaskOrigin = 'left';
                    wordEl.style.webkitMaskSize = totalAspectStr;

                    const widthBeforeSelf =
                        realWords.slice(0, i).reduce((a, b) => a + b.width, 0) +
                        (realWords[0] ? fadeWidth : 0);
                    const minOffset = -(word.width + word.padding * 2 + fadeWidth);
                    const clampOffset = (x) => Math.max(minOffset, Math.min(0, x));
                    let curPos = -widthBeforeSelf - word.width - word.padding - fadeWidth;
                    let timeOffset = 0;
                    const frames = [];
                    let lastPos = curPos;
                    let lastTime = 0;

                    const pushFrame = () => {
                        const moveOffset = curPos - lastPos;
                        const time = Math.max(0, Math.min(1, timeOffset));
                        const duration = time - lastTime;
                        const d = Math.abs(duration / (moveOffset || 1));
                        if (curPos > minOffset && lastPos < minOffset) {
                            const staticTime = Math.abs(lastPos - minOffset) * d;
                            const value = `${clampOffset(lastPos)}px 0`;
                            frames.push({ offset: lastTime + staticTime, maskPosition: value, webkitMaskPosition: value });
                        }
                        if (curPos > 0 && lastPos < 0) {
                            const staticTime = Math.abs(lastPos) * d;
                            const value = `${clampOffset(curPos)}px 0`;
                            frames.push({ offset: lastTime + staticTime, maskPosition: value, webkitMaskPosition: value });
                        }
                        const value = `${clampOffset(curPos)}px 0`;
                        frames.push({ offset: time, maskPosition: value, webkitMaskPosition: value });
                        lastPos = curPos;
                        lastTime = time;
                    };

                    pushFrame();
                    let lastTimeStamp = 0;
                    realWords.forEach((otherWord, j) => {
                        const curTimeStamp = otherWord.startTime - lineStartMs;
                        const staticDuration = curTimeStamp - lastTimeStamp;
                        timeOffset += staticDuration / Math.max(1, totalFadeDuration);
                        if (staticDuration > 0) pushFrame();
                        lastTimeStamp = curTimeStamp;

                        const fadeDuration = otherWord.endTime - otherWord.startTime;
                        timeOffset += fadeDuration / Math.max(1, totalFadeDuration);
                        curPos += otherWord.width;
                        if (j === 0) {
                            curPos += fadeWidth * 1.5;
                        }
                        if (j === realWords.length - 1) {
                            curPos += fadeWidth * 0.5;
                        }
                        if (fadeDuration > 0) pushFrame();
                        lastTimeStamp += fadeDuration;
                    });

                    word.maskAnimations.forEach((a) => a.cancel());
                    try {
                        const ani = wordEl.animate(frames, {
                            duration: totalFadeDuration || 1,
                            id: `fade-word-${word.word}-${i}`,
                            fill: 'both'
                        });
                        ani.pause();
                        word.maskAnimations = [ani];
                    } catch (err) {
                        console.warn('mask animation failed', frames, totalFadeDuration, err);
                    }
                });

                return totalFadeDuration;
            }

                        function cancelLineAnimations(lineInfo, { commit } = {}) {
                            if (!lineInfo || !lineInfo.animations) return;
                            lineInfo.animations.forEach(animation => {
                                try {
                                    if (commit && typeof animation.commitStyles === 'function') {
                                        animation.commitStyles();
                                    }
                                } catch (e) { /* 忽略 */ }
                                try {
                                    animation.cancel();
                                } catch (e) { /* 忽略 */ }
                            });
                            lineInfo.animations = [];
                        }

                        function syncLineAnimations(lineInfo) {
                            if (!lineInfo || !lineInfo.animations || lineInfo.animations.length === 0) return;
                            const currentMs = Number.isFinite(audioPlayer.currentTime) ? audioPlayer.currentTime * 1000 : 0;
                            const lineStart = lineInfo.lineStartMs ?? 0;
                            const duration = Math.max(1, lineInfo.lineDuration ?? 0);
                            const localTime = currentMs - lineStart;
                            const clampedTime = Math.max(0, Math.min(duration, localTime));
                            if (!SUPPORT_MASK_IMAGE && lineInfo.element) {
                                lineInfo.element.style.setProperty('--amll-player-time', `${clampedTime}`);
                            }
                            lineInfo.animations.forEach(animation => {
                                try {
                                    const mapper = animation && animation.__mapTime;
                                    const mappedTime = typeof mapper === 'function' ? mapper(clampedTime) : clampedTime;
                                    animation.currentTime = mappedTime;
                                } catch (e) { /* 忽略 */ }
                            });
                        }

            function prepareSyllableAnimations(lineIndex, lineEl, lineInfo, lineData) {
                if (!lineInfo || !lineEl) return;
                const amllData = lineEl.__amllData;
                if (!amllData || !Array.isArray(amllData.realWords) || amllData.realWords.length === 0) {
                    return;
                }

                cancelLineAnimations(lineInfo);
                updateWordMetrics(amllData.realWords);

                let totalFadeDuration = Math.max(1, amllData.lineEndMs - amllData.lineStartMs);
                if (SUPPORT_MASK_IMAGE) {
                    totalFadeDuration = generateWebAnimationBasedMaskImage(
                        amllData.realWords,
                        amllData.lineStartMs,
                        amllData.lineEndMs
                    );
                } else {
                    generateCalcBasedMaskImage(amllData.realWords, amllData.lineStartMs);
                }

                const animations = [];
                let maxAnimationEnd = 0;
                amllData.realWords.forEach((word) => {
                    (word.elementAnimations || []).forEach((ani) => {
                        animations.push(ani);
                        const timing = ani.effect && typeof ani.effect.getTiming === 'function' ? ani.effect.getTiming() : null;
                        if (timing && typeof timing.duration === 'number') {
                            const delay = Number.isFinite(timing.delay) ? timing.delay : 0;
                            const end = Math.max(0, delay) + Math.max(0, timing.duration);
                            maxAnimationEnd = Math.max(maxAnimationEnd, end);
                        }
                    });
                    (word.maskAnimations || []).forEach((ani) => {
                        animations.push(ani);
                        const timing = ani.effect && typeof ani.effect.getTiming === 'function' ? ani.effect.getTiming() : null;
                        if (timing && typeof timing.duration === 'number') {
                            const delay = Number.isFinite(timing.delay) ? timing.delay : 0;
                            const end = Math.max(0, delay) + Math.max(0, timing.duration);
                            maxAnimationEnd = Math.max(maxAnimationEnd, end);
                        }
                    });
                });

                lineInfo.lineStartMs = amllData.lineStartMs;
                lineInfo.originalLineDuration = Math.max(1, amllData.lineEndMs - amllData.lineStartMs);
                lineInfo.lineDuration = Math.max(totalFadeDuration, maxAnimationEnd, lineInfo.originalLineDuration);
                lineInfo.animations = animations;

                syncLineAnimations(lineInfo);
            }

            // 卡拉OK进度更新函数 - 只更新当前活跃行
            function updateKaraokeProgress() {
                displayedLines.forEach((lineInfo) => {
                    syncLineAnimations(lineInfo);
                });
            }

            // requestAnimationFrame 循环
            function rafLoop() {
                updateKaraokeProgress();
                rafId = requestAnimationFrame(rafLoop);
            }

            // 解析 LRC 翻译，返回 [{timeMs, content}]
            function parseLrcTranslation(content) {
                const lines = content.split('\n');
                const result = [];
                const lrcTimeRe = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
                for (const line of lines) {
                    const match = lrcTimeRe.exec(line);
                    if (match) {
                        const min = parseInt(match[1], 10);
                        const sec = parseInt(match[2], 10);
                        let ms = match[3].length === 2 ? parseInt(match[3], 10) * 10 : parseInt(match[3], 10);
                        const timeMs = min * 60 * 1000 + sec * 1000 + ms;
                        const contentText = line.replace(lrcTimeRe, '').trim();
                        if (contentText) {
                            result.push({ timeMs, content: contentText });
                        }
                    }
                }
                return result;
            }

            // 将持续时间超过 1s 的英文词拆分为逐字符的子音节，按等份时间平分
        function splitLongWordSyllables(lines, minDurationSec = 1, predicate = () => true) {
            if (!Array.isArray(lines)) return [];

            return lines.map((line) => {
                if (!predicate(line)) return line;
                if (!line || !Array.isArray(line.syllables)) {
                    return line;
                }

                    const newSyllables = [];
                    line.syllables.forEach((syllable) => {
                        if (!syllable) return;
                        const rawText = syllable.text || '';
                        const text = rawText.trim();
                        const duration = Number.parseFloat(syllable.duration);
                        const start = Number.parseFloat(syllable.startTime);
                        const looksLikeWord = /^[A-Za-z][A-Za-z,'-]*[A-Za-z]?[.,!?]?$/.test(text) && !text.includes(' ');

                        if (
                            Number.isFinite(duration) &&
                            Number.isFinite(start) &&
                            duration > minDurationSec &&
                            text.length > 1 &&
                            looksLikeWord
                        ) {
                            const chars = Array.from(rawText);
                            const partDuration = duration / chars.length;
                            chars.forEach((char, idx) => {
                                const splitStart = start + partDuration * idx;
                                newSyllables.push({
                                    ...syllable,
                                    text: char,
                                    startTime: splitStart,
                                    duration: partDuration
                                });
                            });
                        } else {
                            newSyllables.push(syllable);
                        }
                    });

                    return { ...line, syllables: newSyllables };
            });
        }

        function splitMultiWordSyllables(lines, minDurationSec = 1, predicate = () => true) {
            if (!Array.isArray(lines)) return [];

            return lines.map((line) => {
                if (!predicate(line)) return line;
                if (!line || !Array.isArray(line.syllables) || line.syllables.length !== 1) {
                    return line;
                }
                const syllable = line.syllables[0];
                if (!syllable) return line;
                const rawText = syllable.text || '';
                if (!/\s/.test(rawText)) return line;

                const duration = Number.parseFloat(syllable.duration);
                const start = Number.parseFloat(syllable.startTime);
                if (!Number.isFinite(duration) || !Number.isFinite(start) || duration <= minDurationSec) {
                    return line;
                }

                const tokens = rawText.match(/\S+\s*/g);
                if (!tokens || tokens.length <= 1) return line;

                const weights = tokens.map((token) => {
                    const weight = token.replace(/\s+/g, '').length;
                    return weight > 0 ? weight : 1;
                });
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                if (totalWeight <= 0) return line;

                let cursor = start;
                const newSyllables = tokens.map((token, idx) => {
                    const partDuration = duration * (weights[idx] / totalWeight);
                    const next = {
                        ...syllable,
                        text: token,
                        startTime: cursor,
                        duration: partDuration
                    };
                    cursor += partDuration;
                    return next;
                });

                const last = newSyllables[newSyllables.length - 1];
                const end = start + duration;
                last.duration = Math.max(0, end - Number.parseFloat(last.startTime));

                return { ...line, syllables: newSyllables, line: tokens.join('') };
            });
        }

        function isLineUsingSpecialFont(line) {
            if (!line) return false;
            const hasLineFont = Boolean(line.style && line.style.fontFamily);
            const hasSyllableFont =
                Array.isArray(line.syllables) && line.syllables.some((sy) => sy && sy.fontFamily);
            return hasLineFont || hasSyllableFont;
        }

        function mergeSpecialFontWords(lines) {
            if (!Array.isArray(lines)) return [];
            const isSeparator = (text = '') => {
                if (!text) return true;
                if (/\s/.test(text)) return true;
                return /^[.,;!?:，。？！、：；]+$/.test(text);
            };
            const isLatinWord = (text = '') => /[A-Za-z]/.test(text);

            return lines.map((line) => {
                if (!line || !line.style || !line.style.fontFamily || !Array.isArray(line.syllables)) {
                    return line;
                }
                const merged = [];
                let current = null;

                const pushCurrent = () => {
                    if (current) {
                        current.duration = Math.max(0, current.endTime - current.startTime);
                        delete current.endTime;
                        merged.push(current);
                        current = null;
                    }
                };

                line.syllables.forEach((sy) => {
                    if (!sy) return;
                    const text = sy.text || '';
                    const start = parseFloat(sy.startTime) || 0;
                    const dur = parseFloat(sy.duration) || 0;
                    const end = start + dur;
                    const fontFamily = sy.fontFamily;

                    if (isSeparator(text) || !isLatinWord(text)) {
                        pushCurrent();
                        merged.push({
                            text,
                            startTime: start,
                            duration: dur,
                            fontFamily
                        });
                        return;
                    }

                    if (!current || current.fontFamily !== fontFamily) {
                        current = {
                            text,
                            startTime: start,
                            endTime: end,
                            fontFamily
                        };
                    } else {
                        current.text += text;
                        current.endTime = end;
                    }
                });

                pushCurrent();

                return {
                    ...line,
                    syllables: merged,
                    line: merged.map((s) => s.text || '').join('')
                };
            });
        }

            async function loadData() {
                try {
                    const songInfoRes = await fetch('/song-info');
                    const songInfo = await songInfoRes.json();
                    audioPlayer.src = songInfo.song;

                    if (!songInfo.meta || typeof songInfo.meta !== 'object') {
                        songInfo.meta = {};
                    }

                    if (queryBackground) {
                        songInfo.meta['Background-image'] = queryBackground;
                    }

                    if (queryCover && queryCover !== '!') {
                        songInfo.meta.albumImgSrc = queryCover;
                        songInfo.meta.cover = queryCover;
                        songInfo.meta.coverUrl = queryCover;
                        songInfo.cover = queryCover;
                        songInfo.coverUrl = queryCover;
                    }

                    removeExistingBackground();

                    // 检查并加载背景图片/视频
                    let backgroundApplied = false;
                    if (songInfo.meta && songInfo.meta["Background-image"]) {
                        backgroundApplied = await loadBackground(songInfo.meta["Background-image"]);
                    }

                    if (!backgroundApplied) {
                        const coverCandidates = [
                            queryCover,
                            songInfo.meta?.albumImgSrc,
                            songInfo.meta?.cover,
                            songInfo.meta?.coverUrl,
                            songInfo.cover,
                            songInfo.coverUrl
                        ];
                        const coverSource = coverCandidates.find((candidate) => candidate && candidate !== '!');
                        if (coverSource) {
                            backgroundApplied = await initAmllBackgroundFromAlbum(coverSource);
                        }
                    }
                    
                    // 进入页面自动播放
                    setTimeout(() => {
                        audioPlayer.play().catch(() => {});
                    }, 0);

                    const lyricsRes = await fetch('/lyrics');
                    const lyricsJson = await lyricsRes.json();
                    lyricsData = lyricsJson.lyrics || [];
                    // 长词拆分仅应用于非自定义字体行或音节，避免特殊字体被拆成单字符
                    lyricsData = splitLongWordSyllables(
                        lyricsData,
                        1,
                        (line) => !isLineUsingSpecialFont(line)
                    );
                    lyricsData = splitMultiWordSyllables(lyricsData, 1);
                    // 对特殊字体行：按单词合并音节（空格/标点分词），避免跨词遮挡
                    lyricsData = mergeSpecialFontWords(lyricsData);

                    // 判断是否所有歌词行都不是 right（没有对唱标记）
                    forceCenterAlign = lyricsData.length > 0 && lyricsData.every(line => !line.style || line.style.align !== 'right');

                    // 优先使用后端返回的 translation 字段
                    translationData = Array.isArray(lyricsJson.translation) ? lyricsJson.translation.map(t => {
                        // 转换 time 为毫秒
                        const m = /^([0-9]{2}):([0-9]{2})\.([0-9]{2,3})$/.exec(t.time);
                        if (m) {
                            let ms = m[3].length === 2 ? parseInt(m[3], 10) * 10 : parseInt(m[3], 10);
                            t.timeMs = parseInt(m[1], 10) * 60 * 1000 + parseInt(m[2], 10) * 1000 + ms;
                        } else {
                            t.timeMs = 0;
                        }
                        return t;
                    }) : [];

                    // 如果没有 translation 字段，回退到原有 LRC 解析
                    if (translationData.length === 0 && songInfo.meta && songInfo.meta.lyrics) {
                        const parts = songInfo.meta.lyrics.split('::');
                        if (parts.length >= 3 && parts[2] && parts[2] !== '!') {
                            let transPath = parts[2];
                            if (transPath.startsWith('http://127.0.0.1:5000/songs/')) {
                                transPath = transPath.replace('http://127.0.0.1:5000/songs/', '');
                            }
                            if (transPath.endsWith('.lrc')) {
                                try {
                                    const resp = await fetch(transPath.startsWith('/') ? transPath : '/' + transPath);
                                    if (resp.ok) {
                                        const lrcText = await resp.text();
                                        translationData = parseLrcTranslation(lrcText);
                                    }
                                } catch (e) { /* 忽略 */ }
                            }
                        }
                    }

                    initLyrics();
                } catch (error) {
                    lyricsContainer.textContent = '无法加载歌词。';
                    console.error('Error loading data:', error);
                }
            }

            function groupSyllablesIntoWords(container, itemClass = 'syllable') {
                if (!container) return;

                const hasWrapper = Array.from(container.children).some(
                    (child) => child.classList && child.classList.contains('word-wrapper')
                );
                if (hasWrapper) return;

                const targetElements = Array.from(container.children).filter(
                    (child) => child.classList && child.classList.contains(itemClass)
                );
                if (targetElements.length === 0) return;

                const hasCJK = (text) => /[\u3040-\u30FF\u3100-\u312F\u31A0-\u31BF\u3130-\u318F\u3300-\u33FF\u3400-\u4DBF\u4E00-\u9FFF\uAC00-\uD7AF\u1100-\u11FF]/.test(text);
                const hasLatin = (text) => /[A-Za-z0-9]/.test(text);

                let currentWrapper = null;
                targetElements.forEach((element) => {
                    const text = element.textContent || '';
                    const trimmed = text.replace(/\s+/g, '');
                    const hasVisibleChar = trimmed.length > 0;
                    const endsWithSpace = /\s$/.test(text);
                    const isWhitespaceOnly = !hasVisibleChar;
                    const isLatinSegment = hasLatin(trimmed) && !hasCJK(trimmed);

                    if (isWhitespaceOnly) {
                        currentWrapper = null;
                        element.classList.add('word-space');
                        element.classList.remove('non-latin');
                        return;
                    }

                    element.classList.remove('word-space');

                    if (!isLatinSegment) {
                        currentWrapper = null;
                        element.classList.add('non-latin');
                        return;
                    }

                    element.classList.remove('non-latin');

                    if (!currentWrapper) {
                        currentWrapper = document.createElement('span');
                        currentWrapper.classList.add('word-wrapper');
                        container.insertBefore(currentWrapper, element);
                    }

                    currentWrapper.appendChild(element);

                    if (endsWithSpace) {
                        currentWrapper = null;
                    }
                });
            }
            
            function createLineElement(lineIndex) {
                const line = lyricsData[lineIndex];
                if (!line) return null;

                const lineStyle = line.style || {};
                const bodyFont = window.getComputedStyle(document.body).fontFamily;
                const syllableFonts = Array.isArray(line.syllables)
                    ? line.syllables
                        .map((s) => (s && s.fontFamily ? String(s.fontFamily) : ''))
                        .filter((name) => name && name.trim().length > 0)
                    : [];
                const uniqueFonts = Array.from(new Set(syllableFonts));
                const aliasList = uniqueFonts.flatMap((name) => buildFontAliases(name));
                const dedupAliases = Array.from(new Set(aliasList));
                uniqueFonts.forEach((f) => ensureFontLoaded(f));
                const hasAnySpecialFont = uniqueFonts.length > 0;
                const disableBlurLayer = hasAnySpecialFont;

                const lineEl = document.createElement('div');
                lineEl.classList.add('lyric-line');
                if (hasAnySpecialFont) {
                    lineEl.classList.add('allow-overflow');
                    lineEl.dataset.specialFont = '1';
                    lineEl.dataset.maxFloatMs = '1000';
                    lineEl.style.fontWeight = 'normal';
                }
                lineEl.dataset.lineIndex = lineIndex;
                
                // 应用从后端传来的样式
                if (forceCenterAlign) {
                    lineEl.classList.add('center-aligned');
                    if (lineStyle.fontSize === 'small') {
                        lineEl.classList.add('small-font');
                    }
                } else if (line.style) {
                    if (lineStyle.align === 'right') {
                        lineEl.classList.add('right-aligned');
                    } else if (lineStyle.align === 'center') {
                        lineEl.classList.add('center-aligned');
                    } else {
                        lineEl.classList.add('left-aligned');
                    }
                    if (lineStyle.fontSize === 'small') {
                        lineEl.classList.add('small-font');
                    }
                } else {
                    lineEl.classList.add('left-aligned');
                }
                
                if(line.syllables && line.syllables.length > 0) {
                    const firstSyllable = line.syllables[0];
                    const lastSyllable = line.syllables[line.syllables.length - 1];
                    lineEl.dataset.startTime = firstSyllable.startTime;
                    lineEl.dataset.endTime = parseFloat(lastSyllable.startTime) + parseFloat(lastSyllable.duration);
                }
                const isSmallFont = (lineStyle.fontSize === 'small');
                
                // 创建模糊层（在翻译渲染之前，以便计算正确的高度）
                let blurLayer = null;
                if (!disableBlurLayer) {
                    blurLayer = document.createElement('div');
                    blurLayer.className = 'blur-layer';
                    
                    // 复制上层歌词的样式
                    blurLayer.style.justifyContent = getComputedStyle(lineEl).justifyContent;
                    blurLayer.style.alignItems = getComputedStyle(lineEl).alignItems;
                    
                    // 为每个音节创建模糊文本
                    line.syllables.forEach((syllable) => {
                        const blurText = document.createElement('span');
                        blurText.className = 'blur-text';
                        blurText.textContent = syllable.text;
                        blurText.style.fontSize = getComputedStyle(lineEl).fontSize;
                        blurText.style.fontWeight = getComputedStyle(lineEl).fontWeight;
                        blurText.style.lineHeight = getComputedStyle(lineEl).lineHeight;
                        const hasPresetFont = Object.prototype.hasOwnProperty.call(syllable, 'fontFamily');
                        const presetFont = hasPresetFont ? (syllable.fontFamily || '') : '';
                        const chosenFont = hasPresetFont ? presetFont : '';
                        const allowFallback = Boolean(chosenFont);
                        const blurFontValue = buildFontValue(chosenFont, dedupAliases, bodyFont, allowFallback);
                        if (blurFontValue) {
                            blurText.style.fontFamily = blurFontValue;
                            const chosenClass = chosenFont ? ensureFontClass(chosenFont, blurFontValue) : '';
                            if (chosenClass) blurText.classList.add(chosenClass);
                        }
                        
                        // 复制间距
                        if (syllable.text && syllable.text.includes(' ')) {
                            blurText.style.marginRight = '0.28em';
                        }
                        
                        blurLayer.appendChild(blurText);
                    });
                    
                    lineEl.appendChild(blurLayer);
                }
                
                const mainLineEl = document.createElement('div');
                mainLineEl.className = 'amll-main-line';
                lineEl.appendChild(mainLineEl);
                const amllMeta = buildAmllWords(line, mainLineEl, { aliases: dedupAliases, bodyFont });
                lineEl.__amllData = amllMeta;

                groupSyllablesIntoWords(blurLayer, 'blur-text');

                // 翻译渲染：在歌词行下方插入翻译
                if (translationData.length > 0 && line.syllables && line.syllables.length > 0) {
                    // 取第一个音节的开始时间（秒->毫秒）
                    const startMs = Math.round(parseFloat(line.syllables[0].startTime) * 1000);
                    // 找到最接近的翻译（±200ms）
                    let minDelta = 201;
                    let bestTrans = null;
                    for (const t of translationData) {
                        const delta = Math.abs(t.timeMs - startMs);
                        if (delta < minDelta) {
                            minDelta = delta;
                            bestTrans = t;
                        }
                    }
                    if (bestTrans && minDelta <= 200) {
                        const transDiv = document.createElement('div');
                        transDiv.className = 'translation-line';
                        // 字体大小：正常歌词翻译为0.5em，背景人声的翻译为0.8em
                        transDiv.style.fontSize = isSmallFont ? '0.8em' : '0.5em';
                        transDiv.style.color = '#ffffff';
                        transDiv.style.fontWeight = 'normal';
                        transDiv.style.lineHeight = '1.2';
                        transDiv.style.marginTop = '0.1em';
                        transDiv.textContent = bestTrans.content;
                        // 强制换行并允许文本对齐
                        transDiv.style.width = '100%';
                        transDiv.style.paddingBottom = '0.2em'; // 给模糊层留下空间
                        // 翻译对齐方式与主歌词一致
                        if (lineEl.classList.contains('left-aligned')) transDiv.classList.add('left-aligned');
                        if (lineEl.classList.contains('center-aligned')) transDiv.classList.add('center-aligned');
                        if (lineEl.classList.contains('right-aligned')) transDiv.classList.add('right-aligned');
                        lineEl.appendChild(transDiv);
                        
                        // 如果有翻译，调整模糊层高度以避免重叠
                        setTimeout(() => {
                            const transHeight = transDiv.offsetHeight;
                            if (transHeight > 0 && blurLayer) {
                                blurLayer.style.height = `calc(100% - ${transHeight}px + var(--blur-safe-pad))`;
                            }
                        }, 0);
                    }
                }

                lineEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (lineEl.dataset.startTime) {
                        audioPlayer.currentTime = parseFloat(lineEl.dataset.startTime);
                        audioPlayer.play();
                    }
                });
                return lineEl;
            }

            function initLyrics() {
                lyricsContainer.innerHTML = '';
                displayedLines.clear();
                if (lyricsData.length === 0) {
                     lyricsContainer.textContent = '暂无歌词。';
                     return;
                }
            }

            function addLine(lineIndex) {
                if (displayedLines.has(lineIndex)) return;

                // 如果存在该行的占位符，立即移除，为新行让路
                if (placeholderLines.has(lineIndex)) {
                    const placeholderInfo = placeholderLines.get(lineIndex);
                    clearTimeout(placeholderInfo.removalTimer);
                    clearMoveTransition(placeholderInfo.element);
                    placeholderInfo.element.remove();
                    placeholderLines.delete(lineIndex);
                }

                const incomingLine = createLineElement(lineIndex);
                if (!incomingLine) return;

                // 并发锁：如果动画未完成，不允许重复添加
                if (incomingLine.animationLock) return;
                incomingLine.animationLock = true;

                // 找到下一个比当前 lineIndex 大的歌词行
                let inserted = false;
                const children = Array.from(lyricsContainer.children);
                for (let i = 0; i < children.length; i++) {
                    const childIndex = parseInt(children[i].dataset.lineIndex, 10);
                    if (childIndex > lineIndex) {
                        lyricsContainer.insertBefore(incomingLine, children[i]);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    lyricsContainer.appendChild(incomingLine);
                }

                const lineInfo = { element: incomingLine };
                displayedLines.set(lineIndex, lineInfo);

                if (!suppressAnimations) {
                    const animation = safeAnimate(incomingLine, [
                        { opacity: 0, filter: 'blur(5px)', '-webkit-filter': 'blur(5px)' },
                        { opacity: 1, filter: 'blur(0)', '-webkit-filter': 'blur(0)' }
                    ], {
                        duration: enterDuration,
                        easing: customEasing,
                        fill: 'forwards'
                    });
                    animation.onfinish = () => {
                        incomingLine.animationLock = false;
                    };
                } else {
                    incomingLine.style.opacity = '1';
                    incomingLine.style.filter = 'none';
                    incomingLine.style.webkitFilter = 'none';
                    incomingLine.animationLock = false;
                }

                const lineData = lyricsData[lineIndex];
                if (lineData) {
                    prepareSyllableAnimations(lineIndex, incomingLine, lineInfo, lineData);
                    requestAnimationFrame(() => {
                        if (displayedLines.has(lineIndex)) {
                            prepareSyllableAnimations(lineIndex, incomingLine, lineInfo, lineData);
                        }
                    });
                }
                scheduleAutoScale();
            }

            function removeLine(lineIndex) {
                const lineInfo = displayedLines.get(lineIndex);
                if (!lineInfo) return;

                const outgoingLine = lineInfo.element;

                cancelLineAnimations(lineInfo, { commit: true });

                if (suppressAnimations) {
                    if (outgoingLine && outgoingLine.parentElement) {
                        outgoingLine.remove();
                    }
                    displayedLines.delete(lineIndex);
                    return;
                }

                // 记录当前位置用于保持淡出起点
                const originalRect = outgoingLine.getBoundingClientRect();

                // 并发锁：动画未完成时禁止移除
                if (outgoingLine.animationLock) return;
                outgoingLine.animationLock = true;

                // 1. 创建并插入占位符
                const placeholderEl = document.createElement('div');
                placeholderEl.style.height = `${originalRect.height}px`; // 维持布局高度
                outgoingLine.before(placeholderEl); // 插入到原位置

                const scrollX = window.scrollX || window.pageXOffset || 0;
                const scrollY = window.scrollY || window.pageYOffset || 0;
                clearMoveTransition(outgoingLine);

                // 2. 克隆一个节点用于淡出动画，原节点立即移出布局
                const fadeLine = outgoingLine.cloneNode(true);
                fadeLine.classList.remove('active');
                fadeLine.style.position = 'absolute';
                fadeLine.style.left = `${originalRect.left + scrollX}px`;
                fadeLine.style.top = `${originalRect.top + scrollY}px`;
                fadeLine.style.width = `${originalRect.width}px`;
                fadeLine.style.margin = '0';
                fadeLine.style.pointerEvents = 'none';
                fadeLine.style.transform = '';
                fadeLine.style.willChange = '';
                const computedStyle = window.getComputedStyle(outgoingLine);
                const lyricScale = computedStyle.getPropertyValue('--lyric-scale');
                fadeLine.style.fontSize = computedStyle.fontSize;
                fadeLine.style.lineHeight = computedStyle.lineHeight;
                fadeLine.style.fontWeight = computedStyle.fontWeight;
                fadeLine.style.textAlign = computedStyle.textAlign;
                fadeLine.style.justifyContent = computedStyle.justifyContent;
                fadeLine.style.alignItems = computedStyle.alignItems;
                if (lyricScale) {
                    fadeLine.style.setProperty('--lyric-scale', lyricScale.trim());
                }
                document.body.appendChild(fadeLine);

                outgoingLine.remove();

                const animation = safeAnimate(fadeLine, [
                    { opacity: 1, filter: 'blur(0)', '-webkit-filter': 'blur(0)' },
                    { opacity: 0, filter: 'blur(5px)', '-webkit-filter': 'blur(5px)' }
                ], {
                    duration: exitDuration,
                    easing: customEasing,
                    fill: 'forwards'
                });
                animation.onfinish = () => {
                    outgoingLine.animationLock = false;
                    fadeLine.remove();
                };

                // 3. 100ms后再移除占位符并触发补位动画
                const removalTimer = setTimeout(() => {
                    // FLIP - FIRST: 记录所有元素在占位符消失前的位置
                    const oldPositions = new Map();
                    const recordPosition = (map, keyPrefix) => {
                        map.forEach((info, index) => {
                            // 排除即将被移除的当前占位符
                            if (keyPrefix === 'placeholder-' && index === lineIndex) return;
                            oldPositions.set(`${keyPrefix}${index}`, info.element.getBoundingClientRect());
                        });
                    };
                    recordPosition(displayedLines, 'line-');
                    recordPosition(placeholderLines, 'placeholder-');

                    // DOM 操作：移除占位符
                    clearMoveTransition(placeholderEl);
                    placeholderEl.remove();
                    placeholderLines.delete(lineIndex);

                    // FLIP - LAST: 读取新位置
                    const newPositions = new Map();
                    const readNewPosition = (map, keyPrefix) => {
                        map.forEach((info, index) => {
                            const key = `${keyPrefix}${index}`;
                            if (oldPositions.has(key)) {
                                newPositions.set(key, {
                                    element: info.element,
                                    rect: info.element.getBoundingClientRect()
                                });
                            }
                        });
                    };
                    readNewPosition(displayedLines, 'line-');
                    readNewPosition(placeholderLines, 'placeholder-');
                    
                    // FLIP - INVERT & PLAY
                    newPositions.forEach((newInfo, key) => {
                        const oldRect = oldPositions.get(key);
                        const newRect = newInfo.rect;
                        const deltaX = oldRect.left - newRect.left;
                        const deltaY = oldRect.top - newRect.top;

                        runFlipTransition(newInfo.element, deltaX, deltaY);
                    });
                }, placeholderDuration); // 100ms后再移除占位符

                placeholderLines.set(lineIndex, { element: placeholderEl, removalTimer: removalTimer });
                displayedLines.delete(lineIndex);
                scheduleAutoScale();
            }

            function updateLyricsDisplay() {
                const currentTime = audioPlayer.currentTime;
                const oldPositions = suppressAnimations ? new Map() : new Map();
                if (!suppressAnimations) {
                    // FIRST: 记录所有当前显示行和占位符的位置
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        oldPositions.set(`line-${lineIndex}`, lineInfo.element.getBoundingClientRect());
                    });
                    placeholderLines.forEach((lineInfo, lineIndex) => {
                        oldPositions.set(`placeholder-${lineIndex}`, lineInfo.element.getBoundingClientRect());
                    });
                }

                // 歌词行显示逻辑
                if (showAllLinesWhenPaused) {
                    // 暂停时，全部歌词行都显示
                    lyricsData.forEach((line, index) => {
                        if (!displayedLines.has(index)) {
                            addLine(index);
                        }
                    });
                    // 多余的行要移除
                    Array.from(displayedLines.keys()).forEach(index => {
                        if (index >= lyricsData.length) {
                            removeLine(index);
                        }
                    });
                } else {
                    // 正常模式，使用后端计算好的消失时机
                    lyricsData.forEach((line, index) => {
                        // 确保歌词行有音节数据
                        if (!line.syllables || line.syllables.length === 0) return;

                        const startTime = parseFloat(line.syllables[0].startTime); // 单位：秒
                        const disappearTime = line.disappearTime / 1000; // 从后端获取（毫秒 -> 秒）
                        
                        const isLineDisplayed = displayedLines.has(index);

                        // 判断是否应显示/消失
                        const isLineActive = (currentTime >= startTime - lineDisplayOffset) && (currentTime < disappearTime);

                        if (isLineActive && !isLineDisplayed) {
                            addLine(index);
                        } else if (!isLineActive && isLineDisplayed) {
                            removeLine(index);
                        }
                    });
                }

                if (!suppressAnimations) {
                    // LAST: 读取新位置
                    const newPositions = [];
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        const key = `line-${lineIndex}`;
                        if (oldPositions.has(key)) {
                            newPositions.push({
                                key,
                                element: lineInfo.element,
                                rect: lineInfo.element.getBoundingClientRect()
                            });
                        }
                    });
                    placeholderLines.forEach((lineInfo, lineIndex) => {
                        const key = `placeholder-${lineIndex}`;
                        if (oldPositions.has(key)) {
                            newPositions.push({
                                key,
                                element: lineInfo.element,
                                rect: lineInfo.element.getBoundingClientRect()
                            });
                        }
                    });

                    // INVERT & PLAY: 为移动的元素应用动画
                    newPositions.forEach(({ key, element, rect }) => {
                        const oldRect = oldPositions.get(key);
                        if (!oldRect) return;
                        const deltaX = oldRect.left - rect.left;
                        const deltaY = oldRect.top - rect.top;
                        runFlipTransition(element, deltaX, deltaY);
                    });
                }
                
                // 音节高亮逻辑 - 只处理active状态，卡拉OK进度由rafLoop处理
                if (displayedLines.size > 0) {
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        const lineEl = lineInfo.element;
                        const startTime = parseFloat(lineEl.dataset.startTime);
                        const endTime = parseFloat(lineEl.dataset.endTime);
                        // 当前播放歌词行加 active
                        if (currentTime >= startTime - lineDisplayOffset && currentTime < endTime) {
                            lineEl.classList.add('active');
                        } else {
                            lineEl.classList.remove('active');
                        }
                        syncLineAnimations(lineInfo);
                    });
                }
            }

            audioPlayer.addEventListener('timeupdate', () => {
                syncBackgroundVideo(false);
                updateLyricsDisplay();
            });
            audioPlayer.addEventListener('seeking', () => {
                syncBackgroundVideo(true);
            });
            audioPlayer.addEventListener('seeked', () => {
                syncBackgroundVideo(true);
            });
            // 监听暂停/播放事件，切换展示模式
            audioPlayer.addEventListener('pause', () => {
                syncBackgroundVideo(true);
                showAllLinesWhenPaused = true;
                autoScaleLocked = true;
                if (autoScaleRaf) {
                    cancelAnimationFrame(autoScaleRaf);
                    autoScaleRaf = null;
                }
                playerContainer.classList.add('paused-mode');
                withAnimationsSuppressed(() => {
                    updateLyricsDisplay();
                });
                // 滚动到当前播放的歌词行
                setTimeout(() => {
                    const currentLine = document.querySelector('.lyric-line.active');
                    if (currentLine) {
                        currentLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
                // 停止动画循环
                if (rafId != null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
            });
            audioPlayer.addEventListener('play', () => {
                syncBackgroundVideo(true);
                showAllLinesWhenPaused = false;
                autoScaleLocked = false;
                playerContainer.classList.remove('paused-mode');
                withAnimationsSuppressed(() => {
                    updateLyricsDisplay();
                });
                scheduleAutoScale();
                // 启动动画循环
                if (rafId == null) {
                    rafLoop();
                }
            });
            
            function togglePlayPause() {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            }

            document.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.code === 'Space') {
                    event.preventDefault();
                    togglePlayPause();
                } else if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 5);
                } else if (event.key === 'ArrowRight') {
                    event.preventDefault();
                    audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 5);
                }
            });
            
            // 全局点击：只要不是歌词行就切换播放/暂停
            document.body.addEventListener('click', function(e) {
                // 如果点击的是歌词行或其子元素，什么都不做
                if (e.target.closest('.lyric-line')) return;
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            });
            window.addEventListener('resize', scheduleAutoScale);

            await syncAnimationConfig();
            await loadData();
            scheduleAutoScale();
            
            // 页面加载后自动启动动画循环（如果音频正在播放）
            setTimeout(() => {
                if (!audioPlayer.paused && rafId == null) {
                    rafLoop();
                }
            }, 100);
            
            // 字体大小调整滑块逻辑
            fontSlider.addEventListener('input', (e) => {
                const nextScale = parseFloat(e.target.value) || 1;
                userLyricScale = nextScale;
                localStorage.setItem('lyricScale', nextScale);
                setLyricScale(computeAutoScaleTarget());
                scheduleAutoScale();
            });

            // 页面加载时应用缓存的字体大小
            const savedScale = localStorage.getItem('lyricScale');
            if (savedScale) {
                const parsedScale = parseFloat(savedScale);
                if (!Number.isNaN(parsedScale)) {
                    userLyricScale = parsedScale;
                    fontSlider.value = savedScale;
                    setLyricScale(computeAutoScaleTarget());
                }
            }

            // Safari animate 兼容降级
            function safeAnimate(element, keyframes, options) {
                if (element.animate) {
                    return element.animate(keyframes, options);
                } else {
                    // Safari 旧版降级：直接设置最终样式
                    Object.assign(element.style, keyframes[keyframes.length - 1]);
                    return { onfinish: () => {} };
                }
            }

            // 加载背景图片或视频
        });
    </script>
</body>
</html>
