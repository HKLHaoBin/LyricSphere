<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>动态歌词展示</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: #121212;
    color: #fff;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    cursor: pointer;
    position: relative;
  }
  .background-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;overflow:hidden}
  .background-container img,.background-container video{width:100%;height:100%;object-fit:cover;opacity:.2}
  .player-container{width:90%;text-align:center}
  .player-container.paused-mode{height:100%;overflow:auto;scrollbar-width:none;-ms-overflow-style:none}
  .player-container.paused-mode::-webkit-scrollbar{display:none}
  .lyrics-container{
    min-height:15em;overflow:hidden;position:relative;
    display:flex;flex-direction:column;justify-content:center;align-items:center;
  }
  .lyric-line{
    position:relative;font-size:calc(4.5em * var(--lyric-scale, 1));
    font-weight:bold;line-height:1.5;display:flex;flex-wrap:wrap;justify-content:center;align-items:center;
    color:rgba(255,255,255,.2);width:100%;
  }
  .blur-layer{
    position:absolute;top:0;left:0;width:100%;height:100%;
    display:flex;flex-wrap:wrap;justify-content:inherit;align-items:inherit;z-index:-1;pointer-events:none;
  }
  .blur-text{color:#fff;opacity:.1;filter:blur(8px);font-size:inherit;font-weight:inherit;line-height:inherit}
  .lyric-line.left-aligned{justify-content:flex-start}
  .lyric-line.center-aligned{justify-content:center}
  .lyric-line.right-aligned{justify-content:flex-end}
  .lyric-line.small-font{font-size:2.25em}

  /* ✅ 改动 1：占位行（flex 子项 + 定位容器），支持坍塌 & 绝对定位淡出 */
  .line-placeholder{
    width: 100%;
    flex: 0 0 auto;      /* 不被拉伸或压缩，按内容高度占位 */
    position: relative;  /* 让内部的消失行可相对它绝对定位 */
    pointer-events: none;
    /* 可选的高度过渡（不需要也行，FLIP 已保证顺滑） */
    --collapse-duration: 700ms;
    --easing: cubic-bezier(.27,.14,0,.99);
    transition: height var(--collapse-duration) var(--easing);
  }

  .syllable{
    position:relative;color:rgba(255,255,255,.2);
    text-shadow:0 0 12px rgba(255,255,255,.4);filter:blur(0);-webkit-filter:blur(0);
  }
  .syllable.highlight{color:#fff}
  .syllable.karaoke{
    /* 关键：把进度提到一个变量，双重断点 + 微小像素余量 */
    --p: var(--progress, 0%);
    --eps: var(--eps-px, 0.6px); /* 选用DPR自适应的像素值 */

    background:
      linear-gradient(
        90deg,
        #fff 0,
        #fff var(--p),                   /* 第一停靠：到进度 */
        rgba(255,255,255,.3) calc(var(--p) + var(--eps)), /* 第二停靠：+一个像素级余量 */
        rgba(255,255,255,.3) 100%
      );
    background-clip: text;
    -webkit-background-clip: text;
    color: transparent;
    -webkit-text-fill-color: transparent;

    /* 让渐变严格覆盖文本盒子，避免重复平铺带来的边界问题 */
    background-size: 100% 100%;
    background-repeat: no-repeat;
  }

  /* 结束态：彻底关闭渐变，使用正常文本绘制，避免尾像素缝隙 */
  .syllable.finished{
    background: none !important;
    background-clip: initial !important;
    -webkit-background-clip: initial !important;
    color: #fff !important;
    -webkit-text-fill-color: #fff !important;
  }

  .lyric-line.active{border-radius:.2em}
  .translation-line.left-aligned{text-align:left}
  .translation-line.center-aligned{text-align:center}
  .translation-line.right-aligned{text-align:right}
  .font-slider-container{display:none;position:fixed;bottom:20px;right:20px;z-index:1000}
  @media (max-width:768px){.font-slider-container{display:block}}
  /* 兜底：仅当最后一个没有“模拟空格”时才清零 */
  .lyric-line .syllable:last-of-type:not(.has-space) { margin-right: 0 !important; }
  .lyric-line .blur-layer .blur-text:last-of-type:not(.has-space) { margin-right: 0 !important; }
</style>
</head>
<body>
  <div class="player-container" id="player-container">
    <div id="lyrics-container" class="lyrics-container"></div>
  </div>
  <div class="font-slider-container">
    <input type="range" min="0.5" max="1.5" value="1" step="0.05" id="fontSlider" />
  </div>

<script>
// ====== AMLL 专用运行时（保持与 V1 完全一致的动画时序） ======
let amllConnected = false;
let serverNowTime = 0;               // 秒
let rafId = 0;
const INTERPOLATE_CLIENT = true;
let lastTickMs = 0;
function nowSec(){ return serverNowTime; }

// —— 与 V1 完全一致的参数 ——
window.lineDisplayOffset = 0.5;      // 行提前显示 0.5秒
window.syllableDisplayOffset = 0.2;  // 音节进度提前 0.2秒

// 其余控制参数
window.enterDuration = 700;
window.moveDuration = 700;
window.exitDuration = 700;
window.placeholderDuration = 50;   // 此值不再用于坍塌时机，仅保留兼容
window.customEasing = 'cubic-bezier(.27,.14,0,.99)';
window.showAllLinesWhenPaused = false;
window.ERROR_MARGIN = 0.1;
window.forceFullFillAfterEnd = true;  // 完全到头规则：确保音节结束后完全填充

// 全局数据
window.lyricsData = [];
window.forceCenterAlign = false;
window.translationData = [];
window.displayedLines = new Map();
window.placeholderLines = new Map();
const moveTransitionCleanup = new WeakMap(); // 存储当前位移动画信息

function clearMoveTransition(element){
  if (!element) return { residualX: 0, residualY: 0, progress: 0 };
  const record = moveTransitionCleanup.get(element);
  if (!record) return { residualX: 0, residualY: 0, progress: 0 };

  moveTransitionCleanup.delete(element);

  let progress = 0;
  let residualX = 0;
  let residualY = 0;

  const { animation, fromX = 0, fromY = 0 } = record;
  if (animation && animation.effect && typeof animation.effect.getComputedTiming === 'function'){
    try {
      const timing = animation.effect.getComputedTiming();
      if (timing && typeof timing.progress === 'number'){
        progress = Math.max(0, Math.min(1, timing.progress));
      }
    } catch (e) { /* 忽略 */ }
  }

  const remaining = 1 - progress;
  residualX = fromX * remaining;
  residualY = fromY * remaining;

  try { animation.cancel(); } catch (e) { /* 忽略 */ }

  element.style.transform = '';
  element.style.willChange = '';

  return { residualX, residualY, progress };
}

function runFlipTransition(element, deltaX, deltaY){
  if (!element) return;
  const { residualX, residualY, progress } = clearMoveTransition(element);

  const adjustedDeltaX = deltaX + residualX;
  const adjustedDeltaY = deltaY + residualY;

  if (Math.abs(adjustedDeltaX) <= 0.5 && Math.abs(adjustedDeltaY) <= 0.5) return;

  const baseMoveDuration = window.moveDuration || 700;
  const durationFactor = progress > 0 ? Math.max(0.35, 1 - progress * 0.6) : 1;
  const animationDuration = Math.max(180, baseMoveDuration * durationFactor);
  const easing = progress > 0.2 ? 'linear' : (window.customEasing || 'linear');

  element.style.willChange = 'transform';
  const animation = element.animate(
    [
      { transform: `translate(${adjustedDeltaX}px, ${adjustedDeltaY}px)` },
      { transform: 'translate(0, 0)' }
    ],
    {
      duration: animationDuration,
      easing,
      fill: 'forwards',
      composite: 'add'
    }
  );

  const record = { animation, fromX: adjustedDeltaX, fromY: adjustedDeltaY };

  const finalize = () => {
    if (moveTransitionCleanup.get(element) !== record) return;
    moveTransitionCleanup.delete(element);
    element.style.transform = '';
    element.style.willChange = '';
  };

  animation.addEventListener('finish', finalize, { once: true });
  animation.addEventListener('cancel', finalize, { once: true });

  moveTransitionCleanup.set(element, record);
}

// ✅ 避免和自动补位重复：FLIP 期间抑制 updateLyricsDisplay 的内置补位
window.suppressAutoFLIP = false;

// —— 与 V1 完全一致的卡拉OK进度渲染 ——
window.renderKaraoke = () => {
  const now = nowSec() - window.syllableDisplayOffset;
  const linesToRender = document.querySelectorAll('.lyric-line'); // 渲染所有已显示的行
  linesToRender.forEach(lineEl => {
    lineEl.querySelectorAll('.syllable').forEach(syllableEl => {
      const start = parseFloat(syllableEl.dataset.startTime);
      const duration = parseFloat(syllableEl.dataset.duration);
      const end = start + duration;
      let progress = 0;

      if (now >= start && now <= end) {
        progress = ((now - start) / duration) * 100;
      } else if (now > end) {
        // ✅ 进入完成态：直接切换样式，彻底取消渐变带来的拼缝风险
        syllableEl.classList.add('finished');
        syllableEl.classList.remove('karaoke');
        syllableEl.style.removeProperty('--progress');
        return; // 结束态不再设置渐变
      }

      // 尚未结束：确保处于渐变态
      syllableEl.classList.remove('finished');
      if (!syllableEl.classList.contains('karaoke')) {
        syllableEl.classList.add('karaoke');
      }
      syllableEl.style.setProperty('--progress', progress + '%');
    });
  });
};

// —— 预处理歌词：生成 disappearTime 与翻译时间表 ——
window.setLyricsData = (lines) => {
  const normalized = (lines || []).map((line,i,arr) => {
    const hasSyl = line?.syllables?.length > 0;
    const first = hasSyl ? line.syllables[0] : null;
    const last  = hasSyl ? line.syllables[line.syllables.length-1] : null;

    const startTime = hasSyl ? parseFloat(first.startTime)
                             : (i>0 ? parseFloat(arr[i-1]?.syllables?.at(-1)?.startTime ?? 0) : 0);
    const endTime   = hasSyl ? (parseFloat(last.startTime)+parseFloat(last.duration))
                             : (startTime + 2);

    const nextStartTime = (() => {
      const next = arr[i+1];
      if (next?.syllables?.length > 0) return parseFloat(next.syllables[0].startTime);
      return endTime + 4;
    })();

    const disappearTime = Math.min(endTime + 0.6, nextStartTime - 0.1);
    return { ...line, disappearTime: Math.max(startTime + 0.01, disappearTime) };
  });

  window.translationData = (lines || [])
    .filter(l => l?.translatedLyric && l?.syllables?.length > 0)
    .map(l => ({ timeMs: Math.round(parseFloat(l.syllables[0].startTime) * 1000), content: l.translatedLyric }));

  window.lyricsData = normalized;

  // 检测是否存在对唱歌词
  window.hasAnyDuet = (lines || []).some(l => l?.isDuet === true);

  // 初始化对齐记忆表
  window.alignMap = new Map();

  if (window.renderLyricsOnce) window.renderLyricsOnce();
  if (window.updateLyricsDisplay) window.updateLyricsDisplay();
  if (typeof window.hideWaiting === 'function') window.hideWaiting();
};

// 渲染主循环
function tick(){
  try{
    if (INTERPOLATE_CLIENT){
      const nowPerf = performance.now();
      const delta = (nowPerf - lastTickMs) / 1000; // 秒
      lastTickMs = nowPerf;
      serverNowTime += delta;
    }
    if (window.renderKaraoke) window.renderKaraoke();
    if (window.updateLyricsDisplay) window.updateLyricsDisplay();
  } finally {
    rafId = requestAnimationFrame(tick);
  }
}

// —— AMLL 事件流 —— //
function applyLyrics(lines){ window.setLyricsData ? window.setLyricsData(lines) : console.log("[AMLL] lyrics lines:", lines);
  if (typeof hideWaiting === "function") hideWaiting(); else if (typeof window.hideWaiting === "function") window.hideWaiting(); }
function applySong(song){
  const el = document.getElementById('songTitle');
  if (el && song){
    const artists = (song.artists || []).join(" / ");
    el.textContent = `${song.musicName || ""} — ${artists}`;
  }
}
function startSSE(){
  const es = new EventSource('/amll/stream');
  es.addEventListener('open', () => { amllConnected = true; document.body.classList.add('amll-connected'); });

  es.addEventListener('state', (e) => {
    const st = JSON.parse(e.data);
    if (st.song) applySong(st.song);
    if (Array.isArray(st.lines)) applyLyrics(st.lines);
    serverNowTime = (st.progress_ms | 0) / 1000;
    if (window.updateLyricsDisplay) window.updateLyricsDisplay();
    if (window.renderKaraoke) window.renderKaraoke();
  });

  es.addEventListener('lyrics', (e) => {
    const { lines } = JSON.parse(e.data);
    if (Array.isArray(lines)) {
      // 保存当前播放时间到 localStorage
      localStorage.setItem('lastPlaybackTime', serverNowTime.toString());
      // 保存歌词数据到 sessionStorage
      sessionStorage.setItem('pendingLyrics', JSON.stringify(lines));
      // 立即刷新页面以使用新歌词
      location.reload();
    }
  });

  es.addEventListener('progress', (e) => {
    const { progress_ms } = JSON.parse(e.data);
    serverNowTime = Math.max(serverNowTime, (progress_ms | 0) / 1000);
    lastTickMs = performance.now();
    if (window.updateLyricsDisplay) window.updateLyricsDisplay();
    if (window.renderKaraoke) window.renderKaraoke();
  });

  es.addEventListener('song', (e) => {
    const { song } = JSON.parse(e.data);
    applySong(song);
  });

  es.addEventListener('error', (e) => { console.warn('[AMLL] SSE error', e); });
}

document.addEventListener('DOMContentLoaded', () => {
  const lyricsContainer = document.getElementById('lyrics-container');
  const playerContainer = document.getElementById('player-container');
  const fontSlider = document.getElementById('fontSlider');

  // 检查是否有待处理的歌词数据
  const pendingLyrics = sessionStorage.getItem('pendingLyrics');
  if (pendingLyrics) {
    const lines = JSON.parse(pendingLyrics);
    sessionStorage.removeItem('pendingLyrics');

    // 恢复播放时间
    const lastPlaybackTime = localStorage.getItem('lastPlaybackTime');
    if (lastPlaybackTime) {
      serverNowTime = parseFloat(lastPlaybackTime);
      localStorage.removeItem('lastPlaybackTime');
    }

    // 立即应用歌词数据
    if (window.setLyricsData) window.setLyricsData(lines);
  }

  // 等待提示（首屏占位）
  const waiting = document.createElement('div');
  waiting.id = 'waiting';
  waiting.textContent = '等待 AMLL 客户端连接…';
  lyricsContainer.appendChild(waiting);
  window.hideWaiting = function(){ const w = document.getElementById('waiting'); if (w) w.remove(); };

  // 开始 SSE & RAF
  startSSE();
  if (!rafId) rafId = requestAnimationFrame(tick);

  // —— DOM 构建 —— //
  function createLineElement(lineIndex){
    const line = window.lyricsData[lineIndex];
    if (!line) return null;

    const lineEl = document.createElement('div');
    lineEl.classList.add('lyric-line');
    lineEl.dataset.lineIndex = lineIndex;

    // 计算这行应使用的对齐与字号
    let alignClass = 'center-aligned'; // 默认居中（当整首歌没有对唱时用）
    let isSmallFont = (line.style && line.style.fontSize === 'small') || false;

    // 若本歌单出现过对唱 -> 启用左右分轨模式
    if (window.hasAnyDuet) {
      if (line.isBG) {
        // 背景行：跟随上一条主歌词的对齐
        const follow = getPrevPrimaryAlign(lineIndex);
        alignClass = (follow === 'right') ? 'right-aligned' : 'left-aligned';
        isSmallFont = true; // 背景一律小字号
      } else if (line.isDuet) {
        alignClass = 'right-aligned';
        window.alignMap.set(lineIndex, 'right');
      } else {
        alignClass = 'left-aligned';
        window.alignMap.set(lineIndex, 'left');
      }
    } else {
      // 没有对唱：保留你原本的体验（非对唱强制居中）
      alignClass = 'center-aligned';
      // 若你想：也可以让背景在"无对唱时"仍跟随上一条主歌词（通常也居中），这里就不动
      if (line.isBG) { isSmallFont = true; }
    }

    // 应用到 DOM
    lineEl.classList.add(alignClass);
    if (isSmallFont) lineEl.classList.add('small-font');

    if (line.syllables && line.syllables.length > 0){
      const first = line.syllables[0];
      const last  = line.syllables[line.syllables.length - 1];
      const startTime = parseFloat(first.startTime);
      const endTime   = parseFloat(last.startTime) + parseFloat(last.duration);
      lineEl.dataset.startTime = String(startTime);
      lineEl.dataset.endTime   = String(endTime);
    }

    // 模糊层
    const blurLayer = document.createElement('div');
    blurLayer.className = 'blur-layer';
    lineEl.appendChild(blurLayer);

    // 先把行插到容器里，再做样式复制更稳定
    lyricsContainer.appendChild(lineEl);
    const cs = getComputedStyle(lineEl);
    blurLayer.style.justifyContent = cs.justifyContent;
    blurLayer.style.alignItems = cs.alignItems;

    // 模糊字：空格模拟（与正文保持一致）
    line.syllables.forEach((syllable, idx) => {
      const blurText = document.createElement('span');
      blurText.className = 'blur-text';
      blurText.textContent = syllable.text;
      blurText.style.fontSize = cs.fontSize;
      blurText.style.fontWeight = cs.fontWeight;
      blurText.style.lineHeight = cs.lineHeight;

      const SPACE_EM = 0.28; // 单个空格的视觉宽度，可按字体微调 0.25~0.33
      const trailing = (syllable.text?.match(/\s+$/)?.[0] ?? '');
      const spaceCount = trailing.length;
      if (spaceCount > 0) {
        blurText.classList.add('has-space');
        blurText.style.setProperty('margin-right', `${SPACE_EM * spaceCount}em`);
      }
      blurLayer.appendChild(blurText);
    });

    // 音节：空格模拟 + 停顿间距叠加
    line.syllables.forEach((syllable, idx) => {
      const syllableEl = document.createElement('span');
      syllableEl.classList.add('syllable');
      syllableEl.textContent = syllable.text;
      syllableEl.dataset.startTime    = syllable.startTime;
      syllableEl.dataset.duration     = syllable.duration;

      const notLast = idx < line.syllables.length - 1;

      // —— 仅基于文本空格判断空格，移除基于时间延迟的判断 ——
      const SPACE_EM = 0.28; // 单个空格对应的 em 宽度
      const trailing = (syllable.text?.match(/\s+$/)?.[0] ?? '');
      const spaceCount = trailing.length;

      if (spaceCount > 0) {
        syllableEl.classList.add('has-space');
        const marginEm = SPACE_EM * spaceCount;
        syllableEl.style.setProperty('margin-right', `${marginEm}em`);
      }

      lineEl.appendChild(syllableEl);
    });

    // 翻译（按 V1 规则 ±0.2s 匹配首音节）
    if (window.translationData.length > 0 && line.syllables?.length > 0){
      const startTime = parseFloat(line.syllables[0].startTime);
      let minDelta = 0.201, bestTrans = null;
      for (const t of window.translationData){
        const d = Math.abs(t.timeMs / 1000 - startTime);
        if (d < minDelta){ minDelta = d; bestTrans = t; }
      }
      if (bestTrans && minDelta <= 0.2){
        const transDiv = document.createElement('div');
        transDiv.className = 'translation-line';
        transDiv.style.fontSize = isSmallFont ? '0.8em' : '0.5em';
        transDiv.style.color = '#ffffff';
        transDiv.style.fontWeight = 'normal';
        transDiv.style.lineHeight = '1.2';
        transDiv.style.marginTop = '0.1em';
        transDiv.style.width = '100%';
        transDiv.textContent = bestTrans.content;
        if (lineEl.classList.contains('left-aligned'))  transDiv.classList.add('left-aligned');
        if (lineEl.classList.contains('center-aligned'))transDiv.classList.add('center-aligned');
        if (lineEl.classList.contains('right-aligned')) transDiv.classList.add('right-aligned');
        lineEl.appendChild(transDiv);
        // 调整模糊层高度
        setTimeout(() => {
          const h = transDiv.offsetHeight;
          if (h > 0 && blurLayer) blurLayer.style.height = `calc(100% - ${h}px)`;
        }, 0);
      }
    }

    // 初始插入动画
    const animation = safeAnimate(lineEl,
      [{opacity:0, filter:'blur(5px)', '-webkit-filter':'blur(5px)'},
       {opacity:1, filter:'blur(0)',   '-webkit-filter':'blur(0)'}],
      {duration: window.enterDuration, easing: window.customEasing, fill:'forwards'}
    );
    animation.onfinish = () => { lineEl.animationLock = false; };
    return lineEl;
  }

  function renderLyricsOnce(){
    lyricsContainer.innerHTML = '';
    window.displayedLines.clear();
    window.placeholderLines.clear();
    if (window.lyricsData.length === 0){
      lyricsContainer.textContent = '暂无歌词。';
      return;
    }
    updateLyricsDisplay();
  }

  function addLine(lineIndex){
    if (window.displayedLines.has(lineIndex)) return;

    if (window.placeholderLines.has(lineIndex)){
      const ph = window.placeholderLines.get(lineIndex);
      clearTimeout(ph.removalTimer);
      clearMoveTransition(ph.element);
      ph.element.remove();
      window.placeholderLines.delete(lineIndex);
    }

    const incomingLine = createLineElement(lineIndex);
    if (!incomingLine) return;
    if (incomingLine.animationLock) return;
    incomingLine.animationLock = true;

    // 插入到正确顺序
    let inserted = false;
    const children = Array.from(lyricsContainer.children);
    for (let i=0;i<children.length;i++){
      const childIndex = parseInt(children[i].dataset.lineIndex,10);
      if (!isNaN(childIndex) && childIndex > lineIndex){
        lyricsContainer.insertBefore(incomingLine, children[i]); inserted = true; break;
      }
    }
    if (!inserted) lyricsContainer.appendChild(incomingLine);
    window.displayedLines.set(lineIndex, { element: incomingLine });

    const ani = safeAnimate(incomingLine,
      [{opacity:0, filter:'blur(5px)', '-webkit-filter':'blur(5px)'},
       {opacity:1, filter:'blur(0)',   '-webkit-filter':'blur(0)'}],
      {duration: window.enterDuration, easing: window.customEasing, fill:'forwards'}
    );
    ani.onfinish = () => { incomingLine.animationLock = false; };
  }

  /* ✅ 改动 2：批量 FLIP 调度器（同一帧合并多行的坍塌与补位） */
  const FLIP = {
    scheduled: false,
    placeholders: new Set(),
    run(){
      if (this.scheduled) return;
      this.scheduled = true;

      requestAnimationFrame(() => {
        window.suppressAutoFLIP = true;  // 暂停内置补位，避免叠加

        // FIRST：记录坍塌前的位置（含占位符当前高度）
        const first = new Map();
        window.displayedLines.forEach((info, idx) => first.set(`line-${idx}`, info.element.getBoundingClientRect()));
        window.placeholderLines.forEach((info, idx) => first.set(`ph-${idx}`, info.element.getBoundingClientRect()));

        // MUTATE：让所有占位符“立即坍塌到 0”
        this.placeholders.forEach(ph => { ph.style.height = '0px'; });
        // 强制 reflow 确认布局
        void lyricsContainer.offsetHeight;

        // LAST：记录坍塌后的新位置
        const last = new Map();
        window.displayedLines.forEach((info, idx) => last.set(`line-${idx}`, info.element.getBoundingClientRect()));
        window.placeholderLines.forEach((info, idx) => last.set(`ph-${idx}`, info.element.getBoundingClientRect()));

        // INVERT + PLAY：仅对仍在场的歌词行做补位动画
        last.forEach((rect, key) => {
          if (!key.startsWith('line-')) return;
          const idx = parseInt(key.slice(5), 10);
          const elInfo = window.displayedLines.get(idx);
          if (!elInfo?.element) return;

          const o = first.get(key);
          const dx = o.left - rect.left;
          const dy = o.top  - rect.top;
          runFlipTransition(elInfo.element, dx, dy);
        });

        // 一段时间后恢复内置补位
        setTimeout(() => { window.suppressAutoFLIP = false; }, window.moveDuration);
        this.placeholders.clear();
        this.scheduled = false;
      });
    }
  };

  /* ✅ 改动 3：removeLine —— “淡出即坍塌”，多行同时滚动更稳 */
  function removeLine(lineIndex){
    const info = window.displayedLines.get(lineIndex);
    if (!info) return;

    const outgoing = info.element;
    if (outgoing.animationLock) return;
    outgoing.animationLock = true;
    clearMoveTransition(outgoing);

    // 读取原始高度
    const rect = outgoing.getBoundingClientRect();

    // 1) 插入“可被 flex 管控”的占位符，并把旧行移进去
    const placeholder = document.createElement('div');
    placeholder.className = 'line-placeholder';
    placeholder.style.height = `${rect.height}px`;      // 先用原高度占位
    outgoing.before(placeholder);
    placeholder.appendChild(outgoing);                   // 旧行放进占位符里

    // 旧行相对占位符绝对定位，在局部坐标里淡出
    Object.assign(outgoing.style, { position:'absolute', left:'0', top:'0', width:'100%' });

    // 2) 启动淡出（与坍塌重叠进行）
    const fadeOut = safeAnimate(outgoing,
      [{ opacity:1, filter:'blur(0)', '-webkit-filter':'blur(0)' },
       { opacity:0, filter:'blur(5px)', '-webkit-filter':'blur(5px)' }],
      { duration: window.exitDuration, easing: window.customEasing, fill:'forwards' }
    );
    fadeOut.onfinish = () => { outgoing.animationLock = false; outgoing.remove(); };

    // 3) 立刻加入批量 FLIP：同一帧把多个行的坍塌统一处理
    window.placeholderLines.set(lineIndex, { element: placeholder, removalTimer: null });
    FLIP.placeholders.add(placeholder);
    FLIP.run();

    // 4) 动画都结束后，再移除占位符
    const settleTime = Math.max(window.exitDuration, window.moveDuration);
    const removalTimer = setTimeout(() => {
      clearMoveTransition(placeholder);
      placeholder.remove();
      window.placeholderLines.delete(lineIndex);
    }, settleTime);
    const placeholderInfo = window.placeholderLines.get(lineIndex);
    if (placeholderInfo) {
      placeholderInfo.removalTimer = removalTimer;
    }

    window.displayedLines.delete(lineIndex);
  }

  function updateLyricsDisplay(){
    const now = nowSec();

    // FIRST：记录位置
    const oldPositions = new Map();
    window.displayedLines.forEach((info, idx)=>{ oldPositions.set(idx, info.element.getBoundingClientRect()); });
    window.placeholderLines.forEach((info, idx)=>{ oldPositions.set(idx, info.element.getBoundingClientRect()); });

    // 显示/隐藏逻辑（提前 0.5s）
    if (window.showAllLinesWhenPaused){
      window.lyricsData.forEach((_, idx) => { if (!window.displayedLines.has(idx)) addLine(idx); });
      Array.from(window.displayedLines.keys()).forEach(idx => { if (idx >= window.lyricsData.length) removeLine(idx); });
    } else {
      window.lyricsData.forEach((line, index) => {
        if (!line.syllables || line.syllables.length === 0) return;
        const startTime     = parseFloat(line.syllables[0].startTime);
        const disappearTime = line.disappearTime;
        const isShown       = window.displayedLines.has(index);
        const isActive      = (now >= (startTime - window.lineDisplayOffset)) && (now < disappearTime);
        if (isActive && !isShown) addLine(index);
        else if (!isActive && isShown) removeLine(index);
      });
    }

    // LAST：仅在非 FLIP 期间做内置补位，避免两套动画叠加
    if (!window.suppressAutoFLIP){
      const newPositions = new Map();
      window.displayedLines.forEach((info, idx) => { if (oldPositions.has(idx)) newPositions.set(idx, info.element.getBoundingClientRect()); });
      window.placeholderLines.forEach((info, idx) => { if (oldPositions.has(idx)) newPositions.set(idx, info.element.getBoundingClientRect()); });

      newPositions.forEach((nRect, idx) => {
        const oRect = oldPositions.get(idx);
        const lineObj = window.displayedLines.get(idx);
        if (!lineObj?.element) return;
        const dx = oRect.left - nRect.left;
        const dy = oRect.top  - nRect.top;
        runFlipTransition(lineObj.element, dx, dy);
      });
    }

    // active 行（也按提前 0.5s）
    if (window.displayedLines.size > 0){
      window.displayedLines.forEach(({element}) => {
        const s = parseFloat(element.dataset.startTime);
        const e = parseFloat(element.dataset.endTime);
        if (now >= (s - window.lineDisplayOffset) && now < e) {
          element.classList.add('active');
        } else {
          // 行不再 active：把残留的渐变音节兜底切成完成态
          if (element.classList.contains('active')) {
            element.querySelectorAll('.syllable.karaoke').forEach(syl => {
              syl.classList.remove('karaoke');
              syl.classList.add('finished');
              syl.style.removeProperty('--progress');
            });
          }
          element.classList.remove('active');
        }
      });
    }
  }

  // 字体缩放
  fontSlider.addEventListener('input', (e)=>{
    playerContainer.style.setProperty('--lyric-scale', e.target.value);
    localStorage.setItem('lyricScale', e.target.value);
  });
  const savedScale = localStorage.getItem('lyricScale');
  if (savedScale){ fontSlider.value = savedScale; playerContainer.style.setProperty('--lyric-scale', savedScale); }

  // 根据设备像素比调整抗缝余量
  const dpr = window.devicePixelRatio || 1;
  // 粗略经验：1x → 0.6px；2x → 0.8px；3x 以上 → 1px
  const eps = dpr >= 3 ? 1 : (dpr >= 2 ? 0.8 : 0.6);
  document.documentElement.style.setProperty('--eps-px', `${eps}px`);

  // 获取上一个主歌词的对齐方式
  function getPrevPrimaryAlign(lineIndex){
    for (let i = lineIndex - 1; i >= 0; i--){
      const l = window.lyricsData[i];
      if (l && !l.isBG){
        const a = window.alignMap.get(i);
        if (a) return a;
      }
    }
    return 'left'; // 找不到就用左
  }

  // 判断是否为对唱歌词
  function isDuetLyric(line){
    if (line?.isDuet === true) return true;
    // ↓ 以下保留你的旧兜底逻辑
    if (line?.style?.part) return true;
    if (line?.style?.duet) return true;
    if (line?.exclusive) return true;
    if (line?.syllables?.length > 0){
      const t = line.syllables[0]?.text || '';
      if (/^\[.*\]/.test(t)) return true;
    }
    return false;
  }

  // animate 兼容
  window.safeAnimate = function(element, keyframes, options){
    if (element.animate) return element.animate(keyframes, options);
    Object.assign(element.style, keyframes[keyframes.length - 1]); return { onfinish: ()=>{} };
  };

  // 背景加载
  async function loadBackground(backgroundPath){
    let path = backgroundPath.replace(/^\.\//,'');
    const isAbsolute = /^https?:\/\//i.test(path);
    const url = isAbsolute ? path : (path.startsWith('/') ? path : '/' + path);
    const container = document.createElement('div'); container.className='background-container'; document.body.appendChild(container);
    const ext = path.split('.').pop().toLowerCase(); const isVideo = ['mp4','webm','ogg'].includes(ext);
    if (isVideo){ const v=document.createElement('video'); v.src=url; v.muted=true; v.loop=true; v.autoplay=true; v.onerror=()=>container.remove(); container.appendChild(v); }
    else { const img=document.createElement('img'); img.src=url; img.onerror=()=>container.remove(); container.appendChild(img); }
  }

  // 暴露接口
  window.updateLyricsDisplay = updateLyricsDisplay;
  window.renderLyricsOnce = renderLyricsOnce;
  window.createLineElement = createLineElement;
  window.addLine = addLine;
  window.removeLine = removeLine;
});
</script>
</body>
</html>
