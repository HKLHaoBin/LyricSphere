<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LyricSphere</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --card-bg: #ffffff;
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            --input-bg: rgba(255, 255, 255, 0.9);
            --border-color: #e9ecef;
            --tag-bg: #f8f9fa;
            --modal-bg: #ffffff;
            --button-bg: #495057;
            --button-text: #fff;
            --status-bg-default: #e7f5ff;
            --status-color-default: #1c7ed6;
            --status-bg-info: #e7f5ff;
            --status-color-info: #1c7ed6;
            --status-bg-success: #e6fcf5;
            --status-color-success: #0c8599;
            --status-bg-error: #ffe3e3;
            --status-color-error: #c92a2a;
            --status-progress-bg: rgba(33, 33, 33, 0.92);
            --status-progress-color: #ffffff;
            --status-progress-desc-color: rgba(0, 0, 0, 0.72);
        }

        .dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --card-bg: rgba(45, 45, 45, 0.9);
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            --input-bg: rgba(45, 45, 45, 0.9);
            --border-color: #404040;
            --tag-bg: #404040;
            --modal-bg: #333333;
            --button-bg: #606060;
            --button-text: #ffffff;
            --status-bg-default: rgba(77, 171, 247, 0.18);
            --status-color-default: #9bd4ff;
            --status-bg-info: rgba(77, 171, 247, 0.18);
            --status-color-info: #9bd4ff;
            --status-bg-success: rgba(18, 184, 134, 0.2);
            --status-color-success: #7fe7c7;
            --status-bg-error: rgba(255, 107, 107, 0.25);
            --status-color-error: #ffb3b3;
            --status-progress-bg: rgba(20, 20, 20, 0.92);
            --status-progress-color: #ffffff;
            --status-progress-desc-color: rgba(255, 255, 255, 0.78);
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', system-ui, sans-serif;
            /* max-width: 100%; */
            margin: 0;
            /* padding: 39px; */
            padding-top: 70px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media screen and (max-width: 768px), screen and (orientation: portrait) {
            body {
                padding-top: 80px;
            }
        }

        .json-list {
            display: flex;
            /* margin: 12px; */
            flex-wrap: wrap;
            /* gap: 0px; */
            /* margin: 2px -8px; */
            /* width: calc(100% + 20px); */
            list-style: none;
            padding: 0 10px;
            justify-content: center;
        }

        .list-status {
            margin: 6px 14px;
            color: #666;
            display: none;
            align-items: center;
            gap: 8px;
            min-height: 24px;
        }

        .list-status .spinner {
            width: 18px;
            height: 18px;
            border: 3px solid #ddd;
            border-top-color: #4a90e2;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .auth-status {
            padding: 10px;
            border-radius: 8px;
            background: var(--tag-bg);
            color: var(--text-color);
            text-align: center;
            border: 1px solid var(--border-color);
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        /* From Uiverse.io by mobinkakei */
        #wifiLoaderWrapper {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: none;
        }

        #wifi-loader {
            --background: #62abff;
            --front-color: #4f29f0;
            --back-color: #c3c8de;
            --text-color: #414856;
            width: 64px;
            height: 64px;
            border-radius: 50px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        #wifi-loader svg {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #wifi-loader svg circle {
            position: absolute;
            fill: none;
            stroke-width: 6px;
            stroke-linecap: round;
            stroke-linejoin: round;
            transform: rotate(-100deg);
            transform-origin: center;
        }

        #wifi-loader svg circle.back {
            stroke: var(--back-color);
        }

        #wifi-loader svg circle.front {
            stroke: var(--front-color);
        }

        #wifi-loader svg.circle-outer {
            height: 86px;
            width: 86px;
        }

        #wifi-loader svg.circle-outer circle {
            stroke-dasharray: 62.75 188.25;
        }

        #wifi-loader svg.circle-outer circle.back {
            animation: circle-outer135 1.8s ease infinite 0.3s;
        }

        #wifi-loader svg.circle-outer circle.front {
            animation: circle-outer135 1.8s ease infinite 0.15s;
        }

        #wifi-loader svg.circle-middle {
            height: 60px;
            width: 60px;
        }

        #wifi-loader svg.circle-middle circle {
            stroke-dasharray: 42.5 127.5;
        }

        #wifi-loader svg.circle-middle circle.back {
            animation: circle-middle6123 1.8s ease infinite 0.25s;
        }

        #wifi-loader svg.circle-middle circle.front {
            animation: circle-middle6123 1.8s ease infinite 0.1s;
        }

        #wifi-loader svg.circle-inner {
            height: 34px;
            width: 34px;
        }

        #wifi-loader svg.circle-inner circle {
            stroke-dasharray: 22 66;
        }

        #wifi-loader svg.circle-inner circle.back {
            animation: circle-inner162 1.8s ease infinite 0.2s;
        }

        #wifi-loader svg.circle-inner circle.front {
            animation: circle-inner162 1.8s ease infinite 0.05s;
        }

        #wifi-loader .text {
            position: absolute;
            bottom: -40px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-transform: lowercase;
            font-weight: 500;
            font-size: 14px;
            letter-spacing: 0.2px;
        }

        #wifi-loader .text::before,
        #wifi-loader .text::after {
            content: attr(data-text);
        }

        #wifi-loader .text::before {
            color: var(--text-color);
        }

        #wifi-loader .text::after {
            color: var(--front-color);
            animation: text-animation76 3.6s ease infinite;
            position: absolute;
            left: 0;
        }

        @keyframes circle-outer135 {
            0% {
                stroke-dashoffset: 25;
            }

            25% {
                stroke-dashoffset: 0;
            }

            65% {
                stroke-dashoffset: 301;
            }

            80% {
                stroke-dashoffset: 276;
            }

            100% {
                stroke-dashoffset: 276;
            }
        }

        @keyframes circle-middle6123 {
            0% {
                stroke-dashoffset: 17;
            }

            25% {
                stroke-dashoffset: 0;
            }

            65% {
                stroke-dashoffset: 204;
            }

            80% {
                stroke-dashoffset: 187;
            }

            100% {
                stroke-dashoffset: 187;
            }
        }

        @keyframes circle-inner162 {
            0% {
                stroke-dashoffset: 9;
            }

            25% {
                stroke-dashoffset: 0;
            }

            65% {
                stroke-dashoffset: 106;
            }

            80% {
                stroke-dashoffset: 97;
            }

            100% {
                stroke-dashoffset: 97;
            }
        }

        @keyframes text-animation76 {
            0% {
                clip-path: inset(0 100% 0 0);
            }

            50% {
                clip-path: inset(0);
            }

            100% {
                clip-path: inset(0 0 0 100%);
            }
        }

        .json-item {
            background: var(--card-bg);
            border-radius: 30px;
            box-shadow: var(--card-shadow);
            transition: transform 0.2s, box-shadow 0.2s;
            /* flex: 0 0 calc(33.33% - 20px); */
            margin: 12px;
            padding: 18px;
            /* box-sizing: border-box; */
            max-width: 570px;
            min-width: 420px;
            display: flex;
            flex-direction: column;
        }

        .json-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.1);
        }

        .json-item-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .file-name {
            color: var(--text-color);
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-name.has-cover {
            justify-content: space-between;
        }

        .file-name-text {
            flex: 0 1 auto;
        }

        .album-cover {
            height: 120px;
            width: auto;
            object-fit: contain;
            border-radius: 6px;
        }

        .file-name::before {
            content: 'üéµ';
            font-size: 1.2em;
        }

        .json-item-actions {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-top: 12px;
        }

        .style-buttons {
            display: flex;
            flex-direction: row;
            gap: 12px;
            margin: 0;
        }

        .style-button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .am-style {
            background: linear-gradient(135deg, #4dabf7, #69db7c);
            color: #fff;
        }

        .fs-style {
            background: linear-gradient(135deg, #ff6b6b, #ff922b);
            color: #fff;
        }

        .fslr-style {
            background: linear-gradient(135deg, #da77f2, #cc5de8);
            color: #fff;
        }

        .action-button {
            background: var(--button-bg, #495057);
            color: var(--button-text, #fff);
            padding: 8px 16px;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .action-button:hover {
            background: #343a40;
        }

        .search-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            padding: 15px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            z-index: 1000;
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease,
                box-shadow 0.3s ease,
                border-color 0.3s ease;
        }

        .search-box {
            flex: 1;
            padding: 12px 18px;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--input-bg);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .search-box:focus {
            border-color: #4dabf7;
            box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.15),
                0 4px 12px rgba(77, 171, 247, 0.1);
            background: white;
        }

        .search-box::placeholder {
            color: #868e96;
            opacity: 0.8;
        }

        .file-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 0;
        }

        .file-preview {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 3px;
            display: none;
        }

        .preview-content {
            white-space: pre-wrap;
            font-family: monospace;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background: var(--modal-bg);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin: 6% auto;
            padding: 20px;
            width: 95%;
            height: 80%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s ease;
        }

        .modal-content>div {
            overflow-y: auto;
            padding-right: 8px;
        }

        .lyrics-search-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1.3fr;
            gap: 14px;
            height: 100%;
            min-width: 0;
        }

        .lyrics-search-panel {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            background: var(--input-bg);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
            min-width: 0;
        }

        .lyrics-search-status {
            font-size: 0.9em;
            color: #666;
        }

        .lyrics-search-results {
            border: 1px dashed var(--border-color);
            border-radius: 10px;
            padding: 8px;
            flex: 1 1 auto;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.02);
            color: var(--text-color);
        }

        .lyrics-search-item {
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
            color: var(--text-color);
        }

        .lyrics-search-item:hover {
            background: rgba(77, 171, 247, 0.12);
            transform: translateY(-1px);
        }

        .lyrics-search-preview {
            width: 100%;
            min-height: 180px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: 10px;
            background: var(--modal-bg);
            white-space: pre-wrap;
            font-family: "Fira Code", monospace;
            overflow-y: auto;
        }

        .lyrics-search-editor {
            width: 100%;
            flex: 1 1 auto;
            min-height: 180px;
            border-radius: 10px;
            border: 1px solid #3c3c3c;
            background: #1e1e1e;
            color: #d4d4d4;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
            overflow: hidden;
        }

        .lyrics-search-editor .monaco-editor {
            width: 100%;
        }

        .lyrics-search-editor textarea {
            font-family: "Fira Code", monospace;
        }

        .lyrics-search-result-header {
            font-weight: 600;
        }

        @media (max-width: 900px) {
            .lyrics-search-grid {
                grid-template-columns: 1fr;
            }
        }

        .modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: var(--button-bg);
            border-radius: 4px;
        }

        .dark-mode .modal-content::-webkit-scrollbar-thumb {
            background: #606060;
        }

        .lyrics-editor {
            width: calc(100% - 24px);
            height: calc(100% - 60px);
            margin-top: 10px;
            font-family: 'Fira Code', monospace;
            resize: none;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            padding: 12px;
            background: var(--input-bg);
            color: var(--text-color);
            position: relative;
            overflow: hidden;
        }

        .editor-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .file-path-input {
            width: calc(100% - 24px);
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: var(--input-bg);
            color: var(--text-color);
            margin: 8px 0;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        .file-path-input:focus {
            border-color: #4dabf7;
            box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.15);
        }

        .editor-buttons button {
            padding: 10px 24px;
            border-radius: 8px;
            border: none;
            background: var(--button-bg);
            color: var(--button-text);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .editor-buttons button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        .editor-buttons button:active {
            transform: translateY(0);
        }

        .modal-content h3 {
            margin: 15px 0 10px;
            color: var(--text-color);
            font-size: 1.1em;
        }

        .create-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }

        .create-card {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 14px;
            background: var(--input-bg);
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }

        .create-card:hover {
            border-color: #4dabf7;
            box-shadow: 0 6px 18px rgba(77, 171, 247, 0.15);
        }

        .create-card.selected {
            border-color: #4dabf7;
            box-shadow: 0 8px 24px rgba(77, 171, 247, 0.22);
        }

        .create-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .create-card .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .create-card .card-title {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            font-size: 1.05rem;
        }

        .create-card .pill {
            padding: 4px 10px;
            border-radius: 999px;
            background: var(--tag-bg);
            font-size: 0.85rem;
            color: var(--text-color);
        }

        .create-card .link-btn {
            border: none;
            background: transparent;
            color: #4dabf7;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 4px 8px;
        }

        .create-card .link-btn:hover {
            text-decoration: underline;
        }

        .amll-row {
            display: flex;
            gap: 12px;
            align-items: stretch;
            flex-wrap: wrap;
        }

        .amll-cover {
            width: 160px;
            height: 160px;
            max-width: 40%;
            background: var(--tag-bg);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            flex: 0 0 auto;
        }

        .amll-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .amll-info {
            flex: 1;
            min-width: 240px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .amll-meta {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.95rem;
            color: var(--text-color);
        }

        .amll-lyrics-preview {
            border: 1px dashed var(--border-color);
            border-radius: 10px;
            padding: 10px;
            background: var(--modal-bg);
            white-space: pre-wrap;
            font-family: 'Fira Code', monospace;
            min-height: 64px;
        }

        .lyrics-translation-wrap {
            display: flex;
            flex-direction: column;
            gap: 24px;
            flex: 1;
            min-height: 0;
            height: 100%;
        }

        .lyrics-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
            min-height: 0;
            height: 100%;
        }

        @media (min-width: 960px) {
            .lyrics-translation-wrap {
                flex-direction: row;
                align-items: flex-start;
            }
            .lyrics-translation-wrap .lyrics-panel {
                flex: 1;
                min-width: 0;
            }
        }

        .lyrics-panel .lyrics-editor {
            flex: 1;
            min-height: 220px;
            height: auto;
        }

        .lyrics-actions-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .lyrics-actions-row .lyrics-action-btn {
            flex: 0 0 auto;
            width: auto;
        }

        .amll-icon-btn {
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            background: transparent;
            border: none;
            cursor: pointer;
        }

        .amll-icon-btn svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .create-hint {
            font-size: 0.88rem;
            color: #666;
        }

        .sort-button {
            background-color: #2196F3;
            color: white;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .sort-button:hover {
            opacity: 0.8;
        }

        .song-tags {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .song-tag {
            font-size: 0.9rem;
            padding: 4px 10px;
            border-radius: 20px;
            background: var(--tag-bg);
        }

        .duet-tag {
            background: #9c36b5;
            color: #fff;
        }

        .background-vocals-tag {
            background: #FF8B36;
            color: #fff;
        }
        .search-options {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            color: var(--text-color);
            flex-wrap: wrap;
        }
        .search-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            user-select: none;
        }

        .no-audio-tag {
            background: #adb5bd;
            color: #1a1a1a;
        }

        .instrumental-tag {
            background: #5c7cfa;
            color: #fff;
        }

        .lyrics-editor {
            height: 176px;
            margin: 10px 0;
        }

        .lyrics-editor.error-highlight {
            border-color: #ff6b6b;
            box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.2);
        }

        .status-message {
            margin-top: 8px;
            padding: 10px 12px;
            border-radius: 8px;
            background: var(--status-bg-default);
            color: var(--status-color-default);
            display: none;
            white-space: pre-wrap;
            line-height: 1.4;
            font-size: 0.95em;
        }

        .status-message.status-error {
            background: var(--status-bg-error);
            color: var(--status-color-error);
        }

        .status-message.status-info {
            background: var(--status-bg-info);
            color: var(--status-color-info);
        }

        .status-message.status-success {
            background: var(--status-bg-success);
            color: var(--status-color-success);
        }

        #lyricsSearchStatus {
            display: block;
            padding: 18px 16px;
            font-size: 1.05em;
            text-align: center;
        }

        #lyricsSearchStatus .btn-shine {
            position: static;
            transform: none;
            display: inline-block;
            padding: 10px 20px;
        }

        .soft-notice {
            position: fixed;
            right: 20px;
            bottom: 24px;
            background: rgba(25, 25, 25, 0.86);
            color: #fff;
            padding: 10px 14px;
            border-radius: 999px;
            font-size: 0.95rem;
            opacity: 0;
            transform: translateY(6px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
            z-index: 9999;
        }

        .soft-notice.is-visible {
            opacity: 1;
            transform: translateY(0);
        }

        #translationStatusMessage {
            position: relative;
        }

        #translationStatusMessage.translation-in-progress {
            background: var(--status-progress-bg);
            color: var(--status-progress-color);
            display: block;
            padding: 24px 20px;
        }

        #translationStatusMessage.translation-in-progress .btn-shine {
            position: relative;
            top: auto;
            left: auto;
            transform: none;
            display: inline-block;
            margin: 0 auto 16px;
        }

        #translationStatusMessage.translation-in-progress .status-progress {
            margin-top: 12px;
        }

        /* From Uiverse.io by neerajbaniwal */
        .btn-shine {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 12px 48px;
            color: #fff;
            background: linear-gradient(to right, #9f9f9f 0, #fff 10%, #868686 20%);
            background-position: -150% 0;
            background-size: 300% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shine 3s infinite linear;
            animation-fill-mode: forwards;
            -webkit-text-size-adjust: none;
            font-weight: 600;
            font-size: 16px;
            text-decoration: none;
            white-space: nowrap;
            font-family: "Poppins", sans-serif;
        }

        @-moz-keyframes shine {
            0% {
                background-position: -150% 0;
            }

            100% {
                background-position: 300% 0;
            }
        }

        @-webkit-keyframes shine {
            0% {
                background-position: -150% 0;
            }

            100% {
                background-position: 300% 0;
            }
        }

        @-o-keyframes shine {
            0% {
                background-position: -150% 0;
            }

            100% {
                background-position: 300% 0;
            }
        }

        @keyframes shine {
            0% {
                background-position: -150% 0;
            }

            100% {
                background-position: 300% 0;
            }
        }

        .status-message__list {
            margin: 6px 0 0;
            padding-left: 18px;
        }

        .status-message__list li {
            margin-bottom: 4px;
            font-family: 'Fira Code', monospace;
        }

        .status-message__summary {
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1.05em;
        }

        .status-progress {
            margin: 0;
            padding: 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        @media (min-width: 769px) {
            .status-progress {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 12px;
            }

            .status-progress__item {
                flex: 1 1 220px;
            }
        }

        .status-progress__item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.04);
        }

        .status-progress__item--pending {
            opacity: 0.6;
        }

        .status-progress__item--active {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.18);
        }

        .status-progress__item--success {
            border-color: rgba(85, 233, 171, 0.6);
            background: rgba(12, 133, 153, 0.18);
        }

        .status-progress__item--error {
            border-color: rgba(255, 107, 107, 0.6);
            background: rgba(255, 107, 107, 0.18);
        }

        .status-progress__label {
            font-weight: 600;
            letter-spacing: 0.4px;
        }

        .status-progress__desc {
            font-size: 0.85em;
            color: var(--status-progress-desc-color);
        }

        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media screen and (max-width: 768px), screen and (orientation: portrait) {
            /* ÁªôÂõ∫ÂÆöÁöÑ .search-container È¢ÑÁïôÁ©∫Èó¥ÔºåÊåâ‰Ω†ÂÆûÈôÖÈ´òÂ∫¶ÂæÆË∞É */
            body {
                padding-top: 80px;   /* ‰Ω†ÂâçÈù¢‰πüÁî®Ëøá 80pxÔºåËøôÈáåÊ≤øÁî®Âç≥ÂèØ„ÄÇ */
                padding-bottom: 60px;
            }

            /* Á°Æ‰øùÂàóË°®ÂèÇ‰∏éÊ≠£Â∏∏ÊªöÂä®Ôºå‰∏ç"Â∏∏È©ª" */
            .json-list {
                position: static !important;  /* Ë¶ÜÁõñÁõ∏ÂØπÂÆö‰Ωç */
                z-index: auto !important;
            }

            .search-container {
                position: static;
                padding: 12px 16px 16px;
                background: var(--card-bg);
                box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
                border-bottom: 1px solid var(--border-color);
                width: 92%;
            }

            .search-wrapper {
                justify-content: flex-start;
            }

            .search-tools {
                flex-direction: column;
                align-items: stretch;
                gap: 16px;
            }

            .search-row {
                width: 100%;
                display: grid;
                gap: 10px;
                flex-wrap: nowrap;
            }

            .search-row--focus {
                grid-template-columns: 1fr;
            }

            .search-row--focus .search-box {
                max-width: none;
            }

            .search-row--sort,
            .search-row--main,
            .search-row--system {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .search-row .action-button,
            .search-row button {
                width: 100%;
                justify-content: center;
            }

            .device-manage-button {
                width: 100%;
            }

            .dropdown-menu {
                position: fixed !important;
                top: auto !important;
                right: 16px !important;
                left: 16px !important;
                bottom: 16px !important;
                min-width: unset !important;
                border-radius: 12px !important;
                padding: 12px !important;
                box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25) !important;
            }

            .json-list {
                margin: 0;
                padding: 16px;
                display: flex;
                gap: 16px;
            }

            .json-item {
                margin: 0;
                min-width: unset;
                width: 100%;
                padding: 18px;
                border-radius: 20px;
            }

            .file-name {
                font-size: 1.2rem;
                line-height: 1.3;
                flex-wrap: wrap;
            }

            .json-item-actions {
                gap: 16px;
            }

            .style-buttons {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 10px;
            }

            .style-button {
                flex: 1 1 calc(50% - 10px);
                justify-content: center;
            }

            .file-actions {
                display: grid;
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 10px;
            }

            .file-actions .action-button {
                width: 100%;
            }

            .modal {
                padding: 0;
            }

            .modal-content {
                margin: 40px auto;
                width: calc(100% - 24px);
                height: calc(100% - 80px);
                border-radius: 14px;
                max-height: 92vh;
            }

            .lyrics-editor {
                height: 220px;
            }

            .modal-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }

            .modal-header-actions,
            .modal-flex-group {
                width: 100%;
            }

            .modal-header-actions button,
            .modal-flex-group button,
            .modal-flex-group .lyrics-action-btn,
            .modal-flex-group label,
            .modal-header-actions .lyrics-action-btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Â¢ûÂº∫ÂØπÊØîÂ∫¶ */
        .style-button:hover {
            opacity: 0.9;
            filter: brightness(1.05);
        }

        .search-box {
            max-width: 300px;
            padding: 11px 14px;
        }

        .lyrics-action-btn {
            padding: 8px 13px;
            border-radius: 6px;
            border: none;
            margin: 5px 0;
            transition: all 0.2s ease;
            /* display: inline-flex; */
            align-items: center;
            /* gap: 8px; */
        }

        .path-update-btn {
            background: #4dabf7;
            color: white;
        }

        .save-btn {
            background: #37b24d;
            color: white;
        }

        .close-btn {
            background: #f03e3e;
            color: white;
        }

        .lyrics-action-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .save-all-btn {
            background: #f59f00;
            color: white;
        }

        .copy-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .copy-btn:hover {
            opacity: 1;
        }
        .search-wrapper {
            display: flex;
            width: 100%;
            justify-content: center;
        }
        .search-tools {
            display: flex;
            width: 100%;
            max-width: 1200px;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .search-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        .search-row--focus .search-box {
            width: 100%;
        }

        @media screen and (min-width: 769px) and (orientation: landscape) {
            .search-tools {
                max-width: 1200px;
                gap: 12px;
                justify-content: center;
                align-items: center;
                flex-wrap: nowrap;
            }
            .search-row {
                flex-wrap: nowrap;
                flex: 0 0 auto;
                min-width: fit-content;
            }
            .search-row--focus {
                min-width: 0;
            }
            .search-row--focus .search-box {
                width: 100%;
                min-width: 0;
            }
        }
        .search-row--focus .search-box {
            width: 100%;
        }
        .device-manage-button {
            position: relative;
            display: inline-flex;
        }
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--modal-bg);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px;
            min-width: 200px;
            z-index: 1000;
        }
        .dropdown-menu button {
            width: 100%;
            text-align: left;
            padding: 8px;
            border: none;
            background: none;
            cursor: pointer;
            color: var(--text-color);
            border-radius: 6px;
        }
        .dropdown-menu button:hover {
            background: var(--tag-bg);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 8px 0;
            gap: 12px;
        }

        .modal-header-actions,
        .modal-flex-group {
            display: flex;
            flex-wrap: wrap;
        }

        .modal-path-group {
            margin-top: 8px;
        }

        .style-button.disabled-style {
            background: #e9ecef !important;
            color: #bbb !important;
            cursor: not-allowed !important;
        }
    </style>
</head>

<body>
    <div class="search-container">
        <div class="search-wrapper">
            <div class="search-tools">
                <div class="search-row search-row--focus">
                    <input type="text" name="fake_username" autocomplete="username"
                           style="position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;">
                    <input type="password" name="fake_password" autocomplete="new-password"
                           style="position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;">
                    <input type="search" class="search-box" id="songSearchInput"
                           name="song_search_input"
                           autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="search"
                           readonly
                           placeholder="ÊêúÁ¥¢Èü≥‰πê...ÔºàÂÖ≥ÈîÆÂ≠óË∂äÂ∞ë ÊêúÂà∞ÁöÑÊ¶ÇÁéáË∂äÂ§ßÔºâ">
                    <div class="search-options">
                        <label class="search-toggle">
                            <input type="checkbox" id="fuzzySearchToggle">
                            <span>Ê®°Á≥äÊêúÁ¥¢</span>
                        </label>
                    </div>
                </div>
                <div class="search-row search-row--sort">
                    <button class="action-button" onclick="toggleSort('name')" id="nameSortBtn">A-Z ÊéíÂ∫è</button>
                    <button class="action-button" onclick="toggleSort('time')" id="timeSortBtn">Êó∂Èó¥ÂÄíÂ∫è</button>
                </div>
                <div class="search-row search-row--main">
                    <button class="action-button" onclick="showCreateModal()">ÂàõÂª∫Êñ∞Ê≠åÊõ≤</button>
                    <button class="action-button" onclick="triggerStaticImport()" title="ÈÄâÊã© static.zip Âø´ÈÄüÂØºÂÖ•">Âø´ÈÄüÂØºÂÖ•</button>
                    <input type="file" id="staticZipInput" accept=".zip" style="display:none" onchange="handleStaticImport(event)">
                    <a class="action-button" href="/lyric-sphere-v2/" target="_blank" rel="noopener">LyricSphere v2</a>
                    <button class="action-button" onclick="toggleDarkMode()" id="themeToggle">üåì ÂàáÊç¢‰∏ªÈ¢ò</button>
                    <button class="action-button" id="portSwitchBtn" onclick="switchPortMode()">ÈöèÊú∫Á´ØÂè£</button>
                </div>
                <div class="search-row search-row--system">
                    <button class="action-button" id="securityToggleBtn" onclick="toggleSecurityMode()" title="ÂÆâÂÖ®‰øùÊä§ÔºöÈªòËÆ§ÂºÄÂêØÔºåÈò≤Ê≠¢Â§ñÈÉ®‰øÆÊîπ">üîí ÂÆâÂÖ®‰øùÊä§</button>
                    <button class="action-button" id="authToggleBtn" onclick="toggleAuthModal()" title="Ëß£ÈîÅÊú¨ËÆæÂ§áÁºñËæëÊùÉÈôê">üîë Ëß£ÈîÅÊú¨ËÆæÂ§á</button>
                    <button class="action-button" onclick="openAMLL()" title="ÊâìÂºÄAMLLÊ≠åËØçÁïåÈù¢">AMLLÊ∫ê</button>
                    <div class="action-button device-manage-button">
                        ‚öôÔ∏è ËÆæÂ§áÁÆ°ÁêÜ
                        <div class="dropdown-menu" style="display: none;">
                            <button onclick="showTrustedDevices()">üìã Êü•ÁúãËÆæÂ§á</button>
                            <button onclick="showSetPasswordModal()">üîê ËÆæÁΩÆÂØÜÁ†Å</button>
                            <button onclick="showRevokeDeviceModal()">üö´ ÂêäÈîÄËÆæÂ§á</button>
                            <button onclick="revokeAllDevices()">üóëÔ∏è Ê∏ÖÁ©∫ËÆæÂ§á</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="jsonListStatus" class="list-status"></div>
    <div id="wifiLoaderWrapper">
        <!-- From Uiverse.io by mobinkakei -->
        <div id="wifi-loader">
            <svg class="circle-outer" viewBox="0 0 86 86">
                <circle class="back" cx="43" cy="43" r="40"></circle>
                <circle class="front" cx="43" cy="43" r="40"></circle>
                <circle class="new" cx="43" cy="43" r="40"></circle>
            </svg>
            <svg class="circle-middle" viewBox="0 0 60 60">
                <circle class="back" cx="30" cy="30" r="27"></circle>
                <circle class="front" cx="30" cy="30" r="27"></circle>
            </svg>
            <svg class="circle-inner" viewBox="0 0 34 34">
                <circle class="back" cx="17" cy="17" r="14"></circle>
                <circle class="front" cx="17" cy="17" r="14"></circle>
            </svg>
            <div class="text" data-text="Loading"></div>
        </div>
    </div>
    <ul class="json-list" id="jsonList"></ul>

    <div id="lyricsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0; font-size: 1.5rem;">ÁºñËæëÊ≠åËØç Ôºö <span id="currentFileName"></span><button class="copy-btn" onclick="copyCurrentFileName()" title="Â§çÂà∂Êñá‰ª∂Âêç">üìã</button></h2>
                <div class="modal-header-actions">
                    <button class="lyrics-action-btn save-all-btn" onclick="saveAllLyrics()">üíæ ‰øùÂ≠òÂÖ®ÈÉ®</button>
                    <button class="lyrics-action-btn close-btn" onclick="closeLyricsModal()">üö™ ÂÖ≥Èó≠</button>
                </div>
            </div>
            <div class="lyrics-translation-wrap">
                <div class="lyrics-panel">
                    <h3>Ê≠åËØç</h3>
                    <div>
                        <label>Ê≠åËØçÊñá‰ª∂Ë∑ØÂæÑÔºö</label>
                        <input type="text" id="lyricsPath" class="file-path-input">
                        <div class="modal-flex-group modal-path-group">
                            <button class="lyrics-action-btn path-update-btn" onclick="updateLyricsPath(0)">üîÑ
                                Êõ¥Êñ∞Ë∑ØÂæÑ</button>
                            <button class="lyrics-action-btn path-update-btn" onclick="convertTTML()">
                                üîÑ TTMLËΩ¨LYS/LRC
                            </button>
                            <button class="lyrics-action-btn path-update-btn" onclick="convertToTTML()">
                                üîÑ LYS/LRCËΩ¨TTML
                            </button>
                            <button class="lyrics-action-btn path-update-btn" id="mergeLQEButton" style="display: none;" onclick="mergeToLQE()">
                                üîÑ ÂêàÂπ∂‰∏∫LQE
                            </button>
                            <button class="lyrics-action-btn path-update-btn" onclick="setCurrentFileNameAsLyrics()">
                                üìù ‰∏∫ÂΩìÂâçÊ≠åËØçÂëΩÂêç
                            </button>
                            <button class="lyrics-action-btn path-update-btn" onclick="extractLyrics()">
                                üìã ÊèêÂèñÊ≠åËØç
                            </button>

                            <label class="lyrics-action-btn path-update-btn" style="cursor:pointer;">
                                üì§ ‰∏ä‰º†Ê≠åËØç
                                <input type="file" id="lyricsUpload" accept=".lrc,.lys,.ttml" style="display:none;"
                                    onchange="handleLyricsUpload()">
                            </label>
                        </div>
                    </div>
                    <div id="lyricsEditor" class="lyrics-editor"></div>
                    <div class="lyrics-actions-row">
                        <button class="lyrics-action-btn path-update-btn" onclick="openQuickEdit()">‚úÇÔ∏è Âø´ÈÄüÁºñËæëÊ≠åËØç</button>
                        <button class="amll-icon-btn" onclick="copyTTMLForAMLL()" title="Â§çÂà∂TTMLÂà∞Ââ™Ë¥¥Êùø">
                            <svg width="75" height="76" viewBox="0 0 75 76" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" overflow="hidden"><g transform="translate(-475 -117)"><path d="M67.0548 83.5726C67.0548 79.9014 67.0548 78.0658 67.9562 77.1493 68.4032 76.6952 68.9781 76.3877 69.6041 76.2678 70.8664 76.026 72.3945 77.0445 75.4507 79.0808L83.8623 84.6863C86.387 86.3685 87.6486 87.2096 87.9644 88.3253 88.1219 88.8829 88.1219 89.4733 87.9644 90.0308 87.6486 91.1466 86.387 91.9877 83.8623 93.6699L75.4507 99.2753C72.3945 101.312 70.8664 102.33 69.6041 102.088 68.9781 101.968 68.4032 101.661 67.9562 101.206 67.0548 100.29 67.0548 98.4555 67.0548 94.7836L67.0548 83.5726Z" fill="#FFFFFF" fill-rule="evenodd" transform="matrix(1 0 0 1.01333 416.233 69.1096)"/><path d="M67.0548 65C67.0548 63.449 68.3121 62.1918 69.863 62.1918L108.493 62.1918C110.044 62.1918 111.301 63.449 111.301 65L111.301 65C111.301 66.551 110.044 67.8083 108.493 67.8083L69.863 67.8082C68.3121 67.8082 67.0548 66.5509 67.0548 65Z" fill="#4FEBB0" fill-rule="evenodd" transform="matrix(1 0 0 1.01333 416.233 69.1096)"/><path d="M92.6712 78.1849C92.6712 76.6151 93.9438 75.3425 95.5137 75.3425L125.445 75.3425C127.015 75.3425 128.288 76.6151 128.288 78.1849L128.288 78.1849C128.288 79.7548 127.015 81.0274 125.445 81.0274L95.5137 81.0274C93.9438 81.0274 92.6712 79.7548 92.6712 78.1849Z" fill="#4FEBB0" fill-rule="evenodd" transform="matrix(1 0 0 1.01333 416.233 69.1096)"/><path d="M96.3699 91.3699C96.3699 89.8192 97.6274 88.5616 99.1781 88.5616L116.301 88.5616C117.852 88.5616 119.11 89.8192 119.11 91.3699L119.11 91.3699C119.11 92.9205 117.852 94.1781 116.301 94.1781L99.1781 94.1781C97.6274 94.1781 96.3699 92.9205 96.3699 91.3699Z" fill="#4FEBB0" fill-rule="evenodd" transform="matrix(1 0 0 1.01333 416.233 69.1096)"/><path d="M84.7945 104.555C84.7945 102.985 86.0671 101.712 87.637 101.712L122.637 101.712C124.207 101.712 125.479 102.985 125.479 104.555L125.479 104.555C125.479 106.125 124.207 107.397 122.637 107.397L87.637 107.397C86.0671 107.397 84.7945 106.125 84.7945 104.555Z" fill="#4FEBB0" fill-rule="evenodd" transform="matrix(1 0 0 1.01333 416.233 69.1096)"/><path d="M126.575 91.3699C126.575 89.8192 127.833 88.5616 129.384 88.5616L129.658 88.5616C131.208 88.5616 132.466 89.8192 132.466 91.3699L132.466 91.3699C132.466 92.9205 131.208 94.1781 129.658 94.1781L129.384 94.1781C127.833 94.1781 126.575 92.9205 126.575 91.3699Z" fill="#FFFFFF" fill-rule="evenodd" transform="matrix(1 0 0 1.01333 416.233 69.1096)"/></g></svg>
                        </button>
                        <button class="lyrics-action-btn path-update-btn" onclick="openLyricsSearchModal()">üîç ÊêúÁ¥¢Ê≠åËØç</button>
                        <button class="lyrics-action-btn save-btn" onclick="saveLyrics(0)">üíæ ‰øùÂ≠òÊ≠åËØç</button>
                    </div>
                </div>

                <div class="lyrics-panel">
                    <h3>ÁøªËØë</h3>
                    <div>
                        <label>ÁøªËØëÊñá‰ª∂Ë∑ØÂæÑÔºö</label>
                        <input type="text" id="translationPath" class="file-path-input">
                        <div class="modal-flex-group modal-path-group">
                            <button class="lyrics-action-btn path-update-btn" onclick="updateLyricsPath(1)">üîÑ
                                Êõ¥Êñ∞Ë∑ØÂæÑ</button>
                            <button class="lyrics-action-btn path-update-btn" onclick="setCurrentFileNameAsTranslation()">
                                üìù ‰∏∫ÂΩìÂâçÁøªËØëÂëΩÂêç
                            </button>
                            <button class="lyrics-action-btn path-update-btn" onclick="extractTimestamps()">
                                ‚è±Ô∏è Ê∑ªÂä†Êó∂Èó¥Êà≥
                            </button>
                            <!-- <button class="lyrics-action-btn path-update-btn" onclick="window.open('https://famyliam.ft2.ltd/translate_lyrics', '_blank')">
                                ü§ñ AIÁøªËØë
                            </button> -->
                            <button class="lyrics-action-btn path-update-btn" onclick="translateLyrics()">
                                ü§ñ AIÁøªËØë
                            </button>
                            <button class="lyrics-action-btn path-update-btn" onclick="copyTranslationPrompt()">
                                üìã Â§çÂà∂ÊèêÁ§∫ËØç
                            </button>
                            <button class="lyrics-action-btn path-update-btn" onclick="showAISettings()">
                                ‚öôÔ∏è AIËÆæÁΩÆ
                            </button>
                            <label class="lyrics-action-btn path-update-btn" style="cursor:pointer;">
                                üì§ ‰∏ä‰º†ÁøªËØë
                                <input type="file" id="translationUpload" accept=".lrc,.lys,.ttml" style="display:none;"
                                    onchange="handleTranslationUpload()">
                            </label>
                        </div>
                        <div id="translationStatusMessage" class="status-message">
                            <!-- From Uiverse.io by neerajbaniwal -->
                            <a href="#" class="btn-shine">Ê≠£Âú®ÁøªËØë ¬∑ ËØ∑Ê±ÇÊÄùËÄÉÈò∂ÊÆµ</a>
                        </div>
                    </div>
                    <div id="translationEditor" class="lyrics-editor"></div>
                    <div class="lyrics-actions-row">
                        <button class="lyrics-action-btn save-btn" onclick="saveLyrics(1)">üíæ ‰øùÂ≠òÁøªËØë</button>
                    </div>
                </div>

                <div class="editor-buttons">
                </div>
            </div>
        </div>
    </div>

    <div id="lyricsSearchModal" class="modal">
        <div class="modal-content" style="width: 92%; height: 86%;">
            <h2>ÊêúÁ¥¢Ê≠åËØç</h2>
            <div class="lyrics-search-grid">
                <div class="lyrics-search-panel">
                    <div>ÂΩìÂâçÊñá‰ª∂ÂêçÔºö<span id="lyricsSearchFileName">Êú™ÈÄâÊã©</span></div>
                    <div>
                        <label>ÂÖ≥ÈîÆËØçÔºö</label>
                        <input type="text" id="lyricsSearchKeyword" class="file-path-input" placeholder="Ê≠åÊõ≤Âêç Ê≠åÊâãÂêç">
                    </div>
                    <div>
                        <label>Ê≠åÊõ≤ÂêçÔºö</label>
                        <input type="text" id="lyricsSearchTitle" class="file-path-input" placeholder="ÂèØÊâãÂä®Â°´ÂÜô">
                    </div>
                    <div>
                        <label>Ëâ∫ÊúØÂÆ∂ÂêçÔºö</label>
                        <input type="text" id="lyricsSearchArtist" class="file-path-input" placeholder="ÂèØÊâãÂä®Â°´ÂÜô">
                    </div>
                    <div>
                        <label>Ê≠åÊõ≤ÂêçÊ≠£ÂàôÔºàÂåπÈÖçÊñá‰ª∂ÂêçÔºâÔºö</label>
                        <input type="text" id="lyricsSearchTitleRegex" class="file-path-input" placeholder="‰æãÂ¶Ç: ^(.+?) - ">
                    </div>
                    <div>
                        <label>Ëâ∫ÊúØÂÆ∂ÂêçÊ≠£ÂàôÔºàÂåπÈÖçÊñá‰ª∂ÂêçÔºâÔºö</label>
                        <input type="text" id="lyricsSearchArtistRegex" class="file-path-input" placeholder="‰æãÂ¶Ç: - (.+)$">
                    </div>
                    <div class="editor-buttons">
                        <button onclick="applySearchNameFromFile()">‰ªéÊñá‰ª∂ÂêçËß£Êûê</button>
                        <button onclick="performLyricsMatchFromInputs()">Ëá™Âä®ÂåπÈÖç</button>
                        <button onclick="performLyricsSearch()">ÊêúÁ¥¢ÂàóË°®</button>
                        <button onclick="clearLyricsSearchInputs()">Ê∏ÖÁ©∫</button>
                    </div>
                    <div id="lyricsSearchStatus" class="status-message status-info" style="display: block;">ÂèØÊ†πÊçÆÊñá‰ª∂ÂêçËá™Âä®ÂåπÈÖçÔºå‰πüÂèØÊâãÂä®ÊêúÁ¥¢„ÄÇ</div>
                </div>
                <div class="lyrics-search-panel">
                    <div class="lyrics-search-result-header">ÊêúÁ¥¢ÁªìÊûú</div>
                    <div id="lyricsSearchResults" class="lyrics-search-results"></div>
                </div>
                <div class="lyrics-search-panel">
                    <div class="lyrics-search-result-header">Ê≠åËØçÂÜÖÂÆπÔºàLYSÔºåÂèØÁºñËæëÔºâ</div>
                    <div id="lyricsSearchLyricsEditor" class="lyrics-search-editor"></div>
                    <div class="lyrics-search-result-header">ÁøªËØëÂÜÖÂÆπÔºàLRCÔºåÂèØÁºñËæëÔºâ</div>
                    <div id="lyricsSearchTranslationEditor" class="lyrics-search-editor"></div>
                    <div class="editor-buttons">
                        <button onclick="applyLyricsSearchResult()">Â∫îÁî®Âà∞ÁºñËæëÂô®</button>
                        <button onclick="closeLyricsSearchModal()">ÂÖ≥Èó≠</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="musicPathModal" class="modal">
        <div class="modal-content">
            <h2>‰øÆÊîπÈü≥‰πêÊñá‰ª∂Ë∑ØÂæÑ</h2>
            <div>
                <label>ÂΩìÂâçË∑ØÂæÑÔºö</label>
                <input type="text" id="musicPath" class="file-path-input" readonly>
                <label>Êñ∞Ë∑ØÂæÑÔºö</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="text" id="newMusicPath" class="file-path-input" style="flex:1">
                    <label class="lyrics-action-btn path-update-btn" style="margin:0; cursor:pointer;">
                        üì§ ‰∏ä‰º†Êñá‰ª∂
                        <input type="file" id="musicUpload" accept="audio/*,video/*" style="display:none;"
                            onchange="handleMusicUpload()">
                    </label>
                </div>
                <small style="display: block; margin-top: 5px; color: #666;">
                    ÊèêÁ§∫ÔºöÂèØÁõ¥Êé•ËæìÂÖ•Êñá‰ª∂ÂêçÊàñ‰∏ä‰º†Èü≥È¢ëËßÜÈ¢ëÊñá‰ª∂ÔºàÊîØÊåÅÊâÄÊúâÊ†ºÂºèÔºâ
                </small>
            </div>
            <div class="editor-buttons">
                <button onclick="updateMusicPath()">‰øùÂ≠ò</button>
                <button onclick="closeMusicPathModal()">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <div id="imagePathModal" class="modal">
        <div class="modal-content">
            <h2>‰øÆÊîπÂõæÁâáË∑ØÂæÑ</h2>
            <div>
                <h3>‰∏ìËæëÂ∞ÅÈù¢</h3>
                <label>ÂΩìÂâçË∑ØÂæÑÔºö</label>
                <input type="text" id="imagePath" class="file-path-input" readonly>
                <label>Êñ∞Ë∑ØÂæÑÔºö</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="newImagePath" class="file-path-input" style="flex:1">
                    <label class="lyrics-action-btn path-update-btn" style="margin:0; cursor:pointer;">
                        üì§ ‰∏ä‰º†‰∏ìËæëÂõæ
                        <input type="file" id="imageUpload" accept="image/*" style="display: none;"
                            onchange="handleImageUpload(this.files[0], 'album')">
                    </label>
                </div>
                <small style="display: block; margin-top: 5px; color: #666;">
                    ÊèêÁ§∫ÔºöÊîØÊåÅ JPG/PNG/GIF/WEBP Ê†ºÂºèÔºåÂèØÁõ¥Êé•‰∏ä‰º†ÊàñËæìÂÖ•Êñá‰ª∂Âêç
                </small>
            </div>
            
            <div>
                <h3>ËÉåÊôØÂõæÁâá/ËßÜÈ¢ë</h3>
                <label>ÂΩìÂâçË∑ØÂæÑÔºö</label>
                <input type="text" id="backgroundPath" class="file-path-input" readonly>
                <label>Êñ∞Ë∑ØÂæÑÔºö</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="newBackgroundPath" class="file-path-input" style="flex:1">
                    <label class="lyrics-action-btn path-update-btn" style="margin:0; cursor:pointer;">
                        üì§ ‰∏ä‰º†ËÉåÊôØÂõæ/ËßÜÈ¢ë
                        <input type="file" id="backgroundUpload" accept="image/*,video/*" style="display: none;"
                            onchange="handleImageUpload(this.files[0], 'background')">
                    </label>
                </div>
                <small style="display: block; margin-top: 5px; color: #666;">
                    ÊèêÁ§∫ÔºöÊîØÊåÅ JPG/PNG/GIF/WEBP/MP4/WEBM/OGG/M4V/MOVÔºåÂèØÁõ¥Êé•‰∏ä‰º†ÊàñËæìÂÖ•Êñá‰ª∂Âêç
                </small>
            </div>
            
            <div class="editor-buttons">
                <button onclick="saveAllImagePaths()">‰øùÂ≠òÂÖ®ÈÉ®</button>
                <button onclick="updateImagePath()">‰øùÂ≠ò‰∏ìËæëÂõæ</button>
                <button onclick="updateBackgroundPath()">‰øùÂ≠òËÉåÊôØÂõæ</button>
                <button onclick="closeImagePathModal()">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <div id="createJsonModal" class="modal">
        <div class="modal-content">
            <h2>ÂàõÂª∫Êñ∞Ê≠åÊõ≤</h2>
            <div class="create-grid">
                <div class="create-card" id="amllSourceCard" onclick="selectCreateMode('amll')">
                    <div class="card-header">
                        <div class="card-title">AMLLÊ∫ê</div>
                        <div class="pill" id="amllCardStatus">Êú™ËøûÊé•</div>
                        <button class="link-btn" onclick="event.stopPropagation(); refreshAmllSnapshot(true);">Âà∑Êñ∞</button>
                    </div>
                    <div class="amll-row">
                        <div class="amll-cover">
                            <img id="amllCoverPreview" alt="AMLL cover" src="{{ url_for('static', filename='icons/icon-512x512.png') }}">
                        </div>
                        <div class="amll-info">
                            <div class="amll-meta">
                                <div id="amllSongTitleDisplay">Ê≠åÊõ≤ÂêçÔºö--</div>
                                <div id="amllSongArtistsDisplay">Ê≠åÊâãÔºö--</div>
                                <div id="amllSongAlbumDisplay">‰∏ìËæëÔºö--</div>
                                <div id="amllLyricsSummary">Ê≠åËØçÔºö--</div>
                            </div>
                            <div class="amll-lyrics-preview" id="amllLyricsPreview">Á≠âÂæÖ AMLL Êï∞ÊçÆ...</div>
                            <div class="create-hint">ÈÄâ‰∏≠Ê≠§Âç°ÁâáÂπ∂ÁÇπÂáªÂàõÂª∫ÔºåÂ∞ÜÁõ¥Êé•‰ΩøÁî® AMLL Ê∫êÁöÑÊ≠åÊõ≤Âêç„ÄÅÊ≠åÊâã„ÄÅÂ∞ÅÈù¢ÂíåÊ≠åËØçÁîüÊàêÊñ∞Êù°ÁõÆ„ÄÇ</div>
                        </div>
                    </div>
                </div>

                <div class="create-card selected" id="manualCreateCard" onclick="selectCreateMode('manual')">
                    <div class="card-header">
                        <div class="card-title">ÊâãÂä®ËæìÂÖ•</div>
                        <div class="pill">Ëá™ÂÆö‰πâ</div>
                    </div>
                    <div>
                        <label>Ê≠åÊõ≤ÂêçÔºö</label>
                        <input type="text" id="songTitle" class="file-path-input" onfocus="selectCreateMode('manual')">
                    </div>
                    <div>
                        <label>Ê≠åÊâãÂêçÔºàÂ§ö‰∏™Ê≠åÊâãÁî®ÈÄóÂè∑ÂàÜÈöîÔºâÔºö</label>
                        <input type="text" id="songArtists" class="file-path-input" placeholder="Ê≠åÊâã1,Ê≠åÊâã2" onfocus="selectCreateMode('manual')">
                    </div>
                    <div class="create-hint">‰∏ç‰ΩøÁî® AMLL Ê∫êÊó∂ÔºåÊâãÂä®Â°´ÂÜô‰ø°ÊÅØÂêéÂàõÂª∫„ÄÇ</div>
                </div>

                <div class="create-card" id="audioImportCard" onclick="selectCreateMode('audio')">
                    <div class="card-header">
                        <div class="card-title">ÂØºÂÖ•Èü≥È¢ë</div>
                        <div class="pill">ÊâπÈáè</div>
                    </div>
                    <div>
                        <label class="lyrics-action-btn path-update-btn" style="cursor:pointer; display:inline-block;">
                            üì§ ÈÄâÊã©Èü≥È¢ëÊñá‰ª∂
                            <input type="file" id="audioImportInput" accept="audio/*,video/*" multiple style="display:none;"
                                onchange="handleCreateAudioImport(this.files)">
                        </label>
                    </div>
                    <div id="createAudioStatus" class="lyrics-search-status">ÊîØÊåÅÂçï‰∏™/Â§ö‰∏™Èü≥È¢ëÊñá‰ª∂ÔºåJSON ÂêçÁß∞‰ºö‰ΩøÁî®Èü≥È¢ëÊñá‰ª∂Âêç„ÄÇ</div>
                </div>
            </div>

            <div class="editor-buttons">
                <button id="createJsonConfirm" onclick="createJsonFile()">ÂàõÂª∫</button>
                <button onclick="closeCreateModal()">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <div id="renameModal" class="modal">
        <div class="modal-content">
            <h2>ÈáçÂëΩÂêçÊ≠åÊõ≤</h2>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div>
                    <label>Ê≠åÊõ≤ÂêçÔºö</label>
                    <input type="text" id="renameSongTitle" class="file-path-input">
                </div>
                <div>
                    <label>Ê≠åÊâãÂêçÔºàÂ§ö‰∏™Ê≠åÊâãÁî®ÈÄóÂè∑ÂàÜÈöîÔºâÔºö</label>
                    <input type="text" id="renameSongArtists" class="file-path-input" placeholder="Ê≠åÊâã1,Ê≠åÊâã2">
                </div>
                <div class="editor-buttons">
                    <button onclick="renameJsonFile()">‰øùÂ≠ò</button>
                    <button onclick="closeRenameModal()">ÂèñÊ∂à</button>
                </div>
            </div>
        </div>
    </div>

    <div id="backupModal" class="modal">
        <div class="modal-content">
            <h2>ÈÄâÊã©ÊÅ¢Â§çÁâàÊú¨</h2>
            <div id="backupList" style="max-height: 60vh; overflow-y: auto; margin: 15px 0;"></div>
            <div class="editor-buttons">
                <button onclick="closeBackupModal()">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <!-- Ê∑ªÂä†ËÆ§ËØÅÂØπËØùÊ°Ü -->
    <div id="authModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <h2>üîë ËÆæÂ§áËÆ§ËØÅ</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div id="authStatus" class="auth-status">
                    Ê≠£Âú®Ê£ÄÊü•ËÆæÂ§áÁä∂ÊÄÅ...
                </div>
                <div id="authForm" style="display: none;">
                    <div>
                        <label>ÂØÜÁ†ÅÔºö</label>
                        <input type="password" id="authPassword" class="file-path-input" placeholder="ËØ∑ËæìÂÖ•ËÆøÈóÆÂØÜÁ†Å">
                    </div>
                    <div class="editor-buttons">
                        <button onclick="authLogin()">ÁôªÂΩï</button>
                        <button onclick="authLogout()" id="authLogoutBtn" style="display: none;">ÁôªÂá∫</button>
                        <button onclick="closeAuthModal()">ÂèñÊ∂à</button>
                    </div>
                </div>
                <div id="authSuccess" style="display: none; text-align: center; color: #37b24d;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">‚úÖ</div>
                    <div>ËÆæÂ§áÂ∑≤ÊàêÂäüËÆ§ËØÅÔºÅ</div>
                    <div style="font-size: 0.9em; color: #666; margin-top: 10px;">ÊÇ®Áé∞Âú®ÂèØ‰ª•ÁºñËæëÂÜÖÂÆπ‰∫Ü</div>
                    <button onclick="closeAuthModal()" style="margin-top: 15px;">ÂÖ≥Èó≠</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Ê∑ªÂä†ÂØÜÁ†ÅËÆæÁΩÆÂØπËØùÊ°Ü -->
    <div id="setPasswordModal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <h2>üîê ËÆæÁΩÆÁ≥ªÁªüÂØÜÁ†Å</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div id="setPasswordStatus" style="padding: 10px; border-radius: 8px; background: #f8f9fa; text-align: center; display: none;">
                    <!-- Áä∂ÊÄÅ‰ø°ÊÅØÂ∞ÜÂä®ÊÄÅÊòæÁ§∫ -->
                </div>
                <div>
                    <label>ÂΩìÂâçÂØÜÁ†ÅÔºàÂ¶ÇÂ∑≤ËÆæÁΩÆÔºâÔºö</label>
                    <input type="password" id="currentPassword" class="file-path-input" placeholder="Â¶ÇÂ∑≤ËÆæÁΩÆÂØÜÁ†ÅÔºåËØ∑ËæìÂÖ•ÂΩìÂâçÂØÜÁ†Å">
                </div>
                <div>
                    <label>Êñ∞ÂØÜÁ†ÅÔºö</label>
                    <input type="password" id="newPassword" class="file-path-input" placeholder="ËØ∑ËæìÂÖ•Êñ∞ÂØÜÁ†ÅÔºàÊúÄÂ∞ë8‰ΩçÔºâ">
                </div>
                <div>
                    <label>Á°ÆËÆ§Êñ∞ÂØÜÁ†ÅÔºö</label>
                    <input type="password" id="confirmPassword" class="file-path-input" placeholder="ËØ∑ÂÜçÊ¨°ËæìÂÖ•Êñ∞ÂØÜÁ†Å">
                </div>
                <div style="font-size: 12px; color: #666;">
                    üí° ÂØÜÁ†ÅË¶ÅÊ±ÇÔºöÊúÄÂ∞ë8‰∏™Â≠óÁ¨¶ÔºåÂª∫ËÆÆÂåÖÂê´Â≠óÊØç„ÄÅÊï∞Â≠óÂíåÁâπÊÆäÂ≠óÁ¨¶
                </div>
                <div class="editor-buttons">
                    <button onclick="setPassword()">‰øùÂ≠òÂØÜÁ†Å</button>
                    <button onclick="closeSetPasswordModal()">ÂèñÊ∂à</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Ê∑ªÂä†ËÆæÂ§áÂêäÈîÄÂØπËØùÊ°Ü -->
    <div id="revokeDeviceModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>üö´ ÂêäÈîÄËÆæÂ§á</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div id="revokeDeviceStatus" style="padding: 10px; border-radius: 8px; background: #f8f9fa; text-align: center;">
                    Ê≠£Âú®Âä†ËΩΩËÆæÂ§áÂàóË°®...
                </div>
                <div id="revokeDeviceList" style="max-height: 300px; overflow-y: auto; display: none;">
                    <!-- ËÆæÂ§áÂàóË°®Â∞ÜÂä®ÊÄÅÂä†ËΩΩ -->
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="deviceSearch" class="file-path-input" placeholder="ÊêúÁ¥¢ËÆæÂ§áID..." style="flex: 1;">
                    <button onclick="searchDevices()">ÊêúÁ¥¢</button>
                </div>
                <div class="editor-buttons">
                    <button onclick="closeRevokeDeviceModal()">ÂÖ≥Èó≠</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Ê∑ªÂä†AIËÆæÁΩÆÂØπËØùÊ°Ü -->
    <div id="aiSettingsModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>AIÁøªËØëËÆæÁΩÆ</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <label>APIÊèê‰æõÂïÜÔºö</label>
                    <select id="aiProvider" class="file-path-input">
                        <option value="deepseek">DeepSeek</option>
                        <option value="openai">OpenAI</option>
                        <option value="openrouter">OpenRouter</option>
                        <option value="together">Together</option>
                        <option value="groq">Groq</option>
                        <option value="custom">Ëá™ÂÆö‰πâ</option>
                    </select>
                </div>
                <div>
                    <label>Âü∫Á°ÄURLÔºö</label>
                    <input type="text" id="aiBaseUrl" class="file-path-input" placeholder="‰æãÂ¶Ç: https://api.deepseek.com">
                </div>
                <div>
                    <label>Ê®°ÂûãÂêçÁß∞Ôºö</label>
                    <input type="text" id="aiModel" class="file-path-input" placeholder="‰æãÂ¶Ç: deepseek-reasoner">
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="aiExpectReasoning"> ÊúüÊúõÊÄùÁª¥ÈìæÂÜÖÂÆπÔºà‰ªÖÈÉ®ÂàÜÊ®°ÂûãÊîØÊåÅÔºâ
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="aiCompatMode"> ÂÖºÂÆπÊ®°ÂºèÔºöÂ∞ÜÊèêÁ§∫ËØçÂêàÂπ∂Âà∞Áî®Êà∑Ê∂àÊÅØ‰∏≠
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="aiStripBrackets"> È¢ÑÂ§ÑÁêÜÊ≠åËØçÊó∂ÂéªÊéâÊã¨Âè∑
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="aiThinkingEnabled" checked> ÂêØÁî®ÊÄùËÄÉÊ®°ÂºèÔºàÂÖàÁîüÊàêÊï¥È¶ñÊ≠åÁêÜËß£Ôºâ
                    </label>
                </div>
                <div>
                    <label>APIÂØÜÈí•Ôºö</label>
                    <input type="password" id="aiApiKey" class="file-path-input" placeholder="ËØ∑ËæìÂÖ•APIÂØÜÈí•">
                    <div style="margin-top: 5px; font-size: 12px; color: #666;">
                        <a href="https://platform.deepseek.com/usage" target="_blank" style="color: #0066cc; text-decoration: none;">ÁÇπÂáªËøôÈáåËé∑Âèñ DeepSeek API ÂØÜÈí• ‚Üí</a>
                    </div>
                </div>
                <div>
                    <label>ÁøªËØëÊèêÁ§∫ËØçÔºö</label>
                    <textarea id="aiSystemPrompt" class="lyrics-editor" style="height: 150px;" placeholder="ËÆæÁΩÆAIÁøªËØëÁöÑÊèêÁ§∫ËØçÔºåÁî®‰∫éÊåáÂØºAIÂ¶Ç‰ΩïÁøªËØëÊ≠åËØç"></textarea>
                </div>
                <div style="border-top: 1px solid var(--border-color); padding-top: 12px;">
                    <h3 style="margin: 0 0 8px 0;">ÊÄùËÄÉÊ®°ÂûãËÆæÁΩÆ</h3>
                    <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                        ÂèØÈÄâÔºöÂÖàË∞ÉÁî®ÊÄùËÄÉÊ®°ÂûãÁîüÊàêÊï¥È¶ñÊ≠åÁêÜËß£ÔºåÂÜçÂ∞ÜÁªìÊûú‰º†ÁªôÁøªËØëÊ®°Âûã„ÄÇÁïôÁ©∫ÁöÑÂ≠óÊÆµÂ∞ÜÊ≤øÁî®ÁøªËØëËÆæÁΩÆ„ÄÇ
                    </div>
                    <div>
                        <label>ÊÄùËÄÉÊ®°ÂûãÊèê‰æõÂïÜÔºö</label>
                        <select id="aiThinkingProvider" class="file-path-input">
                            <option value="deepseek">DeepSeek</option>
                            <option value="openai">OpenAI</option>
                            <option value="openrouter">OpenRouter</option>
                            <option value="together">Together</option>
                            <option value="groq">Groq</option>
                            <option value="custom">Ëá™ÂÆö‰πâ</option>
                        </select>
                    </div>
                    <div>
                        <label>ÊÄùËÄÉÊ®°ÂûãÂü∫Á°ÄURLÔºö</label>
                        <input type="text" id="aiThinkingBaseUrl" class="file-path-input" placeholder="ÈªòËÆ§Ê≤øÁî®ÁøªËØëÊ®°ÂûãÁöÑÂü∫Á°ÄURL">
                    </div>
                    <div>
                        <label>ÊÄùËÄÉÊ®°ÂûãÂêçÁß∞Ôºö</label>
                        <input type="text" id="aiThinkingModel" class="file-path-input" placeholder="ÈªòËÆ§Ê≤øÁî®ÁøªËØëÊ®°ÂûãÂêçÁß∞">
                    </div>
                    <div>
                        <label>ÊÄùËÄÉÊ®°ÂûãAPIÂØÜÈí•ÔºàÂèØÈÄâÔºâÔºö</label>
                        <input type="password" id="aiThinkingApiKey" class="file-path-input" placeholder="ÁïôÁ©∫ÂàôÊ≤øÁî®ÁøªËØëAPIÂØÜÈí•">
                    </div>
                    <div>
                        <label>ÊÄùËÄÉÊèêÁ§∫ËØçÔºö</label>
                        <textarea id="aiThinkingPrompt" class="lyrics-editor" style="height: 120px;" placeholder="ËÆæÁΩÆÊÄùËÄÉÊ®°ÂûãÁöÑÊèêÁ§∫ËØçÔºåÁî®‰∫éÁîüÊàêÊï¥È¶ñÊ≠åÁöÑÁêÜËß£"></textarea>
                    </div>
                </div>
                <div class="editor-buttons">
                    <button onclick="probeAIConnection('translation', this)" data-probe="translation">ÊµãËØïÁøªËØëÊ®°Âûã</button>
                    <button onclick="probeAIConnection('thinking', this)" data-probe="thinking">ÊµãËØïÊÄùËÄÉÊ®°Âûã</button>
                    <button onclick="saveAISettings()">‰øùÂ≠òËÆæÁΩÆ</button>
                    <button onclick="closeAISettings()">ÂèñÊ∂à</button>
                </div>
            </div>
        </div>
    </div>

    <script id="amllPlayerConfig" type="application/json">{{ amll_player_base_url|tojson }}</script>
    <script>
        const backendOrigin = window.location.origin;
        const backendRootUrl = new URL('/', backendOrigin).toString();
        const amllPlayerConfigElement = document.getElementById('amllPlayerConfig');
        let amllPlayerBaseUrl = null;
        if (amllPlayerConfigElement && amllPlayerConfigElement.textContent) {
            try {
                amllPlayerBaseUrl = JSON.parse(amllPlayerConfigElement.textContent);
            } catch (error) {
                console.warn('Failed to parse AMLL player base URL from config, fallback to local path.', error);
            }
        }
        amllPlayerBaseUrl = amllPlayerBaseUrl || new URL('/amll-web', backendOrigin).toString();
        const AMLL_SETTINGS_STORAGE_KEY = 'amll_background_settings';
        const STYLE_PARAM_EXCLUDE = new Set([
            'musicUrl',
            'lyricUrl',
            'coverUrl',
            'songTitle',
            'songArtist',
            'musicUrlInput',
            'lyricUrlInput',
            'coverUrlInput',
            'songTitleInput',
            'songArtistInput'
        ]);
        const STYLE_PARAM_ALIAS = {
            lyricDelay: 'ms',
            playbackRate: 'x',
            volume: 'vol',
            loopPlay: 'loop',
            autoPlay: 'auto',
            rangeStartTime: 't',
            rangeEndTime: 'te'
        };

        function readCachedAmllSettings() {
            try {
                const raw = window.localStorage.getItem(AMLL_SETTINGS_STORAGE_KEY);
                if (!raw) {
                    return null;
                }
                const parsed = JSON.parse(raw);
                return (parsed && typeof parsed === 'object') ? parsed : null;
            } catch (error) {
                console.warn('Failed to parse AMLL cached settings:', error);
                return null;
            }
        }

        function buildStyleQueryFromSettings(settings) {
            if (!settings || typeof settings !== 'object') {
                return '';
            }
            const queryParts = [];
            for (const [key, value] of Object.entries(settings)) {
                if (STYLE_PARAM_EXCLUDE.has(key)) {
                    continue;
                }
                if (value === undefined || value === null) {
                    continue;
                }
                if (typeof value === 'string' && value === '') {
                    continue;
                }
                const alias = STYLE_PARAM_ALIAS[key] || key;
                let serialized;
                if (typeof value === 'boolean') {
                    serialized = value ? '1' : '0';
                } else {
                    serialized = String(value);
                }
                queryParts.push(`${encodeURIComponent(alias)}=${encodeURIComponent(serialized)}`);
            }
            return queryParts.length ? `&${queryParts.join('&')}` : '';
        }

        function buildStyleQueryFromCache() {
            const settings = readCachedAmllSettings();
            return buildStyleQueryFromSettings(settings);
        }

        function safeDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value);
            } catch (error) {
                return value;
            }
        }

        function createResourceConfig(segment) {
            const baseUrl = new URL(`${segment}/`, backendRootUrl).toString();
            const path = new URL(`${segment}/`, backendRootUrl).pathname;
            return { base: baseUrl, path, name: segment };
        }

        const RESOURCE_CONFIG = {
            songs: createResourceConfig('songs'),
            static: createResourceConfig('static'),
            backups: createResourceConfig('backups')
        };

        const DEFAULT_AMLL_COVER = "{{ url_for('static', filename='icons/icon-512x512.png') }}";
        let createMode = 'manual';
        let amllSnapshot = null;

        function normalizeResourceUrl(value, resourceKey) {
            if (!value || typeof value !== 'string') {
                return value;
            }
            if (value === '!') {
                return value;
            }
            const config = RESOURCE_CONFIG[resourceKey];
            if (!config) {
                return value;
            }

            try {
                const parsed = new URL(value);
                if (parsed.pathname.startsWith(config.path)) {
                    const decodedPath = safeDecodeURIComponent(parsed.pathname);
                    const normalizedPath = decodedPath.startsWith(config.path)
                        ? decodedPath
                        : config.path + decodedPath.replace(/^\//, '');
                    const search = parsed.search ? safeDecodeURIComponent(parsed.search) : '';
                    const hash = parsed.hash ? safeDecodeURIComponent(parsed.hash) : '';
                    return `${window.location.protocol}//${window.location.host}${normalizedPath}${search}${hash}`;
                }
                return value;
            } catch (error) {
                let normalized = value.replace(/\\/g, '/').replace(/^[./]+/, '');
                if (normalized.startsWith(`${config.name}/`)) {
                    normalized = normalized.substring(config.name.length + 1);
                }
                normalized = safeDecodeURIComponent(normalized);
                if (!normalized) {
                    return config.base;
                }
                return config.base + normalized;
            }
        }

        function stripResourcePrefix(value, resourceKey) {
            if (!value || typeof value !== 'string') {
                return value || '';
            }
            if (value === '!') {
                return value;
            }
            const config = RESOURCE_CONFIG[resourceKey];
            if (!config) {
                return value;
            }

            try {
                const parsed = new URL(value);
                if (parsed.pathname.startsWith(config.path)) {
                    return safeDecodeURIComponent(parsed.pathname.substring(config.path.length));
                }
            } catch (error) {
                const normalizedValue = value.replace(/\\/g, '/');
                if (normalizedValue.startsWith(config.base)) {
                    return safeDecodeURIComponent(normalizedValue.substring(config.base.length));
                }
                if (normalizedValue.startsWith(config.path)) {
                    return safeDecodeURIComponent(normalizedValue.substring(config.path.length));
                }
                if (normalizedValue.startsWith(`${config.name}/`)) {
                    return safeDecodeURIComponent(normalizedValue.substring(config.name.length + 1));
                }
            }
            return value;
        }

        function normalizeSongsUrl(value) {
            return normalizeResourceUrl(value, 'songs');
        }

        function stripSongsPrefix(value) {
            return stripResourcePrefix(value, 'songs');
        }

        function normalizeStaticUrl(value) {
            return normalizeResourceUrl(value, 'static');
        }

        function normalizeBackupsUrl(value) {
            return normalizeResourceUrl(value, 'backups');
        }

        // Âú®È°µÈù¢ÂºÄÂßãÂ∞±ÂÆö‰πâ checkLyrics ÂáΩÊï∞
        function checkLyrics(lyricsPath, filename) {
            fetch('/check_lyrics', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    path: lyricsPath
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        const tagsContainer = document.getElementById(`tags-${filename}`)
                        if (data.hasDuet) {
                            const duetTag = document.createElement('span')
                            duetTag.className = 'song-tag duet-tag'
                            duetTag.textContent = 'ÂåÖÂê´ÂØπÂî±Ê≠åËØç'
                            tagsContainer.appendChild(duetTag)
                        }
                        if (data.hasBackgroundVocals) {
                            const bgTag = document.createElement('span')
                            bgTag.className = 'song-tag background-vocals-tag'
                            bgTag.textContent = 'ÂåÖÂê´ËÉåÊôØÊ≠åËØç'
                            tagsContainer.appendChild(bgTag)
                        }
                        if (typeof applySearch === 'function') {
                            applySearch()
                        }
                    }
                })
        }

        async function openFamyliamCloud(filename, preset) {
            // Â¶ÇÊûúÊòØAMLLËßÑÂàôÁºñÂÜôÁΩëÂùÄ
            if (preset === 'amll') {
                try {
                    const styleSettingsSnapshot = readCachedAmllSettings();
                    const styleQuerySnapshot = buildStyleQueryFromSettings(styleSettingsSnapshot);

                    const response = await fetch('/get_json_data?filename=' + encodeURIComponent(filename));
                    const data = await response.json();
                    if (data.status !== 'success') {
                        alert('Êó†Ê≥ïËé∑ÂèñÊ≠åÊõ≤‰ø°ÊÅØ');
                        return;
                    }

                    const jsonData = data.jsonData;
                    const meta = jsonData.meta || {};

                    const title = encodeURIComponent(meta.title || '');
                    const artists = encodeURIComponent((meta.artists || []).join(' / '));

                    let musicPath = '';
                    if (jsonData.song) {
                        const resolvedSongUrl = normalizeSongsUrl(jsonData.song);
                        if (resolvedSongUrl && resolvedSongUrl !== '!') {
                            musicPath = encodeURIComponent(resolvedSongUrl);
                        }
                    }

                    let lyricsPath = '';
                    let originalLyricsRelative = '';
                    const lyricsField = meta.lyrics || '';
                    const lyricCandidate = lyricsField.includes('::')
                        ? (lyricsField.split('::')[1] || '')
                        : lyricsField;
                    if (lyricCandidate && lyricCandidate !== '!') {
                        const resolvedLyricsUrl = normalizeSongsUrl(lyricCandidate);
                        if (resolvedLyricsUrl && resolvedLyricsUrl !== '!') {
                            lyricsPath = encodeURIComponent(resolvedLyricsUrl);
                            originalLyricsRelative = stripSongsPrefix(resolvedLyricsUrl);
                        }
                    }

                    let coverPath = '';
                    if (meta.albumImgSrc) {
                        const resolvedCoverUrl = normalizeSongsUrl(meta.albumImgSrc);
                        if (resolvedCoverUrl && resolvedCoverUrl !== '!') {
                            const coverFileName = safeDecodeURIComponent((resolvedCoverUrl.split('/').pop() || '')).toLowerCase();
                            if (coverFileName && coverFileName !== '‰∏ìËæëÂõæ.jpg' && coverFileName !== 'album_cover.jpg') {
                                coverPath = encodeURIComponent(resolvedCoverUrl);
                            }
                        }
                    }

                    if (!coverPath && meta['Background-image']) {
                        const resolvedBackgroundUrl = normalizeSongsUrl(meta['Background-image']);
                        if (resolvedBackgroundUrl && resolvedBackgroundUrl !== '!') {
                            coverPath = encodeURIComponent(resolvedBackgroundUrl);
                        }
                    }

                    const coverQuery = coverPath ? `&cover=${coverPath}` : '';

                    const openAmllPlayer = (encodedLyricPath) => {
                        const styleQuery = styleQuerySnapshot;
                        const params = [];
                        if (musicPath) params.push(`music=${musicPath}`);
                        if (encodedLyricPath) params.push(`lyric=${encodedLyricPath}`);
                        if (title) params.push(`title=${title}`);
                        if (artists) params.push(`artist=${artists}`);
                        if (coverPath) params.push(`cover=${coverPath}`);
                        const baseQuery = params.join('&');
                        const mergedQuery = baseQuery
                            ? `${baseQuery}${styleQuery}`
                            : (styleQuery ? styleQuery.replace(/^&/, '') : '');
                        const amllUrl = mergedQuery
                            ? `${amllPlayerBaseUrl}?${mergedQuery}`
                            : amllPlayerBaseUrl;
                        window.open(amllUrl, '_blank');
                    };
                    const preparePlayerLyric = async (sourcePath) => {
                        const resp = await fetch('/prepare_ttml_for_player', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: sourcePath })
                        });
                        const data = await resp.json();
                        if (data.status === 'success' && data.ttmlPath) {
                            return normalizeSongsUrl(data.ttmlPath);
                        }
                        const message = data.message || 'ÁîüÊàêTTMLÂ§±Ë¥•';
                        throw new Error(message);
                    };

                    if (originalLyricsRelative) {
                        try {
                            const preparedUrl = await preparePlayerLyric(lyricCandidate);
                            const preparedPath = encodeURIComponent(preparedUrl);
                            openAmllPlayer(preparedPath);
                        } catch (error) {
                            console.warn('Ê≠åËØçÂ§ÑÁêÜÂ§±Ë¥•ÔºåÂ∑≤Ë∑≥ËøáÊ≠åËØçÂèÇÊï∞:', error);
                            openAmllPlayer('');
                        }
                    } else {
                        openAmllPlayer('');
                    }
                } catch (error) {
                    console.error('Ëé∑ÂèñÊ≠åÊõ≤‰ø°ÊÅØÂ§±Ë¥•:', error);
                    alert('Ëé∑ÂèñÊ≠åÊõ≤‰ø°ÊÅØÂ§±Ë¥•');
                }
                return;
            }

            // ÂéüÊúâÁöÑÂ§ÑÁêÜÈÄªËæë
            const baseUrl = preset === 'am'
                ? `http://localhost:8081/app/?#${backendRootUrl}`
                : `https://famyliam.ft2.ltd/app?preset=${preset}&font-preset=misans&pulling=superweak#${backendRootUrl}`;
            window.open(baseUrl + filename);
        }

        // ÊêúÁ¥¢ÂäüËÉΩ
        const searchBox = document.getElementById('songSearchInput')
        if (searchBox) {
            const unlock = () => {
                searchBox.removeAttribute('readonly')
            }
            searchBox.addEventListener('focus', unlock, { once: true })
            searchBox.addEventListener('pointerdown', unlock, { once: true })
            setTimeout(unlock, 200)
        }
        const fuzzySearchToggle = document.getElementById('fuzzySearchToggle')
        const jsonList = document.getElementById('jsonList')
        const jsonListStatus = document.getElementById('jsonListStatus')
        const songSummaryCache = new Map()
        let allJsonItems = []

        function getSortComparator() {
            return (a, b) => {
                if (currentSort.type === 'name') {
                    const textA = a.querySelector('.file-name').textContent.toLowerCase()
                    const textB = b.querySelector('.file-name').textContent.toLowerCase()
                    return currentSort.asc ? textA.localeCompare(textB, 'zh-Hans-CN')
                        : textB.localeCompare(textA, 'zh-Hans-CN')
                }
                const timeA = parseFloat(a.dataset.mtime)
                const timeB = parseFloat(b.dataset.mtime)
                return currentSort.asc ? timeA - timeB : timeB - timeA
            }
        }

        function parseKeywords(rawText) {
            const normalized = rawText.replace(/Ôºå/g, ',')
            const keywords = normalized.split(',').map(keyword => keyword.trim()).filter(Boolean)
            return Array.from(new Set(keywords))
        }

        function parseFuzzyKeywords(rawText) {
            const normalized = rawText.replace(/[,Ôºå\s\-_]+/g, '')
            const keywords = Array.from(normalized).filter(Boolean)
            return Array.from(new Set(keywords))
        }

        function setListStatus(message, isError = false, loading = false) {
            if (!jsonListStatus) return
            if (!message) {
                jsonListStatus.style.display = 'none'
                jsonListStatus.innerHTML = ''
                return
            }
            jsonListStatus.style.display = 'flex'
            jsonListStatus.style.color = isError ? '#d9534f' : '#666'
            if (loading) {
                jsonListStatus.innerHTML = `<span class="spinner"></span><span>${message}</span>`
            } else {
                jsonListStatus.textContent = message
            }
        }

        function toggleLoader(show, text = 'Loading') {
            const wrapper = document.getElementById('wifiLoaderWrapper')
            const textEl = document.querySelector('#wifi-loader .text')
            if (!wrapper) return
            if (textEl && text) {
                textEl.setAttribute('data-text', text)
            }
            wrapper.style.display = show ? 'flex' : 'none'
        }

        let monacoLoaderPromise = null
        let lyricsMonacoEditor = null
        let translationMonacoEditor = null
        let lyricsSearchMonacoEditor = null
        let translationSearchMonacoEditor = null
        let pendingLyricsText = ''
        let pendingTranslationText = ''
        let pendingSearchLyricsText = ''
        let pendingSearchTranslationText = ''
        let monacoTheme = 'vs'

        function applyMonacoTheme() {
            const target = document.body.classList.contains('dark-mode') ? 'vs-dark' : 'vs'
            monacoTheme = target
            loadMonaco().then(monaco => {
                if (monaco && monaco.editor) {
                    monaco.editor.setTheme(target)
                }
            }).catch(() => { /* ignore */ })
        }

        function loadMonaco() {
            if (monacoLoaderPromise) return monacoLoaderPromise
            monacoLoaderPromise = new Promise((resolve, reject) => {
                if (window.monaco) {
                    resolve(window.monaco)
                    return
                }
                const script = document.createElement('script')
                script.src = '/monaco/vs/loader.js'
                script.onload = () => {
                    if (!window.require) {
                        reject(new Error('Monaco loader Êú™ÊâæÂà∞'))
                        return
                    }
                    window.require.config({ paths: { 'vs': '/monaco/vs' } })
                    window.require(['vs/editor/editor.main'], () => resolve(window.monaco))
                }
                script.onerror = () => reject(new Error('Âä†ËΩΩ Monaco Â§±Ë¥•'))
                document.body.appendChild(script)
            })
            return monacoLoaderPromise
        }

        function buildMonacoOptions(value) {
            return {
                value: value || '',
                language: 'plaintext',
                theme: monacoTheme,
                automaticLayout: true,
                minimap: { enabled: false },
                wordWrap: 'off',
                scrollBeyondLastColumn: 5
            }
        }

        async function ensureMonacoEditors() {
            const monaco = await loadMonaco()
            if (!monaco) return
            if (!lyricsMonacoEditor) {
                lyricsMonacoEditor = monaco.editor.create(
                    document.getElementById('lyricsEditor'),
                    buildMonacoOptions(pendingLyricsText)
                )
            }
            if (!translationMonacoEditor) {
                translationMonacoEditor = monaco.editor.create(
                    document.getElementById('translationEditor'),
                    buildMonacoOptions(pendingTranslationText)
                )
            }
            bindEditorValueProxy()
            if (monaco && monaco.editor) {
                monaco.editor.setTheme(monacoTheme)
            }
        }

        async function ensureLyricsSearchEditors() {
            const monaco = await loadMonaco()
            if (!monaco) return
            const lyricsEl = document.getElementById('lyricsSearchLyricsEditor')
            const translationEl = document.getElementById('lyricsSearchTranslationEditor')
            if (lyricsEl && !lyricsSearchMonacoEditor) {
                lyricsSearchMonacoEditor = monaco.editor.create(
                    lyricsEl,
                    buildMonacoOptions(pendingSearchLyricsText)
                )
            }
            if (translationEl && !translationSearchMonacoEditor) {
                translationSearchMonacoEditor = monaco.editor.create(
                    translationEl,
                    buildMonacoOptions(pendingSearchTranslationText)
                )
            }
            if (monaco && monaco.editor) {
                monaco.editor.setTheme(monacoTheme)
            }
        }

        function setSearchLyricsContent(value) {
            pendingSearchLyricsText = value || ''
            if (lyricsSearchMonacoEditor) {
                lyricsSearchMonacoEditor.setValue(pendingSearchLyricsText)
            }
        }

        function setSearchTranslationContent(value) {
            pendingSearchTranslationText = value || ''
            if (translationSearchMonacoEditor) {
                translationSearchMonacoEditor.setValue(pendingSearchTranslationText)
            }
        }

        function getSearchLyricsContent() {
            if (lyricsSearchMonacoEditor) return lyricsSearchMonacoEditor.getValue()
            return pendingSearchLyricsText || ''
        }

        function getSearchTranslationContent() {
            if (translationSearchMonacoEditor) return translationSearchMonacoEditor.getValue()
            return pendingSearchTranslationText || ''
        }

        function getLyricsContent() {
            if (lyricsMonacoEditor) return lyricsMonacoEditor.getValue()
            const el = document.getElementById('lyricsEditor')
            return el && 'value' in el ? el.value : (pendingLyricsText || '')
        }

        function setLyricsContent(value) {
            pendingLyricsText = value || ''
            if (lyricsMonacoEditor) {
                lyricsMonacoEditor.setValue(pendingLyricsText)
            } else {
                const el = document.getElementById('lyricsEditor')
                if (el && 'value' in el) {
                    el.value = pendingLyricsText
                }
            }
        }

        function getTranslationContent() {
            if (translationMonacoEditor) return translationMonacoEditor.getValue()
            const el = document.getElementById('translationEditor')
            return el && 'value' in el ? el.value : (pendingTranslationText || '')
        }

        function setTranslationContent(value) {
            pendingTranslationText = value || ''
            if (translationMonacoEditor) {
                translationMonacoEditor.setValue(pendingTranslationText)
            } else {
                const el = document.getElementById('translationEditor')
                if (el && 'value' in el) {
                    el.value = pendingTranslationText
                }
            }
        }

        function bindEditorValueProxy() {
            const lyricsEl = document.getElementById('lyricsEditor')
            if (lyricsEl && !lyricsEl.__valueProxy) {
                Object.defineProperty(lyricsEl, 'value', {
                    get: () => getLyricsContent(),
                    set: (v) => setLyricsContent(v)
                })
                lyricsEl.__valueProxy = true
            }
            const translationEl = document.getElementById('translationEditor')
            if (translationEl && !translationEl.__valueProxy) {
                Object.defineProperty(translationEl, 'value', {
                    get: () => getTranslationContent(),
                    set: (v) => setTranslationContent(v)
                })
                translationEl.__valueProxy = true
            }
        }

        function createTag(text, className) {
            const span = document.createElement('span')
            span.className = className
            span.textContent = text
            return span
        }

        function normalizeLyricsValue(value) {
            return String(value || '').trim()
        }

        function extractLyricsPathFromMeta(metaLyrics) {
            const raw = normalizeLyricsValue(metaLyrics)
            if (!raw) return ''
            const parts = raw.split('::')
            if (parts.length >= 4) {
                return normalizeLyricsValue(parts[1])
            }
            return raw
        }

        function hasLyricsSummary(summary) {
            const direct = normalizeLyricsValue(summary.lyricsPath)
            if (direct && direct !== '!') return true
            const fromMeta = extractLyricsPathFromMeta(summary.metaLyrics)
            return Boolean(fromMeta && fromMeta !== '!')
        }

        function buildSongTags(summary) {
            const container = document.createElement('div')
            container.className = 'song-tags'
            container.id = `tags-${summary.filename}`
            if (!hasLyricsSummary(summary)) {
                container.appendChild(createTag('Á∫ØÈü≥‰πê', 'song-tag instrumental-tag'))
            }
            if (!summary.hasAudio) {
                container.appendChild(createTag('Êó†Èü≥Ê∫ê', 'song-tag no-audio-tag'))
            }
            if (summary.hasDuet) {
                container.appendChild(createTag('ÂåÖÂê´ÂØπÂî±Ê≠åËØç', 'song-tag duet-tag'))
            }
            if (summary.hasBackgroundVocals) {
                container.appendChild(createTag('ÂåÖÂê´ËÉåÊôØÊ≠åËØç', 'song-tag background-vocals-tag'))
            }
            return container
        }

        let albumCoverObserver = null
        const videoCoverCache = new Map()

        function stripQueryHash(value) {
            return String(value || '').split('?')[0].split('#')[0]
        }

        function resolveBackgroundVideoUrl(raw) {
            if (!raw || raw === '!') {
                return ''
            }
            const normalized = normalizeSongsUrl(raw)
            const checkTarget = stripQueryHash(normalized)
            if (!hasValidVideoExtension(checkTarget)) {
                return ''
            }
            return normalized
        }

        function resolveBackgroundImageUrl(raw) {
            if (!raw || raw === '!') {
                return ''
            }
            const normalized = normalizeSongsUrl(raw)
            const checkTarget = stripQueryHash(normalized)
            if (!hasValidImageExtension(checkTarget)) {
                return ''
            }
            return normalized
        }

        function captureVideoMiddleFrame(videoUrl) {
            if (videoCoverCache.has(videoUrl)) {
                return videoCoverCache.get(videoUrl)
            }

            const promise = new Promise(resolve => {
                const video = document.createElement('video')
                let settled = false

                const finalize = (dataUrl) => {
                    if (settled) return
                    settled = true
                    try {
                        video.pause()
                        video.removeAttribute('src')
                        video.load()
                    } catch (error) {
                        // Ignore cleanup errors
                    }
                    resolve(dataUrl || '')
                }

                const fail = () => finalize('')

                video.crossOrigin = 'anonymous'
                video.preload = 'metadata'
                video.muted = true
                video.playsInline = true
                video.addEventListener('error', fail, { once: true })

                video.addEventListener('loadedmetadata', () => {
                    const duration = Number.isFinite(video.duration) ? video.duration : 0
                    const targetTime = duration > 0 ? duration / 2 : 0
                    try {
                        video.currentTime = targetTime
                    } catch (error) {
                        fail()
                    }
                }, { once: true })

                video.addEventListener('seeked', () => {
                    const width = video.videoWidth || 0
                    const height = video.videoHeight || 0
                    if (!width || !height) {
                        fail()
                        return
                    }
                    const canvas = document.createElement('canvas')
                    canvas.width = width
                    canvas.height = height
                    const ctx = canvas.getContext('2d')
                    if (!ctx) {
                        fail()
                        return
                    }
                    try {
                        ctx.drawImage(video, 0, 0, width, height)
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.92)
                        finalize(dataUrl)
                    } catch (error) {
                        fail()
                    }
                })

                video.src = videoUrl
            }).then(dataUrl => {
                if (!dataUrl) {
                    videoCoverCache.delete(videoUrl)
                }
                return dataUrl
            })

            videoCoverCache.set(videoUrl, promise)
            return promise
        }

        function ensureAlbumCoverObserver() {
            if (albumCoverObserver || !('IntersectionObserver' in window)) {
                return
            }
            albumCoverObserver = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (!entry.isIntersecting) return
                    const cover = entry.target
                    const dataSrc = cover.getAttribute('data-src')
                    const dataVideo = cover.getAttribute('data-video-src')
                    if (dataVideo && !cover.src) {
                        captureVideoMiddleFrame(dataVideo).then(dataUrl => {
                            if (!dataUrl) {
                                if (cover.parentElement) {
                                    cover.parentElement.removeChild(cover)
                                }
                                const container = cover.closest('.file-name')
                                if (container) {
                                    container.classList.remove('has-cover')
                                }
                                return
                            }
                            cover.src = dataUrl
                        })
                    } else if (dataSrc && !cover.src) {
                        cover.src = dataSrc
                    }
                    albumCoverObserver.unobserve(cover)
                })
            }, { rootMargin: '150px 0px' })
        }

        function createSongItem(summary) {
            const li = document.createElement('li')
            li.className = 'json-item'
            li.dataset.mtime = summary.mtime || 0

            const header = document.createElement('div')
            header.className = 'json-item-header'

            const fileNameDiv = document.createElement('div')
            fileNameDiv.className = 'file-name'
            const displayName = summary.filename.replace(/\.json$/i, '')
            const fileNameText = document.createElement('span')
            fileNameText.className = 'file-name-text'
            fileNameText.textContent = displayName
            fileNameDiv.appendChild(fileNameText)
            const coverUrl = summary.albumImgSrc ? resolveCoverUrl(summary.albumImgSrc) : ''
            const backgroundImageUrl = coverUrl ? '' : resolveBackgroundImageUrl(summary.backgroundImage || '')
            const backgroundVideoUrl = (coverUrl || backgroundImageUrl)
                ? ''
                : resolveBackgroundVideoUrl(summary.backgroundImage || '')
            if (coverUrl || backgroundImageUrl || backgroundVideoUrl) {
                fileNameDiv.classList.add('has-cover')
                const coverImg = document.createElement('img')
                coverImg.className = 'album-cover'
                coverImg.alt = 'album cover'
                coverImg.loading = 'lazy'
                if (coverUrl || backgroundImageUrl) {
                    coverImg.setAttribute('data-src', coverUrl || backgroundImageUrl)
                } else {
                    coverImg.setAttribute('data-video-src', backgroundVideoUrl)
                }
                coverImg.addEventListener('error', () => {
                    if (coverImg.parentElement) {
                        coverImg.parentElement.removeChild(coverImg)
                    }
                    fileNameDiv.classList.remove('has-cover')
                })
                fileNameDiv.appendChild(coverImg)
                ensureAlbumCoverObserver()
                if (albumCoverObserver) {
                    albumCoverObserver.observe(coverImg)
                } else if (coverUrl || backgroundImageUrl) {
                    coverImg.src = coverUrl || backgroundImageUrl
                } else if (backgroundVideoUrl) {
                    captureVideoMiddleFrame(backgroundVideoUrl).then(dataUrl => {
                        if (!dataUrl) {
                            if (coverImg.parentElement) {
                                coverImg.parentElement.removeChild(coverImg)
                            }
                            fileNameDiv.classList.remove('has-cover')
                            return
                        }
                        coverImg.src = dataUrl
                    })
                }
            }
            fileNameText.addEventListener('click', () => {
                const selection = window.getSelection()
                if (selection && !selection.isCollapsed) {
                    return
                }
                copyFileNameText(fileNameText)
            })

            header.appendChild(fileNameDiv)
            header.appendChild(buildSongTags(summary))
            li.appendChild(header)

            const actionsWrapper = document.createElement('div')
            actionsWrapper.className = 'json-item-actions'

            const styleButtons = document.createElement('div')
            styleButtons.className = 'style-buttons'

            const fsBtn = document.createElement('button')
            fsBtn.className = 'style-button fs-style'
            fsBtn.textContent = 'ÂÖ®Â±èÊ≠åËØçÊ†∑Âºè'
            fsBtn.addEventListener('click', () => openFamyliamCloud(summary.filename, 'fs'))

            const fslrBtn = document.createElement('button')
            fslrBtn.className = 'style-button fslr-style'
            fslrBtn.textContent = 'ÂÖ®Â±èÂØπÂî±Ê≠åËØçÊ†∑Âºè'
            fslrBtn.addEventListener('click', () => openFamyliamCloud(summary.filename, 'fslr'))

            const amllBtn = document.createElement('button')
            amllBtn.className = 'style-button am-style'
            amllBtn.textContent = 'AMÊ≠åËØçÊ†∑Âºè'
            amllBtn.addEventListener('click', () => openFamyliamCloud(summary.filename, 'amll'))

            const brightBtn = document.createElement('button')
            brightBtn.className = 'action-button'
            brightBtn.textContent = '‰∫ÆËµ∑'
            brightBtn.addEventListener('click', () => openLyricsAnimate(summary.filename, '‰∫ÆËµ∑'))

            const C_okBtn = document.createElement('button')
            C_okBtn.className = 'action-button'
            C_okBtn.textContent = 'C_ok'
            C_okBtn.addEventListener('click', () => openLyricsAnimate(summary.filename, 'C_ok'))

            styleButtons.appendChild(fsBtn)
            styleButtons.appendChild(fslrBtn)
            styleButtons.appendChild(amllBtn)
            styleButtons.appendChild(brightBtn)
            styleButtons.appendChild(C_okBtn)

            const fileActions = document.createElement('div')
            fileActions.className = 'file-actions'

            const editLyricsBtn = document.createElement('button')
            editLyricsBtn.className = 'action-button'
            editLyricsBtn.textContent = '‰øÆÊîπÊ≠åËØç'
            editLyricsBtn.addEventListener('click', () => {
                editLyrics(summary.lyricsPath || '', summary.translationPath || '', 0, summary.filename)
            })

            const editMusicBtn = document.createElement('button')
            editMusicBtn.className = 'action-button'
            editMusicBtn.textContent = '‰øÆÊîπÈü≥‰πêË∑ØÂæÑ'
            editMusicBtn.addEventListener('click', () => editMusicPath(summary.song || '', summary.filename))

            const editImageBtn = document.createElement('button')
            editImageBtn.className = 'action-button'
            editImageBtn.textContent = '‰øÆÊîπ‰∏ìËæëÂõæË∑ØÂæÑ'
            editImageBtn.addEventListener('click', () => editImagePath(summary.albumImgSrc || '', summary.filename))

            const exportBtn = document.createElement('button')
            exportBtn.className = 'action-button'
            exportBtn.textContent = 'ÂØºÂá∫ÂàÜ‰∫´'
            exportBtn.addEventListener('click', () => exportStatic(summary.filename))

            const renameBtn = document.createElement('button')
            renameBtn.className = 'action-button'
            renameBtn.textContent = 'ÈáçÂëΩÂêç'
            const artistsString = Array.isArray(summary.artists) ? summary.artists.join(',') : ''
            renameBtn.addEventListener('click', () => showRenameModal(summary.filename, summary.title || '', artistsString))

            const deleteBtn = document.createElement('button')
            deleteBtn.className = 'action-button'
            deleteBtn.textContent = 'Âà†Èô§Ê≠åÊõ≤'
            deleteBtn.addEventListener('click', () => {
                if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§Ê≠åÊõ≤Êù°ÁõÆÂêóÔºüÔºàÂÖ≥ËÅîÁöÑÊ≠åËØç„ÄÅÈü≥‰πêÁ≠âÊñá‰ª∂Â∞ÜË¢´‰øùÁïôÔºâ')) {
                    deleteJson(summary.filename)
                }
            })

            fileActions.appendChild(editLyricsBtn)
            fileActions.appendChild(editMusicBtn)
            fileActions.appendChild(editImageBtn)
            fileActions.appendChild(exportBtn)
            fileActions.appendChild(renameBtn)
            fileActions.appendChild(deleteBtn)

            actionsWrapper.appendChild(styleButtons)
            actionsWrapper.appendChild(fileActions)

            const preview = document.createElement('div')
            preview.className = 'file-preview'
            preview.id = `preview-${summary.filename}`
            const previewContent = document.createElement('div')
            previewContent.className = 'preview-content'
            preview.appendChild(previewContent)

            li.appendChild(actionsWrapper)
            li.appendChild(preview)
            return li
        }

        function renderSongList(summaries) {
            const list = document.getElementById('jsonList')
            songSummaryCache.clear()
            list.innerHTML = ''
            allJsonItems = []

            summaries.forEach(summary => {
                songSummaryCache.set(summary.filename, summary)
                const item = createSongItem(summary)
                allJsonItems.push(item)
            })

            applySearch()
        }

        async function loadSongSummaries() {
            setListStatus('Ê≠£Âú®Âä†ËΩΩÊ≠åÊõ≤ÂàóË°®ÔºåËØ∑Á®çÂÄô...', false, true)
            toggleLoader(true, 'Loading')
            try {
                const res = await fetch('/songs/summary')
                const data = await res.json()
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Âä†ËΩΩÂ§±Ë¥•')
                }
                renderSongList(data.songs || [])
                setListStatus('')
            } catch (error) {
                console.error('Âä†ËΩΩÊ≠åÊõ≤ÊëòË¶ÅÂ§±Ë¥•', error)
                setListStatus(`Âä†ËΩΩÂ§±Ë¥•Ôºö${error.message || error}`, true)
            } finally {
                toggleLoader(false)
            }
        }

        function buildSearchPool(item) {
            const fileName = item.querySelector('.file-name')?.textContent || ''
            const tagsText = item.querySelector('.song-tags')?.textContent || ''
            return `${fileName} ${tagsText}`.toLowerCase()
        }

        function applySearch() {
            const rawText = searchBox.value.toLowerCase()
            const isFuzzy = fuzzySearchToggle && fuzzySearchToggle.checked
            const keywords = isFuzzy ? parseFuzzyKeywords(rawText) : parseKeywords(rawText)
            const list = document.getElementById('jsonList')
            const listItems = Array.from(allJsonItems || [])

            if (listItems.length === 0) {
                while (list.firstChild) {
                    list.removeChild(list.firstChild)
                }
                return
            }

            if (keywords.length === 0) {
                listItems.sort(getSortComparator())
                while (list.firstChild) {
                    list.removeChild(list.firstChild)
                }
                listItems.forEach(item => {
                    item.style.display = ''
                    list.appendChild(item)
                })
                return
            }

            const comparator = getSortComparator()

            const rankedItems = listItems.map(item => {
                const searchPool = buildSearchPool(item)
                const matchCount = keywords.reduce((count, keyword) => searchPool.includes(keyword) ? count + 1 : count, 0)
                return { item, matchCount }
            })

            const visibleItems = rankedItems.filter(entry => entry.matchCount > 0)
            const hiddenItems = rankedItems.filter(entry => entry.matchCount === 0)

            visibleItems.sort((a, b) => {
                if (b.matchCount !== a.matchCount) {
                    return b.matchCount - a.matchCount
                }
                return comparator(a.item, b.item)
            })

            hiddenItems.sort((a, b) => comparator(a.item, b.item))

            while (list.firstChild) {
                list.removeChild(list.firstChild)
            }

            visibleItems.forEach(({ item }) => {
                item.style.display = ''
                list.appendChild(item)
            })

            hiddenItems.forEach(({ item }) => {
                item.style.display = 'none'
            })
        }

        searchBox.addEventListener('input', applySearch)
        if (fuzzySearchToggle) {
            fuzzySearchToggle.addEventListener('change', applySearch)
        }

        let currentEditingFile = ''
        let currentLyricsPath = ''
        let currentLyricsIndex = 0
        let currentJsonFile = ''
        let currentMusicPath = ''
        let currentMusicJsonFile = ''
        let currentImagePath = ''
        let currentImageJsonFile = ''
        let currentRenameFile = ''
        let currentSort = { type: 'time', asc: false } // ÂàùÂßã‰∏∫Êó∂Èó¥ÂÄíÂ∫è
        let currentRestoreFile = ''
        let lastThinkingSummary = ''

        function toggleSort(type) {
            if (type === currentSort.type) {
                currentSort.asc = !currentSort.asc
            } else {
                currentSort.type = type
                currentSort.asc = (type === 'name') // ÂêçÁß∞ÊéíÂ∫èÈªòËÆ§ÂçáÂ∫è
            }
            updateSortButtons()
            applySearch()
        }

        function updateSortButtons() {
            const nameBtn = document.getElementById('nameSortBtn')
            const timeBtn = document.getElementById('timeSortBtn')

            nameBtn.textContent = `A-Z ${currentSort.type === 'name' ? (currentSort.asc ? '‚Üë' : '‚Üì') : ''}`
            timeBtn.textContent = `Êó∂Èó¥ ${currentSort.type === 'time' ? (currentSort.asc ? '‚Üë' : '‚Üì') : ''}`
        }

        function sortList() {
            const list = document.getElementById('jsonList')
            const items = Array.from(allJsonItems || [])
            const comparator = getSortComparator()

            items.sort(comparator)

            while (list.firstChild) {
                list.removeChild(list.firstChild)
            }
            if (items.length > 0) {
                items.forEach(item => {
                    item.style.display = ''
                    list.appendChild(item)
                })
            }
        }

        // ÂàùÂßãÂåñÊó∂Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
        window.addEventListener('DOMContentLoaded', () => {
            updateSortButtons()
            bindEditorValueProxy()
            loadSongSummaries()
        })

        function viewFile(type, path) {
            // ÂÆûÁé∞Êñá‰ª∂È¢ÑËßàÈÄªËæë
        }

        function editJson(filename) {
            currentEditingFile = filename
            const modal = document.getElementById('editModal')
            const editor = document.getElementById('jsonEditor')
            // Ëé∑ÂèñJSONÂÜÖÂÆπÂπ∂ÊòæÁ§∫Âú®ÁºñËæëÂô®‰∏≠
            modal.style.display = 'block'
        }

        function saveJson() {
            const editor = document.getElementById('jsonEditor')
            fetch('/update_json', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filename: currentEditingFile,
                    content: JSON.parse(editor.value)
                })
            }).then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        closeModal()
                        location.reload()
                    }
                })
        }

        function closeModal() {
            document.getElementById('editModal').style.display = 'none'
        }

        function restoreFile(filename) {
            fetch('/restore_file', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    file_path: normalizeStaticUrl(filename)
                })
            }).then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        location.reload()
                    }
                })
        }

        function detectFontFamilyTag(text) {
            if (!text) return '';
            const match = text.match(/^\s*\[font-family:\s*([^\]]+?)\s*\]\s*$/mi);
            return match ? match[1].trim() : '';
        }

        function updateFontFamilyNotice(content) {
            const noticeEl = document.getElementById('fontFamilyNotice');
            if (!noticeEl) return;
            const detected = detectFontFamilyTag(content);
            if (detected) {
                noticeEl.textContent = `Ê£ÄÊµãÂà∞Â≠ó‰ΩìÊ†áÁ≠æÔºö${detected}`;
                noticeEl.style.display = 'block';
            } else {
                noticeEl.textContent = 'Êú™Ê£ÄÊµãÂà∞Â≠ó‰ΩìÊ†áÁ≠æ';
                noticeEl.style.display = 'block';
            }
        }

        async function editLyrics(lyricsPath, translationPath, index, jsonFile) {
            currentJsonFile = jsonFile
            const modal = document.getElementById('lyricsModal')
            const lyricsPathInput = document.getElementById('lyricsPath')
            const translationPathInput = document.getElementById('translationPath')
            const normalizedLyricsPath = lyricsPath && lyricsPath !== '!' ? lyricsPath : ''
            const normalizedTranslationPath = translationPath && translationPath !== '!' ? translationPath : ''
            
            // ËÆæÁΩÆÂΩìÂâçÊñá‰ª∂Âêç
            document.getElementById('currentFileName').textContent = jsonFile.replace('.json', '')

            // ËÆæÁΩÆË∑ØÂæÑ
            lyricsPathInput.value = normalizedLyricsPath ? stripSongsPrefix(normalizedLyricsPath) : ''
            translationPathInput.value = normalizedTranslationPath ? stripSongsPrefix(normalizedTranslationPath) : ''

            updateFontFamilyNotice('')
            await ensureMonacoEditors()

            // Âä†ËΩΩÊ≠åËØçÂÜÖÂÆπ
            if (normalizedLyricsPath) {
                fetch('/get_lyrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: normalizedLyricsPath })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            setLyricsContent(data.content)
                            updateFontFamilyNotice(data.content)
                        }
                    })
            } else {
                setLyricsContent('')
            }

            // Âä†ËΩΩÁøªËØëÂÜÖÂÆπ
            if (normalizedTranslationPath) {
                fetch('/get_lyrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: normalizedTranslationPath })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            setTranslationContent(data.content)
                        }
                    })
            } else {
                setTranslationContent('')
            }

            modal.style.display = 'block'
            checkFileExtension()
        }

        function openQuickEdit() {
            if (!currentJsonFile) {
                alert('ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÁºñËæëÁöÑÊ≠åÊõ≤')
                return
            }
            const target = `/quick-editor?json=${encodeURIComponent(currentJsonFile)}`
            window.open(target, '_blank')
        }

        let latestLyricsSearchResult = null
        const LYRICS_SEARCH_REGEX_KEYS = {
            title: 'lyricsSearchTitleRegex',
            artist: 'lyricsSearchArtistRegex'
        }

        function openLyricsSearchModal() {
            const modal = document.getElementById('lyricsSearchModal')
            if (!modal) return
            modal.style.display = 'block'
            latestLyricsSearchResult = null
            document.getElementById('lyricsSearchResults').innerHTML = ''
            setLyricsSearchPreview('', '')
            const currentName = document.getElementById('currentFileName').textContent.trim()
            document.getElementById('lyricsSearchFileName').textContent = currentName || 'Êú™ÈÄâÊã©'
            loadLyricsSearchRegexCache()
            ensureLyricsSearchEditors()
            applySearchNameFromFile(false)
            performLyricsSearch()
        }

        function closeLyricsSearchModal() {
            const modal = document.getElementById('lyricsSearchModal')
            if (modal) {
                modal.style.display = 'none'
            }
        }

        function setLyricsSearchStatus(text) {
            const statusEl = document.getElementById('lyricsSearchStatus')
            if (!statusEl) return
            const safeText = escapeHtml(text)
            if (/^Ê≠£Âú®/.test(text)) {
                statusEl.innerHTML = `<a href="#" class="btn-shine">${safeText}</a>`
            } else {
                statusEl.textContent = text
            }
            statusEl.style.display = 'block'
            statusEl.classList.remove('status-error', 'status-success', 'status-info')
            if (/Â§±Ë¥•|ÈîôËØØ/.test(text)) {
                statusEl.classList.add('status-error')
            } else if (/ÂÆåÊàê|ÊàêÂäü|ÊâæÂà∞/.test(text)) {
                statusEl.classList.add('status-success')
            } else {
                statusEl.classList.add('status-info')
            }
        }

        function escapeHtml(value) {
            return String(value).replace(/[&<>"']/g, match => {
                switch (match) {
                    case '&': return '&amp;'
                    case '<': return '&lt;'
                    case '>': return '&gt;'
                    case '"': return '&quot;'
                    case "'": return '&#39;'
                    default: return match
                }
            })
        }

        function setLyricsSearchPreview(lysText, translationText) {
            setSearchLyricsContent(lysText || '')
            setSearchTranslationContent(translationText || '')
        }

        function clearLyricsSearchInputs() {
            document.getElementById('lyricsSearchKeyword').value = ''
            document.getElementById('lyricsSearchTitle').value = ''
            document.getElementById('lyricsSearchArtist').value = ''
            document.getElementById('lyricsSearchTitleRegex').value = ''
            document.getElementById('lyricsSearchArtistRegex').value = ''
            persistLyricsSearchRegexCache()
            setLyricsSearchStatus('Â∑≤Ê∏ÖÁ©∫ËæìÂÖ•')
        }

        function normalizeSearchFileName(rawName) {
            if (!rawName) return ''
            return rawName.replace(/\.[^.]+$/, '')
        }

        function applySearchNameFromFile(autoMatch = false) {
            const fileName = normalizeSearchFileName(document.getElementById('currentFileName').textContent.trim())
            if (!fileName) {
                setLyricsSearchStatus('Êú™ÊâæÂà∞ÂΩìÂâçÊñá‰ª∂Âêç')
                return
            }
            let title = document.getElementById('lyricsSearchTitle').value.trim()
            let artist = document.getElementById('lyricsSearchArtist').value.trim()
            const titleRegex = document.getElementById('lyricsSearchTitleRegex').value.trim()
            const artistRegex = document.getElementById('lyricsSearchArtistRegex').value.trim()
            if (titleRegex) {
                try {
                    const match = fileName.match(new RegExp(titleRegex))
                    if (match) title = (match[1] || match[0] || '').trim()
                } catch (error) {
                    alert('Ê≠åÊõ≤ÂêçÊ≠£ÂàôÊó†Êïà')
                    return
                }
            }
            if (artistRegex) {
                try {
                    const match = fileName.match(new RegExp(artistRegex))
                    if (match) artist = (match[1] || match[0] || '').trim()
                } catch (error) {
                    alert('Ëâ∫ÊúØÂÆ∂ÂêçÊ≠£ÂàôÊó†Êïà')
                    return
                }
            }
            persistLyricsSearchRegexCache()
            if (!title && !artist && fileName.includes(' - ')) {
                const parts = fileName.split(' - ')
                title = parts[0].trim()
                artist = parts.slice(1).join(' - ').trim()
            }
            document.getElementById('lyricsSearchTitle').value = title
            document.getElementById('lyricsSearchArtist').value = artist
            if (title && artist) {
                document.getElementById('lyricsSearchKeyword').value = `${title} ${artist}`
                setLyricsSearchStatus('Â∑≤‰ªéÊñá‰ª∂ÂêçËß£ÊûêÊ≠åÊõ≤‰ø°ÊÅØ')
                if (autoMatch) {
                    performLyricsMatch(title, artist)
                }
            } else {
                setLyricsSearchStatus('Êú™ËÉΩ‰ªéÊñá‰ª∂ÂêçËß£ÊûêÂÆåÊï¥‰ø°ÊÅØ')
            }
        }

        function persistLyricsSearchRegexCache() {
            const titleRegex = document.getElementById('lyricsSearchTitleRegex').value.trim()
            const artistRegex = document.getElementById('lyricsSearchArtistRegex').value.trim()
            localStorage.setItem(LYRICS_SEARCH_REGEX_KEYS.title, titleRegex)
            localStorage.setItem(LYRICS_SEARCH_REGEX_KEYS.artist, artistRegex)
        }

        function loadLyricsSearchRegexCache() {
            const cachedTitle = localStorage.getItem(LYRICS_SEARCH_REGEX_KEYS.title) || ''
            const cachedArtist = localStorage.getItem(LYRICS_SEARCH_REGEX_KEYS.artist) || ''
            document.getElementById('lyricsSearchTitleRegex').value = cachedTitle
            document.getElementById('lyricsSearchArtistRegex').value = cachedArtist
        }

        function performLyricsMatchFromInputs() {
            const title = document.getElementById('lyricsSearchTitle').value.trim()
            const artist = document.getElementById('lyricsSearchArtist').value.trim()
            if (title && artist) {
                performLyricsMatch(title, artist)
                return
            }
            alert('ËØ∑Â°´ÂÜôÊ≠åÊõ≤ÂêçÂíåËâ∫ÊúØÂÆ∂Âêç')
        }

        function performLyricsSearch() {
            let keyword = document.getElementById('lyricsSearchKeyword').value.trim()
            if (!keyword) {
                const title = document.getElementById('lyricsSearchTitle').value.trim()
                const artist = document.getElementById('lyricsSearchArtist').value.trim()
                if (title || artist) {
                    keyword = `${title} ${artist}`.trim()
                    document.getElementById('lyricsSearchKeyword').value = keyword
                }
            }
            if (!keyword) {
                alert('ËØ∑Â°´ÂÜôÂÖ≥ÈîÆËØçÁî®‰∫éÊêúÁ¥¢ÂàóË°®')
                return
            }
            performLyricsKeywordSearch(keyword)
        }

        function performLyricsMatch(title, artist) {
            setLyricsSearchStatus('Ê≠£Âú®ÂåπÈÖçÊ≠åËØç...')
            const params = new URLSearchParams({ title, artist })
            fetch(`/lddc/match_lyrics?${params.toString()}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status !== 'success') {
                        setLyricsSearchStatus(`ÂåπÈÖçÂ§±Ë¥•Ôºö${data.message || 'Êú™Áü•ÈîôËØØ'}`)
                        return
                    }
                    latestLyricsSearchResult = data
                    setLyricsSearchPreview(data.lyrics_lys || '', data.translation_lrc || '')
                    setLyricsSearchStatus('ÂåπÈÖçÂÆåÊàêÔºåÂèØÁÇπÂáªÂ∫îÁî®Âà∞ÁºñËæëÂô®')
                })
                .catch(error => {
                    setLyricsSearchStatus(`ÂåπÈÖçÂ§±Ë¥•Ôºö${error}`)
                })
        }

        function renderLyricsSearchResults(results) {
            const container = document.getElementById('lyricsSearchResults')
            container.innerHTML = ''
            if (!results || results.length === 0) {
                container.textContent = 'Ê≤°ÊúâÊâæÂà∞ÁªìÊûú'
                return
            }
            try {
                results.forEach((item, index) => {
                    const div = document.createElement('div')
                    div.className = 'lyrics-search-item'
                    const artistText = Array.isArray(item.artist) ? item.artist.join(', ') : (item.artist || '')
                    div.textContent = `${index + 1}. ${item.title} - ${artistText} (${item.source || 'Êú™Áü•Êù•Ê∫ê'})`
                    div.addEventListener('click', () => fetchLyricsById(item.song_info_json))
                    container.appendChild(div)
                })
            } catch (error) {
                container.textContent = `Ê∏≤ÊüìÂ§±Ë¥•: ${error}`
            }
        }

        function performLyricsKeywordSearch(keyword) {
            setLyricsSearchStatus('Ê≠£Âú®ÊêúÁ¥¢Ê≠åËØç...')
            fetch(`/lddc/search?keyword=${encodeURIComponent(keyword)}`)
                .then(async response => {
                    if (!response.ok) {
                        const text = await response.text()
                        throw new Error(text || `HTTP ${response.status}`)
                    }
                    return response.json()
                })
                .then(data => {
                    window.lastLddcSearch = data
                    const results = Array.isArray(data)
                        ? data
                        : (data.results || (data.status === 'success' ? [] : []))
                    if (!Array.isArray(results)) {
                        setLyricsSearchStatus('ÊêúÁ¥¢Â§±Ë¥•ÔºöËøîÂõûÊ†ºÂºèÂºÇÂ∏∏')
                        return
                    }
                    renderLyricsSearchResults(results)
                    if (results.length === 0 && data && data.results && Array.isArray(data.results)) {
                        const container = document.getElementById('lyricsSearchResults')
                        container.textContent = `ËøîÂõû‰∫Ü ${data.results.length} Êù°Ôºå‰ΩÜÊ∏≤Êüì‰∏∫Á©∫ÔºåËØ∑ÂèçÈ¶à`
                    }
                    setLyricsSearchStatus(`ÊêúÁ¥¢ÂÆåÊàêÔºåÊâæÂà∞ ${results.length} ‰∏™ÁªìÊûú`)
                })
                .catch(error => {
                    setLyricsSearchStatus(`ÊêúÁ¥¢Â§±Ë¥•Ôºö${error}`)
                })
        }

        function fetchLyricsById(songInfoJson) {
            if (!songInfoJson) {
                alert('Êó†ÊïàÁöÑ song_info_json')
                return
            }
            setLyricsSearchStatus('Ê≠£Âú®Ëé∑ÂèñÊ≠åËØç...')
            fetch('/lddc/get_lyrics_by_id', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ song_info_json: songInfoJson })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status !== 'success') {
                        setLyricsSearchStatus(`Ëé∑ÂèñÂ§±Ë¥•Ôºö${data.message || 'Êú™Áü•ÈîôËØØ'}`)
                        return
                    }
                    latestLyricsSearchResult = data
                    setLyricsSearchPreview(data.lyrics_lys || '', data.translation_lrc || '')
                    setLyricsSearchStatus('Ëé∑ÂèñÂÆåÊàêÔºåÂèØÁÇπÂáªÂ∫îÁî®Âà∞ÁºñËæëÂô®')
                })
                .catch(error => {
                    setLyricsSearchStatus(`Ëé∑ÂèñÂ§±Ë¥•Ôºö${error}`)
                })
        }

        function applyLyricsSearchResult() {
            const lyricsText = getSearchLyricsContent()
            const translationText = getSearchTranslationContent()
            if (!lyricsText && !translationText) {
                alert('ÊöÇÊó†ÂèØÂ∫îÁî®ÁöÑÊ≠åËØçÂÜÖÂÆπ')
                return
            }
            setLyricsContent(lyricsText)
            setTranslationContent(translationText)
            updateFontFamilyNotice(lyricsText)
            setLyricsSearchStatus('Â∑≤Â∫îÁî®Âà∞ÁºñËæëÂô®ÔºåÂèØÁÇπÂáª‰øùÂ≠ò')
        }

        async function copyTTMLForAMLL() {
            const lyricsPath = document.getElementById('lyricsPath').value.trim();
            const lyricsContent = getLyricsContent();
            const pathExtension = (lyricsPath.match(/\.[^.]+$/) || [])[0]?.toLowerCase() || '';
            const detectedExtension = detectLyricsExtension(lyricsContent);
            const isTtml = pathExtension === '.ttml' || detectedExtension === '.ttml';

            if (isTtml) {
                if (!lyricsContent.trim()) {
                    alert('ÂΩìÂâçÊ≠åËØçÂÜÖÂÆπ‰∏∫Á©∫ÔºåÊó†Ê≥ïÂ§çÂà∂TTML');
                    return;
                }
                try {
                    await navigator.clipboard.writeText(lyricsContent);
                    alert('Â∑≤Â§çÂà∂TTMLÂà∞Ââ™Ë¥¥ÊùøÔºÅ\nËØ∑Âú®ÊâìÂºÄÁöÑÊñ∞ÁïåÈù¢ËøõÂÖ•ÔºöÊâìÂºÄ - ‰ªéÂâ™Ë¥¥ÊùøÂØºÂÖ• TTML„ÄÇ');
                    window.open('https://editor.amll.dev/', '_blank');
                } catch (error) {
                    alert('Â§çÂà∂Â§±Ë¥•Ôºö' + (error.message || error));
                }
                return;
            }

            if (!lyricsPath) {
                alert('ËØ∑ÂÖàÂú®"Ê≠åËØçÊñá‰ª∂Ë∑ØÂæÑ"ËæìÂÖ•Ê°Ü‰∏≠Â°´ÂÜôLYS/LRCÊñá‰ª∂Âêç');
                return;
            }

            if (pathExtension !== '.lys' && pathExtension !== '.lrc') {
                alert('‰ªÖÊîØÊåÅLYS/LRCÊ†ºÂºèËΩ¨Êç¢‰∏∫TTMLÂπ∂Â§çÂà∂');
                return;
            }

            try {
                const response = await fetch('/convert_to_ttml', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: lyricsPath })
                });
                const data = await response.json();
                if (data.status !== 'success' || !data.ttmlPath) {
                    alert('ËΩ¨Êç¢Â§±Ë¥•Ôºö' + (data.message || 'Êó†Ê≥ïÁîüÊàêTTML'));
                    return;
                }

                const ttmlResponse = await fetch('/get_lyrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: data.ttmlPath })
                });
                const ttmlData = await ttmlResponse.json();
                if (ttmlData.status !== 'success') {
                    alert('ËØªÂèñTTMLÂ§±Ë¥•Ôºö' + (ttmlData.message || 'Êú™Áü•ÈîôËØØ'));
                    return;
                }

                await navigator.clipboard.writeText(ttmlData.content || '');
                alert('Â∑≤Â§çÂà∂TTMLÂà∞Ââ™Ë¥¥ÊùøÔºÅ\nËØ∑Âú®ÊâìÂºÄÁöÑÊñ∞ÁïåÈù¢ËøõÂÖ•ÔºöÊâìÂºÄ - ‰ªéÂâ™Ë¥¥ÊùøÂØºÂÖ• TTML„ÄÇ');
                window.open('https://editor.amll.dev/', '_blank');
            } catch (error) {
                alert('ËΩ¨Êç¢ÊàñÂ§çÂà∂Â§±Ë¥•Ôºö' + (error.message || error));
            }
        }

        function saveLyrics(index) {
            const path = index === 0 ?
                document.getElementById('lyricsPath').value :
                document.getElementById('translationPath').value
            const content = index === 0 ?
                getLyricsContent() :
                getTranslationContent()
            const trimmedPath = (path || '').trim()

            // È™åËØÅË∑ØÂæÑ
            if (!trimmedPath || trimmedPath === '.' || trimmedPath === './') {
                if (index === 0 || index === 1) {
                    return updateLyricsPath(index).then(() => Promise.resolve())
                }
                return Promise.reject(new Error('Êó†ÊïàÁöÑÊñá‰ª∂Ë∑ØÂæÑ'));
            }

            return new Promise((resolve, reject) => {
                const fullPath = normalizeSongsUrl(trimmedPath)

                fetch('/save_lyrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        path: fullPath,
                        content: content
                    })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            resolve()
                        } else if (data.status === 'warning') {
                            alert(data.message)
                            resolve()  // ‰ªçÁÑ∂resolveÂõ†‰∏∫Êñá‰ª∂Â∑≤Áªè‰øùÂ≠òÊàêÂäü
                        } else {
                            reject(new Error(data.message || '‰øùÂ≠òÂ§±Ë¥•'))
                        }
                    })
                    .catch(error => reject(error))
            })
        }

        async function saveAllLyrics() {
            const saveBtn = document.querySelector('.save-all-btn');
            saveBtn.disabled = true;
            saveBtn.textContent = 'Ê≠£Âú®‰øùÂ≠ò...';

            try {
                const lyricsPath = document.getElementById('lyricsPath').value;
                const translationPath = document.getElementById('translationPath').value;
                const trimmedLyricsPath = (lyricsPath || '').trim();

                // È™åËØÅÊ≠åËØçË∑ØÂæÑ
                if (!trimmedLyricsPath || trimmedLyricsPath === '.' || trimmedLyricsPath === './') {
                    await updateLyricsPath(0);
                } else {
                    await updateLyricsPath(0);
                    await saveLyrics(0);
                }

                // È™åËØÅÁøªËØëË∑ØÂæÑÔºàÂ¶ÇÊûúÊúâÔºâ
                if (translationPath && (translationPath === '.' || translationPath === './')) {
                    throw new Error('ÁøªËØëÊñá‰ª∂Ë∑ØÂæÑÊó†Êïà');
                }

                // Âè™ÊúâÂú®ÊúâÁøªËØëË∑ØÂæÑÊó∂Êâç‰øùÂ≠òÁøªËØë
                if (translationPath) {
                    await updateLyricsPath(1);
                    await saveLyrics(1);
                }

                alert('ÂÖ®ÈÉ®‰øùÂ≠òÊàêÂäüÔºÅ');
            } catch (err) {
                alert('‰øùÂ≠òËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØÔºö' + err.message);
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'üíæ ‰øùÂ≠òÂÖ®ÈÉ®';
            }
        }

        function updateLyricsPath(index) {
            return new Promise((resolve, reject) => {
                const pathInput = index === 0 ?
                    document.getElementById('lyricsPath') :
                    document.getElementById('translationPath')
                const newPath = (pathInput.value || '').trim()

                fetch('/update_file_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonFile: currentJsonFile,
                        fileType: 'lyrics',
                        newPath: newPath,
                        index: index,
                        clear: !newPath
                    })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            resolve()
                        } else {
                            reject(new Error('Ë∑ØÂæÑÊõ¥Êñ∞Â§±Ë¥•'))
                        }
                    })
                    .catch(error => reject(error))
            })
        }

        function closeLyricsModal() {
            document.getElementById('lyricsModal').style.display = 'none'
            location.reload()
        }

        function editMusicPath(path, jsonFile) {
            currentMusicPath = path
            currentMusicJsonFile = jsonFile
            const modal = document.getElementById('musicPathModal')
            const currentPathInput = document.getElementById('musicPath')
            const newPathInput = document.getElementById('newMusicPath')

            // ÊòæÁ§∫ÂΩìÂâçË∑ØÂæÑÔºàÂéªÊéâÂâçÁºÄÔºâ
            currentPathInput.value = stripSongsPrefix(path)
            newPathInput.value = currentPathInput.value

            modal.style.display = 'block'
        }

        function updateMusicPath() {
            const newPath = document.getElementById('newMusicPath').value.trim()

            if (!newPath) {
                alert('ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊñá‰ª∂Ë∑ØÂæÑÔºÅ')
                return
            }

            fetch('/update_file_path', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonFile: currentMusicJsonFile,
                    fileType: 'music',
                    newPath: newPath
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        closeMusicPathModal()
                        location.reload()
                    } else {
                        alert('Êõ¥Êñ∞Â§±Ë¥•Ôºö' + data.message)
                    }
                })
                .catch(error => {
                    alert('Êõ¥Êñ∞Â§±Ë¥•Ôºö' + error)
                })
        }

        function closeMusicPathModal() {
            document.getElementById('musicPathModal').style.display = 'none'
        }

        const VALID_IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.webp']
        const VALID_VIDEO_EXTENSIONS = ['.mp4', '.webm', '.ogg', '.m4v', '.mov']
        const VALID_BACKGROUND_EXTENSIONS = [
            '.jpg', '.jpeg', '.png', '.gif', '.webp',
            '.mp4', '.webm', '.ogg', '.m4v', '.mov'
        ]

        function hasValidImageExtension(path) {
            if (!path) {
                return false
            }
            const lower = path.toLowerCase()
            return VALID_IMAGE_EXTENSIONS.some(ext => lower.endsWith(ext))
        }

        function hasValidVideoExtension(path) {
            if (!path) {
                return false
            }
            const lower = path.toLowerCase()
            return VALID_VIDEO_EXTENSIONS.some(ext => lower.endsWith(ext))
        }

        function hasValidBackgroundExtension(path) {
            if (!path) {
                return false
            }
            const lower = path.toLowerCase()
            return VALID_BACKGROUND_EXTENSIONS.some(ext => lower.endsWith(ext))
        }

        function editImagePath(path, jsonFile) {
            currentImagePath = path
            currentImageJsonFile = jsonFile
            const modal = document.getElementById('imagePathModal')
            const currentPathInput = document.getElementById('imagePath')
            const newPathInput = document.getElementById('newImagePath')
            const backgroundPathInput = document.getElementById('backgroundPath')
            const newBackgroundPathInput = document.getElementById('newBackgroundPath')

            // ÊòæÁ§∫ÂΩìÂâçË∑ØÂæÑÔºàÂéªÊéâÂâçÁºÄÔºâ
            currentPathInput.value = stripSongsPrefix(path)
            newPathInput.value = currentPathInput.value
            
            // Ëé∑ÂèñÂΩìÂâçËÉåÊôØÂõæÁâáË∑ØÂæÑ
            fetch('/get_json_data?filename=' + encodeURIComponent(jsonFile))
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        const backgroundPath = data.jsonData.meta['Background-image'] || ''
                        backgroundPathInput.value = backgroundPath
                        const editableBackgroundPath = backgroundPath === '!' ? '' : stripSongsPrefix(backgroundPath)
                        newBackgroundPathInput.value = editableBackgroundPath
                    }
                })

            modal.style.display = 'block'
        }

        function updateImagePath() {
            const newPath = document.getElementById('newImagePath').value.trim()

            if (!newPath) {
                alert('ËØ∑ËæìÂÖ•Êñ∞ÁöÑÊñá‰ª∂Ë∑ØÂæÑÔºÅ')
                return
            }

            // Ê£ÄÊü•Êñá‰ª∂Êâ©Â±ïÂêç
            if (!hasValidImageExtension(newPath)) {
                alert('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂõæÁâáÊñá‰ª∂ÂêçÔºàÊîØÊåÅ.jpg„ÄÅ.jpeg„ÄÅ.png„ÄÅ.gif„ÄÅ.webpÔºâ')
                return
            }

            fetch('/update_file_path', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonFile: currentImageJsonFile,
                    fileType: 'image',
                    newPath: newPath
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        closeImagePathModal()
                        location.reload()
                    } else {
                        alert('Êõ¥Êñ∞Â§±Ë¥•Ôºö' + data.message)
                    }
                })
                .catch(error => {
                    alert('Êõ¥Êñ∞Â§±Ë¥•Ôºö' + error)
                })
        }

        function updateBackgroundPath() {
            const rawPath = document.getElementById('newBackgroundPath').value.trim()
            const newPath = rawPath === '!' ? '' : stripSongsPrefix(rawPath)

            if (newPath) {
                // Ê£ÄÊü•Êñá‰ª∂Êâ©Â±ïÂêç
                if (!hasValidBackgroundExtension(newPath)) {
                    alert('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑËÉåÊôØÊñá‰ª∂ÂêçÔºàÊîØÊåÅ.jpg„ÄÅ.jpeg„ÄÅ.png„ÄÅ.gif„ÄÅ.webp„ÄÅ.mp4„ÄÅ.webm„ÄÅ.ogg„ÄÅ.m4v„ÄÅ.movÔºâ')
                    return
                }
            }

            fetch('/update_file_path', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonFile: currentImageJsonFile,
                    fileType: 'background',
                    newPath: newPath
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        closeImagePathModal()
                        location.reload()
                    } else {
                        alert('Êõ¥Êñ∞Â§±Ë¥•Ôºö' + data.message)
                    }
                })
                .catch(error => {
                    alert('Êõ¥Êñ∞Â§±Ë¥•Ôºö' + error)
                })
        }

        async function saveAllImagePaths() {
            const albumPathInput = document.getElementById('newImagePath')
            const backgroundPathInput = document.getElementById('newBackgroundPath')
            const albumPath = albumPathInput.value.trim()
            const rawBackgroundPath = backgroundPathInput.value.trim()

            if (!albumPath) {
                alert('ËØ∑ËæìÂÖ•Êñ∞ÁöÑ‰∏ìËæëÂõæË∑ØÂæÑÔºÅ')
                return
            }

            if (!hasValidImageExtension(albumPath)) {
                alert('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑ‰∏ìËæëÂõæÁâáÊñá‰ª∂ÂêçÔºàÊîØÊåÅ.jpg„ÄÅ.jpeg„ÄÅ.png„ÄÅ.gif„ÄÅ.webpÔºâ')
                return
            }

            let normalizedBackgroundPath = ''
            if (rawBackgroundPath && rawBackgroundPath !== '!') {
                if (!hasValidBackgroundExtension(rawBackgroundPath)) {
                    alert('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑËÉåÊôØÊñá‰ª∂ÂêçÔºàÊîØÊåÅ.jpg„ÄÅ.jpeg„ÄÅ.png„ÄÅ.gif„ÄÅ.webp„ÄÅ.mp4„ÄÅ.webm„ÄÅ.ogg„ÄÅ.m4v„ÄÅ.movÔºâ')
                    return
                }
                normalizedBackgroundPath = stripSongsPrefix(rawBackgroundPath)
            }

            try {
                const albumResponse = await fetch('/update_file_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonFile: currentImageJsonFile,
                        fileType: 'image',
                        newPath: albumPath
                    })
                })

                if (!albumResponse.ok) {
                    throw new Error('‰∏ìËæëÂõæ‰øùÂ≠òÂ§±Ë¥•')
                }

                const albumResult = await albumResponse.json()
                if (albumResult.status !== 'success') {
                    throw new Error(albumResult.message || '‰∏ìËæëÂõæ‰øùÂ≠òÂ§±Ë¥•')
                }

                const backgroundResponse = await fetch('/update_file_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonFile: currentImageJsonFile,
                        fileType: 'background',
                        newPath: normalizedBackgroundPath
                    })
                })

                if (!backgroundResponse.ok) {
                    throw new Error('ËÉåÊôØÂõæ‰øùÂ≠òÂ§±Ë¥•')
                }

                const backgroundResult = await backgroundResponse.json()
                if (backgroundResult.status !== 'success') {
                    throw new Error(backgroundResult.message || 'ËÉåÊôØÂõæ‰øùÂ≠òÂ§±Ë¥•')
                }

                closeImagePathModal()
                location.reload()
            } catch (error) {
                alert('‰øùÂ≠òÂ§±Ë¥•Ôºö' + (error.message || error))
            }
        }

        function closeImagePathModal() {
            document.getElementById('imagePathModal').style.display = 'none'
        }
        
        function convertTTML() {
            const lyricsPath = document.getElementById('lyricsPath').value.trim();
            if (!lyricsPath || !lyricsPath.toLowerCase().endsWith('.ttml')) {
                alert('ËØ∑ÂÖàÂú®"Ê≠åËØçÊñá‰ª∂Ë∑ØÂæÑ"ËæìÂÖ•Ê°Ü‰∏≠Â°´ÂÜôTTMLÊñá‰ª∂ÂêçÔºàÂ¶Ç xxx.ttmlÔºâ');
                return;
            }

            fetch('/convert_ttml_by_path', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: lyricsPath })
            })
            .then(response => response.json())
            .then(data => {
                const lyricsEditor = document.getElementById('lyricsEditor');
                if (data.status === 'success') {
                    document.getElementById('lyricsPath').value = stripSongsPrefix(data.lyricPath);
                    if (data.transPath) {
                        document.getElementById('translationPath').value = stripSongsPrefix(data.transPath);
                    }
                    // Ëá™Âä®Ëé∑ÂèñÂπ∂Â∫îÁî®Ê≠åËØçÂÜÖÂÆπ
                    fetch('/get_lyrics', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: data.lyricPath })
                    })
                    .then(response => response.json())
                    .then(lyricsData => {
                        if (lyricsData.status === 'success') {
                            lyricsEditor.value = lyricsData.content;
                        }
                    });
                    // Ëá™Âä®Ëé∑ÂèñÂπ∂Â∫îÁî®ÁøªËØëÂÜÖÂÆπ
                    if (data.transPath) {
                        fetch('/get_lyrics', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ path: data.transPath })
                        })
                        .then(response => response.json())
                        .then(transData => {
                            if (transData.status === 'success') {
                                document.getElementById('translationEditor').value = transData.content;
                            }
                        });
                    }
                    alert('TTMLËá™Âä®ËΩ¨Êç¢ÊàêÂäüÔºÅÈúÄË¶ÅÁÇπÂáª"‰øùÂ≠òÂÖ®ÈÉ®"Â∫îÁî®ÔºåËã•ËΩ¨Êç¢Âá∫Èîô ËØ∑Áõ¥Êé•ÁÇπÂáªÂÖ≥Èó≠!');
                } else {
                    alert('Ëá™Âä®ËΩ¨Êç¢Â§±Ë¥•Ôºö' + data.message);
                }
            })
            .catch(error => {
                alert('Ëá™Âä®ËΩ¨Êç¢Â§±Ë¥•Ôºö' + error);
            });
        }

        function convertToTTML() {
            const lyricsPath = document.getElementById('lyricsPath').value.trim();
            if (!lyricsPath) {
                alert('ËØ∑ÂÖàÂú®"Ê≠åËØçÊñá‰ª∂Ë∑ØÂæÑ"ËæìÂÖ•Ê°Ü‰∏≠Â°´ÂÜôÊñá‰ª∂Âêç');
                return;
            }

            // Ê£ÄÊü•Êñá‰ª∂Êâ©Â±ïÂêç
            const fileExt = lyricsPath.toLowerCase().substring(lyricsPath.lastIndexOf('.'));
            if (fileExt !== '.lys' && fileExt !== '.lrc') {
                alert('Âè™ÊîØÊåÅLYSÂíåLRCÊ†ºÂºèÁöÑÊ≠åËØçÊñá‰ª∂');
                return;
            }

            fetch('/convert_to_ttml', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: lyricsPath })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Êõ¥Êñ∞Ê≠åËØçË∑ØÂæÑ‰∏∫TTMLÊñá‰ª∂
                    document.getElementById('lyricsPath').value = stripSongsPrefix(data.ttmlPath);

                    // Ëá™Âä®Ëé∑ÂèñÂπ∂Â∫îÁî®ËΩ¨Êç¢ÂêéÁöÑTTMLÂÜÖÂÆπ
                    fetch('/get_lyrics', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: data.ttmlPath })
                    })
                    .then(response => response.json())
                    .then(lyricsData => {
                        if (lyricsData.status === 'success') {
                            document.getElementById('lyricsEditor').value = lyricsData.content;
                        }
                    });

                    alert('LYS/LRCËΩ¨TTMLËΩ¨Êç¢ÊàêÂäüÔºÅÈúÄË¶ÅÁÇπÂáª"‰øùÂ≠òÂÖ®ÈÉ®"Â∫îÁî®ÔºåËã•ËΩ¨Êç¢Âá∫ÈîôËØ∑Áõ¥Êé•ÁÇπÂáªÂÖ≥Èó≠!');
                } else {
                    alert('ËΩ¨Êç¢Â§±Ë¥•Ôºö' + data.message);
                }
            })
            .catch(error => {
                alert('ËΩ¨Êç¢Â§±Ë¥•Ôºö' + error);
            });
        }

        let amllCardReady = false;

        function selectCreateMode(mode) {
            if (mode === 'amll' && !amllCardReady) {
                return;
            }
            createMode = mode;
            const amllCard = document.getElementById('amllSourceCard');
            const manualCard = document.getElementById('manualCreateCard');
            const audioCard = document.getElementById('audioImportCard');
            if (amllCard) {
                amllCard.classList.toggle('selected', mode === 'amll');
            }
            if (manualCard) {
                manualCard.classList.toggle('selected', mode === 'manual');
            }
            if (audioCard) {
                audioCard.classList.toggle('selected', mode === 'audio');
            }
        }

        function renderAmllPreview(lines) {
            if (!Array.isArray(lines) || lines.length === 0) {
                return 'ÊöÇÊó†Ê≠åËØçÊï∞ÊçÆ';
            }
            const previewLines = [];
            lines.slice(0, 4).forEach((line, idx) => {
                const syllables = Array.isArray(line.syllables) ? line.syllables : [];
                const text = syllables.map(s => s.text || '').join('') || line.translatedLyric || '';
                previewLines.push(`${idx + 1}. ${text || 'ÔºàÁ©∫Ë°åÔºâ'}`);
            });
            if (lines.length > 4) {
                previewLines.push(`... ËøòÊúâ ${lines.length - 4} Ë°å`);
            }
            return previewLines.join('\n');
        }

        function resolveCoverUrl(raw) {
            if (!raw || raw === '!') return DEFAULT_AMLL_COVER;
            if (raw.startsWith('data:')) return raw;
            let isSongsResource = false;
            try {
                const parsed = new URL(raw);
                isSongsResource = parsed.pathname.startsWith(RESOURCE_CONFIG.songs.path);
            } catch (error) {
                const normalized = raw.replace(/\\/g, '/');
                isSongsResource = normalized.startsWith('songs/') || normalized.startsWith('./songs/') || normalized.startsWith('/songs/');
            }
            if (isSongsResource) {
                return normalizeSongsUrl(raw);
            }
            if (raw.startsWith('http://') || raw.startsWith('https://')) return raw;
            if (raw.startsWith('//')) return window.location.protocol + raw;
            if (raw.startsWith('/')) return window.location.origin + raw;
            return raw;
        }

        async function refreshAmllSnapshot(force = false) {
            const statusEl = document.getElementById('amllCardStatus');
            const previewEl = document.getElementById('amllLyricsPreview');
            const cardEl = document.getElementById('amllSourceCard');
            const coverEl = document.getElementById('amllCoverPreview');
            if (statusEl) statusEl.textContent = 'Âà∑Êñ∞‰∏≠...';
            amllCardReady = false;
            try {
                const resp = await fetch('/amll/state' + (force ? `?_t=${Date.now()}` : ''));
                if (!resp.ok) {
                    throw new Error('ËØ∑Ê±ÇÂ§±Ë¥•');
                }
                const data = await resp.json();
                amllSnapshot = data;
                const song = data.song || {};
                const lines = data.lines || [];
                const coverUrl = resolveCoverUrl(
                    song.cover_data_url ||
                    song.cover_file_url ||
                    song.cover ||
                    song.albumImgSrc ||
                    song.coverUrl ||
                    DEFAULT_AMLL_COVER
                );
                if (coverEl) {
                    coverEl.src = coverUrl || DEFAULT_AMLL_COVER;
                }
                const titleEl = document.getElementById('amllSongTitleDisplay');
                const artistsEl = document.getElementById('amllSongArtistsDisplay');
                const albumEl = document.getElementById('amllSongAlbumDisplay');
                const summaryEl = document.getElementById('amllLyricsSummary');
                if (titleEl) titleEl.textContent = `Ê≠åÊõ≤ÂêçÔºö${song.musicName || 'Êú™Êèê‰æõ'}`;
                if (artistsEl) artistsEl.textContent = `Ê≠åÊâãÔºö${(song.artists || []).join(' / ') || 'Êú™Êèê‰æõ'}`;
                if (albumEl) albumEl.textContent = `‰∏ìËæëÔºö${song.album || 'Êú™Êèê‰æõ'}`;
                if (summaryEl) summaryEl.textContent = `Ê≠åËØçÔºö${lines.length ? `${lines.length} Ë°å` : 'ÊöÇÊó†Êï∞ÊçÆ'}`;
                if (previewEl) previewEl.textContent = renderAmllPreview(lines);
                amllCardReady = Boolean(song.musicName) && Array.isArray(lines) && lines.length > 0;
                if (statusEl) statusEl.textContent = amllCardReady ? 'ÂèØÁî®' : 'Á≠âÂæÖÊï∞ÊçÆ';
                if (cardEl) cardEl.classList.toggle('disabled', !amllCardReady);
                if (!amllCardReady && createMode === 'amll') {
                    selectCreateMode('manual');
                }
            } catch (error) {
                if (statusEl) statusEl.textContent = 'Ëé∑ÂèñÂ§±Ë¥•';
                if (previewEl) previewEl.textContent = 'Êó†Ê≥ïËé∑Âèñ AMLL Ê∫êÊï∞ÊçÆÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ';
                if (cardEl) cardEl.classList.add('disabled');
                amllSnapshot = null;
                amllCardReady = false;
            }
        }

        function showCreateModal() {
            document.getElementById('createJsonModal').style.display = 'block'
            document.getElementById('songTitle').value = ''
            document.getElementById('songArtists').value = ''
            selectCreateMode('manual')
            refreshAmllSnapshot()
        }

        function closeCreateModal() {
            document.getElementById('createJsonModal').style.display = 'none'
        }

        function buildSongJsonData(title, artists, baseName, songFileName) {
            return {
                serial: 123456,
                meta: {
                    title: title,
                    artists: artists,
                    albumImgSrc: `${RESOURCE_CONFIG.songs.base}‰∏ìËæëÂõæ.jpg`,
                    duration_ms: 0,
                    lyrics: '::!::!::!::'
                },
                song: `${RESOURCE_CONFIG.songs.base}${songFileName}`
            }
        }

        function createJsonFile() {
            if (createMode === 'amll') {
                createFromAmllSource()
                return
            }
            if (createMode === 'audio') {
                alert('ËØ∑ÂÖàÈÄâÊã©Èü≥È¢ëÊñá‰ª∂ËøõË°åÂØºÂÖ•')
                return
            }
            const title = document.getElementById('songTitle').value.trim()
            const artistsInput = document.getElementById('songArtists').value.trim()

            if (!title || !artistsInput) {
                alert('ËØ∑Â°´ÂÜôÊ≠åÊõ≤ÂêçÂíåÊ≠åÊâãÂêçÔºÅ')
                return
            }

            const artists = artistsInput.split(',').map(artist => artist.trim()).filter(artist => artist)

            if (artists.length === 0) {
                alert('ËØ∑Ëá≥Â∞ëËæìÂÖ•‰∏Ä‰ΩçÊ≠åÊâãÔºÅ')
                return
            }

            // Ê∏ÖÁêÜÊñá‰ª∂ÂêçÔºåÁßªÈô§‰∏çÂÖÅËÆ∏ÁöÑÁâπÊÆäÂ≠óÁ¨¶ÔºåÊõøÊç¢ÂÖ®ËßíÂºïÂè∑
            const cleanTitle = title.replace(/[\\/:*<>|]/g, '').replace(/[\"\']/g, 'ÔºÇ')
            const cleanArtists = artists.map(artist => artist.replace(/[\\/:*<>|]/g, '').replace(/[\"\']/g, 'ÔºÇ'))
            // ÊûÑÂª∫Êñá‰ª∂Âêç
            const fileName = `${cleanTitle} - ${cleanArtists.join(' _ ')}.json`

            const jsonData = buildSongJsonData(title, artists, 'Ê≠åËØç', 'Èü≥‰πê.mp3')

            // ÂèëÈÄÅÂàõÂª∫ËØ∑Ê±Ç
            fetch('/create_json', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    filename: fileName,
                    content: jsonData
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        closeCreateModal()
                        location.reload()
                    } else {
                        alert('ÂàõÂª∫Â§±Ë¥•Ôºö' + data.message)
                    }
                })
                .catch(error => {
                    alert('ÂàõÂª∫Â§±Ë¥•Ôºö' + error)
                })
        }

        async function createFromAmllSource() {
            if (!amllCardReady || !amllSnapshot || !Array.isArray(amllSnapshot.lines) || amllSnapshot.lines.length === 0) {
                alert('AMLLÊ∫êÊöÇÊó†ÂèØÁî®Êï∞ÊçÆÔºåËØ∑ÂÖàÊí≠ÊîæÂπ∂Âà∑Êñ∞„ÄÇ')
                return
            }
            const btn = document.getElementById('createJsonConfirm')
            if (btn) {
                btn.disabled = true
                btn.textContent = 'ÂàõÂª∫‰∏≠...'
            }
            try {
                const resp = await fetch('/amll/create_song', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ useTranslation: true })
                })
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}`)
                }
                const data = await resp.json()
                if (data.status === 'success') {
                    alert(`ÂàõÂª∫ÊàêÂäüÔºö${data.jsonFile}`)
                    closeCreateModal()
                    location.reload()
                } else {
                    alert(`ÂàõÂª∫Â§±Ë¥•Ôºö${data.message}`)
                }
            } catch (error) {
                alert(`ÂàõÂª∫Â§±Ë¥•Ôºö${error}`)
            } finally {
                if (btn) {
                    btn.disabled = false
                    btn.textContent = 'ÂàõÂª∫'
                }
            }
        }

        function getFileBaseName(fileName) {
            return fileName.replace(/\.[^.]+$/, '')
        }

        function parseTitleArtistFromName(rawName) {
            const baseName = getFileBaseName(rawName).trim()
            if (!baseName) {
                return { title: '', artists: [] }
            }
            const parts = baseName.split(' - ')
            if (parts.length >= 2) {
                const title = parts[0].trim()
                const artistText = parts.slice(1).join(' - ').trim()
                const artists = artistText
                    .split(/ _ |,|Ôºå/g)
                    .map(item => item.trim())
                    .filter(item => item)
                return { title: title, artists: artists.length ? artists : [artistText] }
            }
            return { title: baseName, artists: [] }
        }

        async function handleCreateAudioImport(files) {
            if (!files || files.length === 0) {
                return
            }
            selectCreateMode('audio')
            const statusEl = document.getElementById('createAudioStatus')
            const results = []
            for (const file of files) {
                if (!file.type.startsWith('audio/') && !file.type.startsWith('video/')) {
                    results.push(`${file.name}: Ë∑≥ËøáÔºà‰∏çÊòØÈü≥È¢ë/ËßÜÈ¢ëÔºâ`)
                    continue
                }
                if (statusEl) {
                    statusEl.textContent = `Ê≠£Âú®‰∏ä‰º†Ôºö${file.name}`
                }
                const formData = new FormData()
                formData.append('file', file)
                try {
                    const uploadResp = await fetch('/upload_music', {
                        method: 'POST',
                        body: formData
                    })
                    const uploadData = await uploadResp.json()
                    if (uploadData.status !== 'success') {
                        results.push(`${file.name}: ‰∏ä‰º†Â§±Ë¥• - ${uploadData.message}`)
                        continue
                    }
                    const cleanName = uploadData.filename
                    const jsonName = `${cleanName}.json`
                    const parsed = parseTitleArtistFromName(cleanName)
                    const title = parsed.title || getFileBaseName(cleanName)
                    const artists = parsed.artists.length ? parsed.artists : ['Êú™Áü•Ê≠åÊâã']
                    const jsonData = buildSongJsonData(title, artists, getFileBaseName(cleanName), cleanName)
                    const createResp = await fetch('/create_json', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: jsonName,
                            content: jsonData
                        })
                    })
                    const createData = await createResp.json()
                    if (createData.status === 'success') {
                        results.push(`${cleanName}: ÂàõÂª∫ÊàêÂäü`)
                    } else {
                        results.push(`${cleanName}: ÂàõÂª∫Â§±Ë¥• - ${createData.message}`)
                    }
                } catch (error) {
                    results.push(`${file.name}: ÂàõÂª∫Â§±Ë¥• - ${error}`)
                }
            }
            if (statusEl) {
                statusEl.textContent = results.length ? results.join(' | ') : 'ÂØºÂÖ•ÂÆåÊàê'
            }
            if (results.length) {
                alert(results.join('\n'))
                location.reload()
            }
        }

        function triggerStaticImport() {
            const input = document.getElementById('staticZipInput')
            if (!input) {
                alert('Êú™ÊâæÂà∞ÂØºÂÖ•Êéß‰ª∂')
                return
            }
            input.value = ''
            input.click()
        }

        async function handleStaticImport(event) {
            const input = event ? event.target : null
            const file = input && input.files ? input.files[0] : null
            if (!file) {
                return
            }

            if (!file.name.toLowerCase().endsWith('.zip')) {
                alert('ËØ∑ÈÄâÊã© static.zip Êñá‰ª∂')
                input.value = ''
                return
            }

            const formData = new FormData()
            formData.append('file', file)

            try {
                const response = await fetch('/import_static', {
                    method: 'POST',
                    body: formData
                })
                const contentType = response.headers.get('content-type') || ''

                if (!contentType.includes('application/json')) {
                    throw new Error('ÊúçÂä°Âô®ËøîÂõûÊú™Áü•Ê†ºÂºè')
                }

                const result = await response.json()
                if (response.ok && result.status === 'success') {
                    alert(result.message || 'ÂØºÂÖ•ÊàêÂäü')
                    location.reload()
                } else {
                    throw new Error(result.message || 'ÂØºÂÖ•Â§±Ë¥•')
                }
            } catch (error) {
                alert(error.message || 'ÂØºÂÖ•Â§±Ë¥•')
            } finally {
                if (input) {
                    input.value = ''
                }
            }
        }

        async function exportStatic(filename) {
            if (!filename) {
                alert('Áº∫Â∞ëÊñá‰ª∂Âêç')
                return
            }

            try {
                const response = await fetch('/export_static', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename })
                })

                const contentType = response.headers.get('content-type') || ''

                if (!response.ok) {
                    if (contentType.includes('application/json')) {
                        const errorPayload = await response.json()
                        throw new Error(errorPayload.message || 'ÂØºÂá∫Â§±Ë¥•')
                    }
                    throw new Error('ÂØºÂá∫Â§±Ë¥•')
                }

                if (contentType.includes('application/json')) {
                    const payload = await response.json()
                    if (payload.status === 'error') {
                        throw new Error(payload.message || 'ÂØºÂá∫Â§±Ë¥•')
                    }
                    throw new Error(payload.message || 'ÊúçÂä°Âô®ËøîÂõûÊú™Áü•ÂÜÖÂÆπ')
                }

                const blob = await response.blob()
                const url = URL.createObjectURL(blob)
                const link = document.createElement('a')
                link.href = url
                link.download = 'static.zip'
                document.body.appendChild(link)
                link.click()
                document.body.removeChild(link)
                URL.revokeObjectURL(url)

                const missingCount = parseInt(response.headers.get('x-missing-assets-count') || '0', 10)
                if (missingCount > 0) {
                    alert(`ÂØºÂá∫ÂÆåÊàêÔºå‰ΩÜÊúâ ${missingCount} ‰∏™ËµÑÊ∫êÊú™ËÉΩÊâìÂåÖ„ÄÇËØ¶ÊÉÖËØ∑Êü•ÁúãÂéãÁº©ÂåÖÂÜÖÁöÑ warnings.txt„ÄÇ`)
                }
            } catch (error) {
                alert(error.message || 'ÂØºÂá∫Â§±Ë¥•')
            }
        }

        function showRenameModal(filename, title, artists) {
            currentRenameFile = filename
            const modal = document.getElementById('renameModal')
            const titleInput = document.getElementById('renameSongTitle')
            const artistsInput = document.getElementById('renameSongArtists')

            // Ê∏ÖÁêÜÊñá‰ª∂ÂêçÔºåÊõøÊç¢ÂÖ®ËßíÂºïÂè∑
            const cleanTitle = title.replace(/[\"\']/g, 'ÔºÇ')
            const cleanArtists = artists.split(',').map(artist => artist.trim().replace(/[\"\']/g, 'ÔºÇ')).join(',')
            titleInput.value = cleanTitle
            artistsInput.value = cleanArtists

            modal.style.display = 'block'
        }

        function closeRenameModal() {
            document.getElementById('renameModal').style.display = 'none'
        }

        function renameJsonFile() {
            const title = document.getElementById('renameSongTitle').value.trim()
            const artistsInput = document.getElementById('renameSongArtists').value.trim()

            if (!title || !artistsInput) {
                alert('ËØ∑Â°´ÂÜôÊ≠åÊõ≤ÂêçÂíåÊ≠åÊâãÂêçÔºÅ')
                return
            }

            const artists = artistsInput.split(',').map(artist => artist.trim()).filter(artist => artist)

            if (artists.length === 0) {
                alert('ËØ∑Ëá≥Â∞ëËæìÂÖ•‰∏Ä‰ΩçÊ≠åÊâãÔºÅ')
                return
            }

            // ÊûÑÂª∫Êñ∞Êñá‰ª∂Âêç
            const newFileName = `${title} - ${artists.join(' _ ')}.json`

            fetch('/rename_json', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    oldFilename: currentRenameFile,
                    newFilename: newFileName,
                    title: title,
                    artists: artists
                })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        closeRenameModal()
                        location.reload()
                    } else {
                        alert('ÈáçÂëΩÂêçÂ§±Ë¥•Ôºö' + data.message)
                    }
                })
                .catch(error => {
                    alert('ÈáçÂëΩÂêçÂ§±Ë¥•Ôºö' + error)
                })
        }

        // ‰∏ªÈ¢òÂàáÊç¢ÂäüËÉΩ
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode')
            const isDark = document.body.classList.contains('dark-mode')
            localStorage.setItem('darkMode', isDark)
            document.getElementById('themeToggle').textContent = isDark ? 'üåû ÊµÖËâ≤Ê®°Âºè' : 'üåí Ê∑±Ëâ≤Ê®°Âºè'
            applyMonacoTheme()
        }

        // ÂàùÂßãÂåñ‰∏ªÈ¢ò
        function initTheme() {
            const savedDarkMode = localStorage.getItem('darkMode') === 'true'
            if (savedDarkMode) {
                document.body.classList.add('dark-mode')
                document.getElementById('themeToggle').textContent = 'üåû ÊµÖËâ≤Ê®°Âºè'
            }
            applyMonacoTheme()
        }
        initTheme()

        function handleMusicUpload() {
            const fileInput = document.getElementById('musicUpload')
            const file = fileInput.files[0]

            if (!file) return

            // ÂÖÅËÆ∏ÊâÄÊúâÈü≥È¢ëËßÜÈ¢ëÊ†ºÂºè
            if (!file.type.startsWith('audio/') && !file.type.startsWith('video/')) {
                alert('ËØ∑‰∏ä‰º†Èü≥È¢ëÊàñËßÜÈ¢ëÊñá‰ª∂')
                return
            }

            // Ê∏ÖÁêÜÊñá‰ª∂ÂêçÔºàÊõøÊç¢ÁâπÊÆäÂ≠óÁ¨¶Ôºâ
            const cleanFileName = file.name.replace(/[^a-zA-Z0-9\u4e00-\u9fa5\-_.]/g, '')

            const formData = new FormData()
            formData.append('file', file, cleanFileName)

            fetch('/upload_music', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('newMusicPath').value = cleanFileName
                        updateMusicPath() // Ëá™Âä®Ëß¶Âèë‰øùÂ≠ò
                    } else {
                        alert('‰∏ä‰º†Â§±Ë¥•: ' + data.message)
                    }
                })
                .catch(error => {
                    console.error('Error:', error)
                    alert('‰∏ä‰º†Â§±Ë¥•')
                })
        }

        async function handleImageUpload(file, type) {
            if (!file) return

            const formData = new FormData()
            formData.append('file', file)

            try {
                const response = await fetch('/upload_image', {
                    method: 'POST',
                    body: formData
                })
                const result = await response.json()

                if (result.status === 'success') {
                    if (type === 'album') {
                        document.getElementById('newImagePath').value = result.filename
                    } else if (type === 'background') {
                        document.getElementById('newBackgroundPath').value = result.filename
                    }
                } else {
                    alert('‰∏ä‰º†Â§±Ë¥•: ' + result.message)
                }
            } catch (error) {
                alert('‰∏ä‰º†Âá∫Èîô: ' + error.message)
            }
        }

        function deleteJson(filename) {
            if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ ${filename} ÂêóÔºüÊ≠§Êìç‰Ωú‰ªÖÂà†Èô§ÂØπÂ∫îÁöÑ JSON Êñá‰ª∂ÔºåÂÖ∂‰ªñÂÖ≥ËÅîÊñá‰ª∂Â∞ÜË¢´‰øùÁïô„ÄÇ`)) {
                fetch('/delete_json', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename })
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            alert('Âà†Èô§ÊàêÂäü')
                            location.reload()
                        } else {
                            alert('Âà†Èô§Â§±Ë¥•: ' + data.message)
                        }
                    })
            }
        }

        function handleLyricsUpload() {
            const fileInput = document.getElementById('lyricsUpload')
            const file = fileInput.files[0]
            if (!file) return

            const formData = new FormData()
            formData.append('file', file)

            fetch('/upload_lyrics', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('lyricsPath').value = data.filename
                        updateLyricsPath(0)
                        // ÈöêËóèÊ≠åËØçÁõ∏ÂÖ≥ÊåâÈíÆ
                        document.querySelector('.save-all-btn').style.display = 'none'
                        document.querySelector('button[onclick="saveLyrics(0)"]').style.display = 'none'
                        alert('Ê≠åËØçÂ∑≤‰∏ä‰º†ÊàêÂäüÔºåÁÇπÂáª"ÂÖ≥Èó≠"ÂêéÁîüÊïà')
                    } else {
                        alert('‰∏ä‰º†Â§±Ë¥•: ' + data.message)
                    }
                })
                .catch(error => {
                    console.error('Error:', error)
                    alert('‰∏ä‰º†Â§±Ë¥•')
                })
        }

        function handleTranslationUpload() {
            const fileInput = document.getElementById('translationUpload')
            const file = fileInput.files[0]
            if (!file) return

            const formData = new FormData()
            formData.append('file', file)

            fetch('/upload_translation', {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        document.getElementById('translationPath').value = data.filename
                        updateLyricsPath(1)
                        // ÈöêËóèÁøªËØëÁõ∏ÂÖ≥ÊåâÈíÆ
                        document.querySelector('.save-all-btn').style.display = 'none'
                        document.querySelector('button[onclick="saveLyrics(1)"]').style.display = 'none'
                        alert('Ê≠åËØçÂ∑≤‰∏ä‰º†ÊàêÂäüÔºåÁÇπÂáª"ÂÖ≥Èó≠"ÂêéÁîüÊïà')
                    } else {
                        alert('‰∏ä‰º†Â§±Ë¥•: ' + data.message)
                    }
                })
                .catch(error => {
                    console.error('Error:', error)
                    alert('‰∏ä‰º†Â§±Ë¥•')
                })
        }

        async function showBackupVersions(filename) {
            currentRestoreFile = filename
            const modal = document.getElementById('backupModal')
            const backupList = document.getElementById('backupList')
            backupList.innerHTML = '<div class="loading">Âä†ËΩΩ‰∏≠...</div>'

            try {
                const response = await fetch('/get_backups', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: normalizeStaticUrl(filename) })
                })
                const data = await response.json()

                backupList.innerHTML = ''
                if (data.backups && data.backups.length > 0) {
                    data.backups.forEach(backup => {
                        const btn = document.createElement('button')
                        btn.className = 'action-button'
                        btn.style.margin = '5px'
                        btn.innerHTML = `
                            ${backup.time}
                            <div style="font-size:0.8em; color:#666;">${backup.path.split('/').pop()}</div>
                        `
                        btn.onclick = () => restoreToVersion(backup.path)
                        backupList.appendChild(btn)
                    })
                } else {
                    backupList.innerHTML = '<div>ÊöÇÊó†ÂéÜÂè≤ÁâàÊú¨</div>'
                }
                modal.style.display = 'block'
            } catch (error) {
                alert('Ëé∑ÂèñÂ§á‰ªΩÂ§±Ë¥•: ' + error)
            }
        }

        function closeBackupModal() {
            document.getElementById('backupModal').style.display = 'none'
        }

        async function quickRestore(filename) {
            if (confirm(`Á°ÆÂÆöË¶ÅÊÅ¢Â§çÂà∞ÊúÄÊñ∞Â§á‰ªΩÁâàÊú¨ÂêóÔºü`)) {
                try {
                    const response = await fetch('/restore_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file_path: normalizeStaticUrl(filename) })
                    })
                    const result = await response.json()
                    if (result.status === 'success') {
                        alert('ÊÅ¢Â§çÊàêÂäüÔºÅ')
                        location.reload()
                    }
                } catch (error) {
                    alert('ÊÅ¢Â§çÂ§±Ë¥•: ' + error)
                }
            }
        }

        async function restoreToVersion(backupPath) {
            if (confirm(`Á°ÆÂÆöË¶ÅÊÅ¢Â§çÂà∞ËØ•ÁâàÊú¨ÂêóÔºü\n${backupPath}`)) {
                try {
                    const response = await fetch('/restore_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ file_path: backupPath })
                    })
                    const result = await response.json()
                    if (result.status === 'success') {
                        alert('ÊÅ¢Â§çÊàêÂäüÔºÅ')
                        location.reload()
                    }
                } catch (error) {
                    alert('ÊÅ¢Â§çÂ§±Ë¥•: ' + error)
                }
            }
        }

        function checkFileExtension() {
            const lyricsPath = document.getElementById('lyricsPath').value;
            const mergeLQEButton = document.getElementById('mergeLQEButton');
            if (lyricsPath && !lyricsPath.toLowerCase().endsWith('.ttml')) {
                mergeLQEButton.style.display = 'inline-block';
            } else {
                mergeLQEButton.style.display = 'none';
            }
        }

        function mergeToLQE() {
            const lyricsPath = document.getElementById('lyricsPath').value;
            const translationPath = document.getElementById('translationPath').value;
            
            if (!lyricsPath || !translationPath) {
                alert('ËØ∑Á°Æ‰øùÊ≠åËØçÂíåÁøªËØëÊñá‰ª∂Ë∑ØÂæÑÈÉΩÂ∑≤ËÆæÁΩÆÔºÅ');
                return;
            }

            fetch('/merge_to_lqe', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    lyricsPath: lyricsPath,
                    translationPath: translationPath
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Ëá™Âä®‰∏ãËΩΩ‰∏∫.lqeÊñá‰ª∂
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    // Êñá‰ª∂ÂêçÂèØÊ†πÊçÆÊ≠åËØçÊñá‰ª∂ÂêçËá™Âä®ÁîüÊàê
                    let baseName = lyricsPath.replace(/\.[^/.]+$/, '');
                    a.download = baseName + '.lqe';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    alert('LQEÊñá‰ª∂Â∑≤ÂØºÂá∫ÔºÅ');
                } else {
                    alert('ÂêàÂπ∂Â§±Ë¥•Ôºö' + data.message);
                }
            })
            .catch(error => {
                alert('ÂêàÂπ∂Â§±Ë¥•Ôºö' + error);
            });
        }

        // Âú®Êõ¥Êñ∞Ë∑ØÂæÑÊó∂Ê£ÄÊü•Êñá‰ª∂Êâ©Â±ïÂêç
        const originalUpdateLyricsPath = updateLyricsPath;
        updateLyricsPath = function(index) {
            originalUpdateLyricsPath(index);
            setTimeout(checkFileExtension, 100); // Âª∂ËøüÊ£ÄÊü•‰ª•Á°Æ‰øùË∑ØÂæÑÂ∑≤Êõ¥Êñ∞
        };

        // È°µÈù¢Âä†ËΩΩÊó∂Ê£ÄÊü•‰∏ÄÊ¨°
        window.addEventListener('DOMContentLoaded', function() {
            checkFileExtension();
        });
        // Ê≠åËØçË∑ØÂæÑËæìÂÖ•ÂèòÂåñÊó∂Ê£ÄÊü•
        document.getElementById('lyricsPath').addEventListener('input', checkFileExtension);

        function detectLyricsExtension(content = '') {
            const text = (content || '').trim();
            if (!text) {
                return '';
            }
            if (/<tt\b|<\/tt>/i.test(text)) {
                return '.ttml';
            }
            if (/\[\d{1,2}:\d{2}(?:\.\d{1,3})?\]/.test(text)) {
                return '.lrc';
            }
            if (/\[\d+\s*,\s*\d+\]/.test(text)) {
                return '.qrc';
            }
            if (/\[\d+\]/.test(text)) {
                return '.lys';
            }
            return '';
        }

        async function ensureLysContentForProcessing(actionLabel = 'Â§ÑÁêÜ') {
            const lyricsEditor = document.getElementById('lyricsEditor');
            const lyricsPathInput = document.getElementById('lyricsPath');

            const lyricsContent = lyricsEditor ? lyricsEditor.value : '';
            const lyricsPath = lyricsPathInput ? lyricsPathInput.value : '';

            const pathExtension = (lyricsPath.match(/\.[^.]+$/) || [])[0]?.toLowerCase() || '';
            const contentExtension = detectLyricsExtension(lyricsContent);
            const shouldConvert = pathExtension === '.ttml' && contentExtension === '.ttml';

            if (!shouldConvert) {
                return { content: lyricsContent, path: lyricsPath, converted: false };
            }

            const relativePath = stripSongsPrefix(lyricsPath).trim();
            if (!relativePath) {
                throw new Error('Ê£ÄÊµãÂà∞TTMLÊ≠åËØçÔºå‰ΩÜÊñá‰ª∂Ë∑ØÂæÑ‰∏∫Á©∫ÔºåÊó†Ê≥ïËΩ¨Êç¢');
            }

            try {
                const convertResp = await fetch('/convert_ttml_by_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: relativePath })
                });
                const convertData = await convertResp.json();
                if (convertData.status !== 'success' || !convertData.lyricPath) {
                    throw new Error(convertData.message || 'TTMLËΩ¨Êç¢Â§±Ë¥•');
                }

                const lysResp = await fetch('/get_lyrics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: convertData.lyricPath })
                });
                const lysData = await lysResp.json();
                if (lysData.status !== 'success' || !lysData.content) {
                    throw new Error(lysData.message || 'Êó†Ê≥ïËØªÂèñËΩ¨Êç¢ÂêéÁöÑÊ≠åËØç');
                }

                console.log(`[TTML] ${actionLabel}ÂâçÂ∑≤‰∏¥Êó∂ËΩ¨Êç¢‰∏∫LYS`, {
                    path: convertData.lyricPath
                });

                return {
                    content: lysData.content,
                    path: stripSongsPrefix(convertData.lyricPath),
                    rawPath: convertData.lyricPath,
                    converted: true
                };
            } catch (error) {
                console.error('TTML‰∏¥Êó∂ËΩ¨Êç¢Â§±Ë¥•Ôºö', error);
                const message = error && error.message ? error.message : 'TTML‰∏¥Êó∂ËΩ¨Êç¢Â§±Ë¥•';
                throw new Error(`Ê£ÄÊµãÂà∞TTMLÊ≠åËØçÔºå${actionLabel}ÂâçËΩ¨Êç¢Â§±Ë¥•Ôºö${message}`);
            }
        }

        function stripBracketCharacters(text = '') {
            if (!text) {
                return '';
            }
            return text
                .replace(/[()ÔºàÔºâ\[\]„Äê„Äë]/g, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
        }

        function preprocessLyricsLinesForPrompt(rawContent = '', stripBracketsEnabled = false) {
            const lines = (rawContent || '').split('\n');
            const cleaned = [];
            for (const line of lines) {
                let text = line.replace(/\[.*?\]/g, '');
                text = text.replace(/\([0-9,]+\)/g, '');
                text = text.trim();
                if (!text) {
                    continue;
                }
                if (stripBracketsEnabled) {
                    text = stripBracketCharacters(text);
                }
                if (text) {
                    cleaned.push(text);
                }
            }
            return cleaned;
        }

        function setCurrentFileNameAsLyrics() {
            const currentFileName = document.getElementById('currentFileName').textContent;
            const lyricsPathInput = document.getElementById('lyricsPath');
            const lyricsContent = document.getElementById('lyricsEditor').value;

            const existingExtension = (lyricsPathInput.value.match(/\.[^.]+$/) || [])[0] || '';
            let extension = detectLyricsExtension(lyricsContent) || existingExtension || '.lys';

            if (!extension.startsWith('.')) {
                extension = `.${extension}`;
            }

            lyricsPathInput.value = currentFileName + extension;
            checkFileExtension();
        }

        function setCurrentFileNameAsTranslation() {
            const currentFileName = document.getElementById('currentFileName').textContent;
            const translationPathInput = document.getElementById('translationPath');
            const translationContent = document.getElementById('translationEditor').value;

            let extension = detectLyricsExtension(translationContent) || '.lrc';
            if (extension === '.lys') {
                // ÁøªËØëÈªòËÆ§‰ΩøÁî®ÈÄêË°åÊ†ºÂºè
                extension = '.lrc';
            }
            if (!extension.startsWith('.')) {
                extension = `.${extension}`;
            }

            translationPathInput.value = currentFileName + extension;
        }

        function showSoftNotice(message) {
            let notice = document.getElementById('softNotice');
            if (!notice) {
                notice = document.createElement('div');
                notice.id = 'softNotice';
                notice.className = 'soft-notice';
                document.body.appendChild(notice);
            }
            notice.textContent = message;
            notice.classList.add('is-visible');
            clearTimeout(notice._hideTimer);
            notice._hideTimer = setTimeout(() => {
                notice.classList.remove('is-visible');
            }, 1200);
        }

        function copyFileNameText(textEl) {
            const fileName = textEl.textContent.trim();
            navigator.clipboard.writeText(fileName).then(() => {
                showSoftNotice('Â∑≤Â§çÂà∂Êñá‰ª∂Âêç');
            });
        }

        function copyCurrentFileName() {
            const fileName = document.getElementById('currentFileName').textContent;
            const button = document.querySelector('h2 .copy-btn');
            navigator.clipboard.writeText(fileName).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úì';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 1000);
            });
        }

        async function extractTimestamps() {
            const lyricsPath = document.getElementById('lyricsPath').value;
            const lyricsContent = document.getElementById('lyricsEditor').value;

            console.log('ÂºÄÂßãÊèêÂèñÊó∂Èó¥Êà≥...');
            console.log('Ê≠åËØçË∑ØÂæÑ:', lyricsPath);
            console.log('Ê≠åËØçÂÜÖÂÆπÈïøÂ∫¶:', lyricsContent.length);

            const allowedExtensions = ['.lys', '.qrc', '.lrc'];
            const pathExtension = (lyricsPath.match(/\.[^.]+$/) || [])[0]?.toLowerCase() || '';
            const detectedExtension = detectLyricsExtension(lyricsContent);
            let resolvedExtension = allowedExtensions.includes(pathExtension)
                ? pathExtension
                : (allowedExtensions.includes(detectedExtension) ? detectedExtension : '');
            let contentForExtraction = lyricsContent;

            const isTtml = pathExtension === '.ttml' && detectedExtension === '.ttml';
            if (isTtml) {
                try {
                    const conversion = await ensureLysContentForProcessing('ÊèêÂèñÊó∂Èó¥Êà≥');
                    contentForExtraction = conversion.content;
                    resolvedExtension = '.lys';
                    console.log('Ê£ÄÊµãÂà∞TTMLÊ≠åËØçÔºåÂ∑≤‰∏¥Êó∂ËΩ¨Êç¢‰∏∫LYSÁî®‰∫éÊó∂Èó¥Êà≥ÊèêÂèñ');
                } catch (error) {
                    console.error('TTMLËΩ¨Êç¢Â§±Ë¥•ÔºåÊó†Ê≥ïÊèêÂèñÊó∂Èó¥Êà≥Ôºö', error);
                    alert(error.message || 'TTMLËΩ¨Êç¢Â§±Ë¥•ÔºåÊó†Ê≥ïÊèêÂèñÊó∂Èó¥Êà≥');
                    return;
                }
            } else if (!resolvedExtension) {
                console.error('Êñá‰ª∂Ê†ºÂºèÈîôËØØÔºö‰∏çÊîØÊåÅÁöÑÊ≠åËØçÊ†ºÂºè');
                alert('ËØ∑ÂÖàÈÄâÊã© LYS/QRC/LRC Ê†ºÂºèÁöÑÊ≠åËØçÊñá‰ª∂ÔºÅ');
                return;
            }

            try {
                console.log('Ê≠£Âú®ÂèëÈÄÅËØ∑Ê±ÇÂà∞ÊúçÂä°Âô®...');
                const response = await fetch('/extract_timestamps', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: contentForExtraction
                    })
                });
                
                console.log('ÊúçÂä°Âô®ÂìçÂ∫îÁä∂ÊÄÅ:', response.status);
                const data = await response.json();
                console.log('ÊúçÂä°Âô®ËøîÂõûÊï∞ÊçÆ:', data);
                
                if (data.status === 'success') {
                    console.log('ÊàêÂäüËé∑ÂèñÊó∂Èó¥Êà≥ÔºåÊï∞Èáè:', data.timestamps.length);
                    const translationEditor = document.getElementById('translationEditor');
                    const rawTranslation = translationEditor.value || '';
                    const translationLines = rawTranslation
                        .split(/\r?\n/)
                        .map(line => line.replace(/^\s*\d+[\.„ÄÅÔºé:Ôºö]?\s*/, '').trim())
                        .filter(line => line.length > 0);

                    if (translationLines.length === data.timestamps.length && translationLines.length > 0) {
                        const merged = data.timestamps.map((ts, idx) => `${ts}${translationLines[idx] ? ' ' + translationLines[idx] : ''}`);
                        translationEditor.value = merged.join('\n');
                        console.log('Êó∂Èó¥Êà≥Â∑≤‰∏éÁøªËØëÈÄêË°åÂêàÂπ∂');
                    } else {
                        // Ë°åÊï∞‰∏ç‰∏ÄËá¥Êó∂Áª¥ÊåÅÊóßË°å‰∏∫Ôºå‰ªÖËæìÂá∫Êó∂Èó¥Êà≥‰æõÁî®Êà∑ÊâãÂä®Á≤òË¥¥
                        translationEditor.value = data.timestamps.join('\n');
                        console.warn(`ÁøªËØëË°åÊï∞(${translationLines.length})‰∏éÊó∂Èó¥Êà≥(${data.timestamps.length})‰∏ç‰∏ÄËá¥ÔºåÂ∑≤‰ªÖÂÜôÂÖ•Êó∂Èó¥Êà≥`);
                    }
                } else {
                    console.error('ÊèêÂèñÊó∂Èó¥Êà≥Â§±Ë¥•:', data.message);
                    alert('ÊèêÂèñÊó∂Èó¥Êà≥Â§±Ë¥•Ôºö' + data.message);
                }
            } catch (error) {
                console.error('ÊèêÂèñÊó∂Èó¥Êà≥Êó∂Âá∫ÈîôÔºö', error);
                console.error('ÈîôËØØËØ¶ÊÉÖ:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                alert('ÊèêÂèñÊó∂Èó¥Êà≥Êó∂Âá∫ÈîôÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ');
            }
        }

        async function extractLyrics() {
            const lyricsContent = document.getElementById('lyricsEditor').value;
            
            try {
                const response = await fetch('/extract_lyrics', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: lyricsContent
                    })
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    // Â∞ÜÊèêÂèñÁöÑÊ≠åËØçÂ§çÂà∂Âà∞Ââ™Ë¥¥Êùø
                    await navigator.clipboard.writeText(data.content);
                    alert('Â∑≤ÊàêÂäüÊèêÂèñÊ≠åËØçÂπ∂Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ');
                } else {
                    alert('ÊèêÂèñÊ≠åËØçÂ§±Ë¥•Ôºö' + data.message);
                }
            } catch (error) {
                console.error('ÊèêÂèñÊ≠åËØçÊó∂Âá∫ÈîôÔºö', error);
                alert('ÊèêÂèñÊ≠åËØçÊó∂Âá∫ÈîôÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ');
            }
        }

        function updateTranslationStatus(message, type = 'info', suspectLines = []) {
            const statusEl = document.getElementById('translationStatusMessage');
            if (!statusEl) {
                return;
            }

            statusEl.style.display = 'none';
            statusEl.className = 'status-message';
            statusEl.classList.remove('translation-in-progress');
            statusEl.innerHTML = '';

            if (!message) {
                return;
            }

            statusEl.classList.add(`status-${type}`);
            const isProgressMessage = typeof message === 'object' && message !== null && Array.isArray(message.stages);
            const appendSuspectLines = () => {
                if (type !== 'error' || !Array.isArray(suspectLines) || suspectLines.length === 0) {
                    return;
                }

                const reminder = document.createElement('div');
                reminder.textContent = 'ÈúÄË¶ÅÊ£ÄÊü•ÁöÑË°åÔºö';
                reminder.style.marginTop = '6px';
                statusEl.appendChild(reminder);

                const list = document.createElement('ul');
                list.className = 'status-message__list';
                suspectLines.slice(0, 5).forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = `Á¨¨${item.line_number}Ë°åÔºö${item.line_content}`;
                    list.appendChild(li);
                });
                statusEl.appendChild(list);

                if (suspectLines.length > 5) {
                    const extra = document.createElement('div');
                    extra.textContent = `ËøòÊúâ ${suspectLines.length - 5} Ë°åÂèØËÉΩÂ≠òÂú®ÈóÆÈ¢òÔºåËØ∑ÁªßÁª≠Ê£ÄÊü•Ê≠åËØç„ÄÇ`;
                    extra.style.marginTop = '4px';
                    statusEl.appendChild(extra);
                }
            };

            if (isProgressMessage) {
                const stages = Array.isArray(message.stages) ? message.stages : [];
                const activeStage = stages.find(stage => stage && stage.state === 'active');
                const summaryText = typeof message.summary === 'string' && message.summary.trim().length > 0
                    ? message.summary.trim()
                    : (activeStage && activeStage.label ? activeStage.label : (type === 'info' ? 'Ê≠£Âú®ÁøªËØë ¬∑ ËØ∑Ê±ÇÊÄùËÄÉÈò∂ÊÆµ' : 'ÁøªËØëËøõÂ∫¶'));
                const useShine = type === 'info' && message.useShine !== false;

                if (useShine && summaryText) {
                    statusEl.classList.add('translation-in-progress');
                    const shineLink = document.createElement('a');
                    shineLink.href = '#';
                    shineLink.className = 'btn-shine';
                    shineLink.textContent = summaryText;
                    statusEl.appendChild(shineLink);
                } else if (summaryText) {
                    const summaryBlock = document.createElement('div');
                    summaryBlock.className = 'status-message__summary';
                    summaryBlock.textContent = summaryText;
                    statusEl.appendChild(summaryBlock);
                }

                if (stages.length > 0) {
                    const list = document.createElement('ul');
                    list.className = 'status-progress';
                    stages.forEach(stage => {
                        if (!stage) {
                            return;
                        }
                        const li = document.createElement('li');
                        const stateClass = stage.state ? `status-progress__item--${stage.state}` : 'status-progress__item--pending';
                        li.className = `status-progress__item ${stateClass}`;

                        const label = document.createElement('span');
                        label.className = 'status-progress__label';
                        label.textContent = stage.label || stage.key || '';
                        li.appendChild(label);

                        if (stage.description) {
                            const desc = document.createElement('div');
                            desc.className = 'status-progress__desc';
                            desc.textContent = stage.description;
                            li.appendChild(desc);
                        }

                        list.appendChild(li);
                    });
                    statusEl.appendChild(list);
                }

                if (message.details && Array.isArray(message.details)) {
                    message.details.forEach(detail => {
                        const detailBlock = document.createElement('div');
                        detailBlock.textContent = detail;
                        statusEl.appendChild(detailBlock);
                    });
                }

                appendSuspectLines();
            } else {
                const isTranslating = type === 'info' && typeof message === 'string' && message.includes('Ê≠£Âú®ÁøªËØë');

                if (isTranslating) {
                    statusEl.classList.add('translation-in-progress');
                    const shineLink = document.createElement('a');
                    shineLink.href = '#';
                    shineLink.className = 'btn-shine';
                    shineLink.textContent = 'Ê≠£Âú®ÁøªËØë ¬∑ ËØ∑Ê±ÇÊÄùËÄÉÈò∂ÊÆµ';
                    statusEl.appendChild(shineLink);
                } else {
                    const messageBlock = document.createElement('div');
                    messageBlock.textContent = message;
                    statusEl.appendChild(messageBlock);
                }

                appendSuspectLines();
            }

            statusEl.style.display = 'block';
        }

        function highlightSuspectLinesInEditor(suspectLines = []) {
            const editor = document.getElementById('lyricsEditor');
            if (!editor) {
                return;
            }

            if (!Array.isArray(suspectLines) || suspectLines.length === 0) {
                editor.classList.remove('error-highlight');
                return;
            }

            editor.classList.add('error-highlight');
            const targetLine = suspectLines[0]?.line_number;
            if (!targetLine || targetLine < 1) {
                return;
            }

            const lines = editor.value.split('\n');
            if (targetLine > lines.length) {
                return;
            }

            let start = 0;
            for (let i = 0; i < targetLine - 1; i++) {
                start += lines[i].length + 1;
            }
            const end = start + lines[targetLine - 1].length;

            editor.focus();
            if (typeof editor.setSelectionRange === 'function') {
                editor.setSelectionRange(start, end);
            }

            const approxLineHeight = editor.scrollHeight / Math.max(lines.length, 1);
            editor.scrollTop = Math.max(0, approxLineHeight * (targetLine - 3));
        }

        async function translateLyrics() {
            const translateBtn = document.querySelector('button[onclick="translateLyrics()"]');
            const originalBtnText = translateBtn.textContent;
            highlightSuspectLinesInEditor([]);
            updateTranslationStatus('');
            lastThinkingSummary = '';

            const translationStages = [
                { key: 'lyricsPrep', label: 'Ê≠åËØçÈ¢ÑÂ§ÑÁêÜÈò∂ÊÆµ', state: 'active', description: 'Ê£ÄÊü•Ê≠åËØçÂÜÖÂÆπ...' },
                { key: 'thinkingRequest', label: 'ËØ∑Ê±ÇÊÄùËÄÉÈò∂ÊÆµ', state: 'pending' },
                { key: 'thinkingOutput', label: 'ËæìÂá∫ÊÄùËÄÉÈò∂ÊÆµ', state: 'pending' },
                { key: 'translationRequest', label: 'ËØ∑Ê±ÇÁøªËØëÈò∂ÊÆµ', state: 'pending' },
                { key: 'translationOutput', label: 'ËæìÂá∫ÁøªËØëÈò∂ÊÆµ', state: 'pending' },
                { key: 'postProcessing', label: 'ÁøªËØëÂ§ÑÁêÜÈò∂ÊÆµ', state: 'pending' }
            ];
            const stageMap = new Map(translationStages.map(stage => [stage.key, stage]));
            const getActiveStage = () => translationStages.find(stage => stage.state === 'active');
            let stageDirty = false;

            const markDirty = (changed) => {
                if (changed) {
                    stageDirty = true;
                }
                return changed;
            };

            const renderStages = (summary, statusType = 'info', options = {}) => {
                const activeStage = getActiveStage();
                let summaryText = summary;
                if (!summaryText) {
                    if (statusType === 'info' && activeStage) {
                        summaryText = `Ê≠£Âú®ÁøªËØë ¬∑ ${activeStage.label}`;
                    } else if (activeStage) {
                        summaryText = activeStage.label;
                    } else if (statusType === 'success') {
                        summaryText = 'ÁøªËØëÂÆåÊàê';
                    } else if (statusType === 'error') {
                        const errorStage = translationStages.find(stage => stage.state === 'error');
                        summaryText = errorStage ? `${errorStage.label}Âá∫Áé∞ÈóÆÈ¢ò` : 'ÁøªËØëÂ§±Ë¥•';
                    } else {
                        summaryText = 'ÁøªËØëÁä∂ÊÄÅ';
                    }
                }

                updateTranslationStatus({
                    summary: summaryText,
                    stages: translationStages.map(stage => ({
                        key: stage.key,
                        label: stage.label,
                        state: stage.state,
                        description: stage.description
                    })),
                    useShine: options.useShine !== undefined ? options.useShine : (statusType === 'info' && Boolean(activeStage))
                }, statusType, options.suspectLines);

                stageDirty = false;
            };

            const activateStage = (key, description) => {
                const stage = stageMap.get(key);
                if (!stage) {
                    return false;
                }
                if (stage.state === 'error') {
                    if (description !== undefined && stage.description !== description) {
                        stage.description = description;
                        return true;
                    }
                    return false;
                }

                let changed = false;
                translationStages.forEach(item => {
                    if (item.key !== key && item.state === 'active') {
                        item.state = 'success';
                        changed = true;
                    }
                });
                if (stage.state !== 'active') {
                    stage.state = 'active';
                    changed = true;
                }
                if (description !== undefined && stage.description !== description) {
                    stage.description = description;
                    changed = true;
                }
                return changed;
            };

            const completeStage = (key, description) => {
                const stage = stageMap.get(key);
                if (!stage) {
                    return false;
                }
                let changed = false;
                if (stage.state !== 'error' && stage.state !== 'success') {
                    stage.state = 'success';
                    changed = true;
                }
                if (description !== undefined && stage.description !== description) {
                    stage.description = description;
                    changed = true;
                }
                return changed;
            };

            const failStage = (key, description) => {
                const stage = stageMap.get(key);
                if (!stage) {
                    return false;
                }
                let changed = false;
                if (stage.state !== 'error') {
                    stage.state = 'error';
                    changed = true;
                }
                if (description !== undefined && stage.description !== description) {
                    stage.description = description;
                    changed = true;
                }
                return changed;
            };

            const updateStageDescription = (key, description) => {
                const stage = stageMap.get(key);
                if (!stage) {
                    return false;
                }
                if (stage.description !== description) {
                    stage.description = description;
                    return true;
                }
                return false;
            };

            const getStageState = (key) => {
                const stage = stageMap.get(key);
                return stage ? stage.state : undefined;
            };

            const flushStages = (summary, statusType = 'info', options = {}) => {
                const hasOptions = options && (Array.isArray(options.suspectLines) && options.suspectLines.length > 0 || options.useShine !== undefined);
                if (!stageDirty && !summary && statusType === 'info' && !hasOptions) {
                    return;
                }
                renderStages(summary, statusType, options || {});
            };

            renderStages('Ê≠£Âú®ÂáÜÂ§áÁøªËØë ¬∑ Ê≠åËØçÈ¢ÑÂ§ÑÁêÜÈò∂ÊÆµ');

            try {
                const lyricsPath = document.getElementById('lyricsPath').value;
                const lyricsContent = document.getElementById('lyricsEditor').value;
                if (!lyricsContent) {
                    markDirty(failStage('lyricsPrep', 'Ê≠åËØçÂÜÖÂÆπ‰∏∫Á©∫ÔºåÊó†Ê≥ïÁªßÁª≠'));
                    flushStages('Ê≠åËØçÂÜÖÂÆπ‰∏∫Á©∫ÔºåÊó†Ê≥ïÁªßÁª≠', 'error', { useShine: false });
                    alert('ËØ∑ÂÖàËæìÂÖ•Ê≠åËØçÂÜÖÂÆπÔºÅ');
                    return;
                }

                const apiKey = localStorage.getItem('aiApiKey');
                if (!apiKey) {
                    markDirty(failStage('lyricsPrep', 'Áº∫Â∞ëAIÂØÜÈí•ÔºåÊó†Ê≥ïÁªßÁª≠'));
                    flushStages('Áº∫Â∞ëAIÂØÜÈí•ÔºåÊó†Ê≥ïÁªßÁª≠', 'error', { useShine: false });
                    alert('ËØ∑ÂÖàÂú®AIËÆæÁΩÆ‰∏≠ËÆæÁΩÆAPIÂØÜÈí•ÔºÅ');
                    return;
                }

                const pathExtension = (lyricsPath.match(/\.[^.]+$/) || [])[0]?.toLowerCase() || '';
                const detectedExtension = detectLyricsExtension(lyricsContent);
                let processedLyricsContent = lyricsContent;

                if (pathExtension === '.ttml' && detectedExtension === '.ttml') {
                    markDirty(updateStageDescription('lyricsPrep', 'Ê£ÄÊµãÂà∞TTMLÊ≠åËØçÔºåÊ≠£Âú®‰∏¥Êó∂ËΩ¨Êç¢‰∏∫LYS...'));
                    flushStages();
                    const conversion = await ensureLysContentForProcessing('ÁøªËØë');
                    processedLyricsContent = conversion.content;
                    markDirty(updateStageDescription('lyricsPrep', 'TTMLÂ∑≤‰∏¥Êó∂ËΩ¨‰∏∫LYSÔºåÁªßÁª≠Â§ÑÁêÜ'));
                }

                console.log('ÂºÄÂßãÁøªËØëËøáÁ®ã...');
                console.log('Ê≠åËØçÂÜÖÂÆπÈïøÂ∫¶:', processedLyricsContent.length);
                const lyricLines = processedLyricsContent.split('\n').length;
                console.log('Ê≠åËØçË°åÊï∞:', lyricLines);

                translateBtn.textContent = 'ÁøªËØë‰∏≠...';
                translateBtn.disabled = true;

                markDirty(completeStage('lyricsPrep', `Â∑≤ËØªÂèñ ${lyricLines} Ë°åÊ≠åËØç`));

                const translationEditor = document.getElementById('translationEditor');
                translationEditor.value = '';

                console.log('ÂèëÈÄÅÁøªËØëËØ∑Ê±ÇÂà∞ÊúçÂä°Âô®...');
                const systemPrompt = localStorage.getItem('aiSystemPrompt');
                const provider = localStorage.getItem('aiProvider') || 'deepseek';
                const baseUrl = localStorage.getItem('aiBaseUrl') || 'https://api.deepseek.com';
                const model = localStorage.getItem('aiModel') || 'deepseek-reasoner';
                const expectReasoning = localStorage.getItem('aiExpectReasoning') === 'true';
                const compatModeStorage = localStorage.getItem('aiCompatMode');
                const compatMode = compatModeStorage ? compatModeStorage === 'true' : false;
                const thinkingEnabledStorage = localStorage.getItem('aiThinkingEnabled');
                const thinkingEnabled = thinkingEnabledStorage ? thinkingEnabledStorage === 'true' : true;
                const thinkingApiKey = localStorage.getItem('aiThinkingApiKey') || '';
                const thinkingProviderStored = localStorage.getItem('aiThinkingProvider');
                const thinkingBaseUrlStored = localStorage.getItem('aiThinkingBaseUrl');
                const thinkingModelStored = localStorage.getItem('aiThinkingModel');
                const thinkingPrompt = localStorage.getItem('aiThinkingPrompt');
                const stripBracketsStored = localStorage.getItem('aiStripBrackets');
                const thinkingProvider = thinkingProviderStored && thinkingProviderStored.length > 0 ? thinkingProviderStored : provider;
                const thinkingBaseUrl = thinkingBaseUrlStored && thinkingBaseUrlStored.length > 0 ? thinkingBaseUrlStored : baseUrl;
                const thinkingModel = thinkingModelStored && thinkingModelStored.length > 0 ? thinkingModelStored : model;
                const stripBrackets = stripBracketsStored ? stripBracketsStored === 'true' : false;

                let thinkingRequestAcknowledged = !thinkingEnabled;
                let thinkingOutputCompleted = !thinkingEnabled;
                let translationRequestActivated = false;
                let translationRequestAcknowledged = false;
                let translationOutputActivated = false;
                let postProcessingActivated = false;

                if (thinkingEnabled) {
                    markDirty(activateStage('thinkingRequest', `ÂáÜÂ§áËØ∑Ê±ÇÊÄùËÄÉÊ®°ÂûãÔºà${thinkingProvider}/${thinkingModel}Ôºâ...`));
                } else {
                    markDirty(completeStage('thinkingRequest', 'Â∑≤Ë∑≥ËøáÔºàÊÄùËÄÉÂäüËÉΩÂÖ≥Èó≠Ôºâ'));
                    markDirty(completeStage('thinkingOutput', 'Â∑≤Ë∑≥ËøáÔºàÊÄùËÄÉÂäüËÉΩÂÖ≥Èó≠Ôºâ'));
                    markDirty(activateStage('translationRequest', `ÂáÜÂ§áËØ∑Ê±ÇÁøªËØëÊ®°ÂûãÔºà${provider}/${model}Ôºâ...`));
                    thinkingOutputCompleted = true;
                    translationRequestActivated = true;
                }

                flushStages();

                const response = await fetch('/translate_lyrics', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: processedLyricsContent,
                        api_key: apiKey,
                        system_prompt: systemPrompt,
                        provider: provider,
                        base_url: baseUrl,
                        model: model,
                        expect_reasoning: expectReasoning,
                        compat_mode: compatMode,
                        thinking_enabled: thinkingEnabled,
                        thinking_api_key: thinkingApiKey,
                        thinking_provider: thinkingProvider,
                        thinking_base_url: thinkingBaseUrl,
                        thinking_model: thinkingModel,
                        thinking_system_prompt: thinkingPrompt,
                        strip_brackets: stripBrackets
                    })
                });

                console.log('ÂºÄÂßãÊé•Êî∂ÊµÅÂºèÂìçÂ∫î...');
                const contentType = response.headers.get('Content-Type') || '';
                if (!response.ok || contentType.includes('application/json')) {
                    let errorData = {};
                    try {
                        errorData = await response.json();
                    } catch (parseError) {
                        console.error('Ëß£ÊûêÈîôËØØÂìçÂ∫îÂ§±Ë¥•:', parseError);
                    }

                    const errorMessage = errorData.message || `ÁøªËØëÂ§±Ë¥•ÔºàHTTP ${response.status}Ôºâ`;
                    const activeStage = getActiveStage();
                    if (activeStage) {
                        markDirty(failStage(activeStage.key, `Â§±Ë¥•Ôºö${errorMessage}`));
                    } else {
                        markDirty(failStage('translationRequest', `Â§±Ë¥•Ôºö${errorMessage}`));
                    }
                    flushStages(errorMessage, 'error', { useShine: false, suspectLines: errorData.suspectLines });
                    highlightSuspectLinesInEditor(errorData.suspectLines || []);
                    if (!errorData.suspectLines || errorData.suspectLines.length === 0) {
                        alert(errorMessage);
                    }
                    return;
                }

                if (!response.body || !response.body.getReader) {
                    markDirty(failStage('translationRequest', 'ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅÊµÅÂºèÂìçÂ∫î'));
                    flushStages('ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅÊµÅÂºèÂìçÂ∫î', 'error', { useShine: false });
                    throw new Error('ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅÊµÅÂºèÂìçÂ∫î„ÄÇ');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let translationContent = '';
                let reasoningContent = '';
                let thinkingContent = '';
                let buffer = '';
                let translationHasTimestamps = true;
                let translationReceived = false;

                const translationEditorUpdater = () => {
                    const sections = [];
                    if (translationContent) {
                        sections.push(translationContent);
                    }
                    if (thinkingContent) {
                        sections.push('Ê≠åÊõ≤ÁêÜËß£:\n' + thinkingContent);
                    }
                    if (reasoningContent) {
                        sections.push('ÊÄùËÄÉËøáÁ®ã:\n' + reasoningContent);
                    }
                    translationEditor.value = sections.join('\n\n');
                };

                const processLine = (line) => {
                    if (!line) {
                        return;
                    }

                    if (line.startsWith('thinking:')) {
                        if (!thinkingRequestAcknowledged && getStageState('thinkingRequest') === 'active') {
                            markDirty(completeStage('thinkingRequest', 'ÊÄùËÄÉËØ∑Ê±ÇÂ∑≤ÂìçÂ∫î'));
                            markDirty(activateStage('thinkingOutput', 'Ê≠£Âú®ÁîüÊàêÊÄùËÄÉÂÜÖÂÆπ...'));
                            thinkingRequestAcknowledged = true;
                        } else if (getStageState('thinkingOutput') === 'pending') {
                            markDirty(activateStage('thinkingOutput', 'Ê≠£Âú®ÁîüÊàêÊÄùËÄÉÂÜÖÂÆπ...'));
                        }

                        try {
                            const content = JSON.parse(line.slice(9));
                        if (content.summary) {
                            thinkingContent = content.summary;
                            lastThinkingSummary = thinkingContent;
                            translationEditorUpdater();
                            if (!thinkingOutputCompleted) {
                                markDirty(completeStage('thinkingOutput', 'ÊÄùËÄÉÂÜÖÂÆπÂ∑≤ÁîüÊàê'));
                                markDirty(activateStage('translationRequest', `ÂáÜÂ§áËØ∑Ê±ÇÁøªËØëÊ®°ÂûãÔºà${provider}/${model}Ôºâ...`));
                                thinkingOutputCompleted = true;
                                    translationRequestActivated = true;
                                }
                            } else if (content.error) {
                                thinkingContent = 'ÊÄùËÄÉÊ®°ÂûãË∞ÉÁî®Â§±Ë¥•Ôºö' + content.error;
                                translationEditorUpdater();
                                markDirty(failStage('thinkingOutput', 'ÊÄùËÄÉÊ®°ÂûãË∞ÉÁî®Â§±Ë¥•'));
                                if (!translationRequestActivated) {
                                    markDirty(activateStage('translationRequest', `ÂáÜÂ§áËØ∑Ê±ÇÁøªËØëÊ®°ÂûãÔºà${provider}/${model}Ôºâ...`));
                                    translationRequestActivated = true;
                                }
                                thinkingOutputCompleted = true;
                            } else {
                                translationEditorUpdater();
                            }
                        } catch (e) {
                            console.error('Ëß£ÊûêÊÄùËÄÉÂÜÖÂÆπÊó∂Âá∫Èîô:', e);
                        }

                        flushStages();
                        return;
                    }

                    if (line.startsWith('reasoning:')) {
                        if (!thinkingRequestAcknowledged && getStageState('thinkingRequest') === 'active') {
                            markDirty(completeStage('thinkingRequest', 'ÊÄùËÄÉËØ∑Ê±ÇÂ∑≤ÂìçÂ∫î'));
                            markDirty(activateStage('thinkingOutput', 'Ê≠£Âú®ÁîüÊàêÊÄùËÄÉÂÜÖÂÆπ...'));
                            thinkingRequestAcknowledged = true;
                        }
                        try {
                            const content = JSON.parse(line.slice(10));
                            if (content.reasoning) {
                                reasoningContent = content.reasoning;
                                translationEditorUpdater();
                                if (!thinkingOutputCompleted) {
                                    markDirty(updateStageDescription('thinkingOutput', 'Ê≠£Âú®Êï¥ÁêÜÊÄùËÄÉËøáÁ®ã...'));
                                }
                                lastThinkingSummary = thinkingContent || reasoningContent || lastThinkingSummary;
                            }
                        } catch (e) {
                            console.error('Ëß£ÊûêÊÄùÁª¥ÈìæÂÜÖÂÆπÊó∂Âá∫Èîô:', e);
                        }

                        flushStages();
                        return;
                    }

                    if (line.startsWith('content:')) {
                        try {
                            const content = JSON.parse(line.slice(8));
                            if (Object.prototype.hasOwnProperty.call(content, 'hasTimestamps')) {
                                translationHasTimestamps = content.hasTimestamps;
                            }

                            if (!translationRequestActivated) {
                                markDirty(activateStage('translationRequest', `ÂáÜÂ§áËØ∑Ê±ÇÁøªËØëÊ®°ÂûãÔºà${provider}/${model}Ôºâ...`));
                                translationRequestActivated = true;
                            }

                            if (!translationRequestAcknowledged) {
                                markDirty(completeStage('translationRequest', 'ÁøªËØëÊúçÂä°Â∑≤ÂìçÂ∫î'));
                                translationRequestAcknowledged = true;
                            }

                            if (!translationOutputActivated) {
                                markDirty(activateStage('translationOutput', 'Ê≠£Âú®ÁîüÊàêÁøªËØëÊñáÊú¨...'));
                                translationOutputActivated = true;
                            }

                            if (content.translations) {
                                translationContent = content.translations.join('\n');
                                translationReceived = true;
                                translationEditorUpdater();
                            }
                        } catch (e) {
                            console.error('Ëß£ÊûêÁøªËØëÂÜÖÂÆπÊó∂Âá∫Èîô:', e);
                        }

                        flushStages();
                        return;
                    }
                };

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;

                    let newlineIndex;
                    while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                        const line = buffer.slice(0, newlineIndex);
                        buffer = buffer.slice(newlineIndex + 1);
                        processLine(line);
                    }
                }

                const finalChunk = decoder.decode();
                if (finalChunk) {
                    buffer += finalChunk;
                }
                if (buffer) {
                    const remainingLines = buffer.split('\n');
                    for (const line of remainingLines) {
                        processLine(line);
                    }
                }

                markDirty(completeStage('translationRequest', 'ÁøªËØëÊµÅÁ®ãÂ∑≤ÁªìÊùü'));
                markDirty(completeStage('translationOutput', translationReceived ? 'ÁøªËØëÊñáÊú¨Êé•Êî∂ÂÆåÊØï' : 'Êú™Êé•Êî∂Âà∞ÁøªËØëÊñáÊú¨'));
                if (!postProcessingActivated) {
                    markDirty(activateStage('postProcessing', 'Ê≠£Âú®ÂÜôÂÖ•ÁøªËØëÂÜÖÂÆπ...'));
                    postProcessingActivated = true;
                }
                markDirty(completeStage('postProcessing', translationReceived ? 'ÁøªËØëÂÜÖÂÆπÂ∑≤ÂÜôÂÖ•ÁºñËæëÂô®' : 'ÁøªËØëÂÜÖÂÆπ‰∏∫Á©∫'));
                flushStages();

                const successMessage = (!translationHasTimestamps && translationReceived)
                    ? 'ÁøªËØëÂÆåÊàêÔºàÂéüÂßãÊ≠åËØçÊó†Êó∂Èó¥Êà≥ÔºåÂ∑≤Ë∑≥ËøáÊó∂Èó¥Êà≥Ê∑ªÂä†Ôºâ'
                    : 'ÁøªËØëÂÆåÊàêÔºÅ';

                flushStages(successMessage, 'success', { useShine: false });
                highlightSuspectLinesInEditor([]);
                console.log('ÁøªËØëÂÆåÊàê');

            } catch (error) {
                console.error('ÁøªËØëÂá∫ÈîôÔºö', error);
                console.error('ÈîôËØØËØ¶ÊÉÖ:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                const fallbackMessage = error && error.message ? error.message : 'ÁøªËØëËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØÔºåËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞Êó•Âøó„ÄÇ';
                const activeStage = getActiveStage();
                if (activeStage) {
                    markDirty(failStage(activeStage.key, 'ÁøªËØëËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ'));
                } else {
                    markDirty(failStage('translationOutput', 'ÁøªËØëËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ'));
                }
                flushStages(`ÁøªËØëÂ§±Ë¥•Ôºö${fallbackMessage}`, 'error', { useShine: false });
                highlightSuspectLinesInEditor([]);
                alert('ÁøªËØëËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ');
            } finally {
                translateBtn.textContent = originalBtnText;
                translateBtn.disabled = false;
            }
        }

        async function copyTranslationPrompt() {
            const copyBtn = document.querySelector('button[onclick="copyTranslationPrompt()"]');
            const originalText = copyBtn ? copyBtn.textContent : '';
            if (copyBtn) {
                copyBtn.textContent = 'Â§çÂà∂‰∏≠...';
                copyBtn.disabled = true;
            }

            const resetButton = () => {
                if (copyBtn) {
                    copyBtn.textContent = originalText || 'üìã Â§çÂà∂ÊèêÁ§∫ËØç';
                    copyBtn.disabled = false;
                }
            };

            try {
                const lyricsEditor = document.getElementById('lyricsEditor');
                if (!lyricsEditor || !lyricsEditor.value.trim()) {
                    alert('ËØ∑ÂÖàËæìÂÖ•Ê≠åËØçÂÜÖÂÆπÔºÅ');
                    resetButton();
                    return;
                }

                const lyricsPathInput = document.getElementById('lyricsPath');
                const lyricsPath = lyricsPathInput ? lyricsPathInput.value : '';
                const pathExtension = (lyricsPath.match(/\.[^.]+$/) || [])[0]?.toLowerCase() || '';
                const detectedExtension = detectLyricsExtension(lyricsEditor.value);

                let processedLyricsContent = lyricsEditor.value;
                if (pathExtension === '.ttml' && detectedExtension === '.ttml') {
                    const conversion = await ensureLysContentForProcessing('Â§çÂà∂ÊèêÁ§∫ËØç');
                    processedLyricsContent = conversion.content;
                }

                const stripBracketsStored = localStorage.getItem('aiStripBrackets');
                const stripBrackets = stripBracketsStored ? stripBracketsStored === 'true' : false;
                const processedLines = preprocessLyricsLinesForPrompt(processedLyricsContent, stripBrackets);
                if (!processedLines.length) {
                    alert('Êú™ÊèêÂèñÂà∞ÂèØÁî®Ê≠åËØçÂÜÖÂÆπÔºåËØ∑Ê£ÄÊü•Ê≠åËØçÊ†ºÂºè');
                    resetButton();
                    return;
                }

                const numberedLyrics = processedLines.map((line, idx) => `${idx + 1}.${line}`).join('\n');
                const thinkingBlock = lastThinkingSummary ? `Ê≠åÊõ≤ÁêÜËß£Ôºö\n${lastThinkingSummary}` : '';

                let systemPrompt = localStorage.getItem('aiSystemPrompt') || '';
                const compatModeStorage = localStorage.getItem('aiCompatMode');
                const compatMode = compatModeStorage ? compatModeStorage === 'true' : false;
                const thinkingEnabledStorage = localStorage.getItem('aiThinkingEnabled');
                const thinkingEnabled = thinkingEnabledStorage ? thinkingEnabledStorage === 'true' : true;
                const thinkingPromptStored = localStorage.getItem('aiThinkingPrompt') || '';
                const thinkingPrompt = thinkingPromptStored.trim().length > 0
                    ? thinkingPromptStored.trim()
                    : 'ÂÖàÁî®‰Ω†ÁöÑÊØçËØ≠ÂØπÊï¥È¶ñÊ≠åËøõË°åÊ∑±ÂÖ•ÁêÜËß£ÔºåÂΩíÁ∫≥ÊÉÖËäÇ„ÄÅÊÉÖÁª™„ÄÅ‰∫∫Áâ©ÂíåÈöêÂñªÔºåÂÜçÊçÆÊ≠§ÁøªËØëÊ≠åËØçÔºå‰øùÊåÅÈÄêË°åÂØπÂ∫î„ÄÇ';

                let finalPrompt = '';
                const promptSections = [];
                if (compatMode) {
                    if (systemPrompt && systemPrompt.trim()) {
                        promptSections.push(systemPrompt.trim());
                    }
                    if (thinkingEnabled) {
                        promptSections.push(thinkingPrompt);
                    }
                    if (thinkingBlock) {
                        promptSections.push(thinkingBlock);
                    }
                    if (thinkingEnabled) {
                        promptSections.push('ËØ∑ÂÖàÂÆåÊàêÊÄùËÄÉÈò∂ÊÆµÔºåÂÜçËøõË°åÈÄêË°åÁøªËØë„ÄÇ');
                    }
                    promptSections.push(`ÂæÖÁøªËØëÊ≠åËØçÔºö\n${numberedLyrics}`);
                    finalPrompt = promptSections.filter(Boolean).join('\n\n');
                } else {
                    if (systemPrompt && systemPrompt.trim()) {
                        promptSections.push(systemPrompt.trim());
                    }
                    if (thinkingEnabled) {
                        promptSections.push(thinkingPrompt);
                    }
                    if (thinkingBlock) {
                        promptSections.push(thinkingBlock);
                    }
                    if (thinkingEnabled) {
                        promptSections.push('ËØ∑ÂÖàÂÆåÊàêÊÄùËÄÉÈò∂ÊÆµÔºåÂÜçËøõË°åÈÄêË°åÁøªËØë„ÄÇ');
                    }
                    promptSections.push(`ÂæÖÁøªËØëÊ≠åËØçÔºö\n${numberedLyrics}`);
                    finalPrompt = promptSections.filter(Boolean).join('\n\n');
                }

                await navigator.clipboard.writeText(finalPrompt);
                if (copyBtn) {
                    copyBtn.textContent = 'Â∑≤Â§çÂà∂';
                    setTimeout(resetButton, 1000);
                } else {
                    alert('ÊèêÁ§∫ËØçÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                }
            } catch (error) {
                console.error('Â§çÂà∂ÊèêÁ§∫ËØçÂ§±Ë¥•Ôºö', error);
                alert(error.message || 'Â§çÂà∂ÊèêÁ§∫ËØçÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ');
                resetButton();
            }
        }

        function showAISettings() {
            // ‰ªélocalStorageËé∑ÂèñAPIÂØÜÈí•ÂíåÊèêÁ§∫ËØç
            const savedApiKey = localStorage.getItem('aiApiKey');
            const savedSystemPrompt = localStorage.getItem('aiSystemPrompt');
            const savedProvider = localStorage.getItem('aiProvider');
            const savedBaseUrl = localStorage.getItem('aiBaseUrl');
            const savedModel = localStorage.getItem('aiModel');
            const savedExpectReasoning = localStorage.getItem('aiExpectReasoning');
            const savedCompatMode = localStorage.getItem('aiCompatMode');
            const savedThinkingEnabled = localStorage.getItem('aiThinkingEnabled');
            const savedThinkingProvider = localStorage.getItem('aiThinkingProvider');
            const savedThinkingBaseUrl = localStorage.getItem('aiThinkingBaseUrl');
            const savedThinkingModel = localStorage.getItem('aiThinkingModel');
            const savedThinkingApiKey = localStorage.getItem('aiThinkingApiKey');
            const savedThinkingPrompt = localStorage.getItem('aiThinkingPrompt');
            const savedStripBrackets = localStorage.getItem('aiStripBrackets');

            // Ëé∑ÂèñÂΩìÂâçËÆæÁΩÆ
            fetch('/get_ai_settings')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // ‰ºòÂÖà‰ΩøÁî®localStorage‰∏≠ÁöÑAPIÂØÜÈí•ÂíåÊèêÁ§∫ËØç
                        document.getElementById('aiApiKey').value = savedApiKey || data.settings.api_key;
                        document.getElementById('aiSystemPrompt').value = savedSystemPrompt || data.settings.system_prompt;
                        document.getElementById('aiProvider').value = savedProvider || data.settings.provider || 'deepseek';
                        document.getElementById('aiBaseUrl').value = savedBaseUrl || data.settings.base_url || 'https://api.deepseek.com';
                        document.getElementById('aiModel').value = savedModel || data.settings.model || 'deepseek-reasoner';
                        document.getElementById('aiExpectReasoning').checked = savedExpectReasoning ? savedExpectReasoning === 'true' : (data.settings.expect_reasoning !== undefined ? data.settings.expect_reasoning : true);
                        document.getElementById('aiCompatMode').checked = savedCompatMode ? savedCompatMode === 'true' : (data.settings.compat_mode !== undefined ? data.settings.compat_mode : false);
                        const backendStripBrackets = data.settings.strip_brackets !== undefined ? !!data.settings.strip_brackets : false;
                        document.getElementById('aiStripBrackets').checked = savedStripBrackets !== null ? savedStripBrackets === 'true' : backendStripBrackets;
                        document.getElementById('aiThinkingEnabled').checked = savedThinkingEnabled ? savedThinkingEnabled === 'true' : (data.settings.thinking_enabled !== undefined ? data.settings.thinking_enabled : true);
                        document.getElementById('aiThinkingProvider').value = savedThinkingProvider || data.settings.thinking_provider || data.settings.provider || 'deepseek';
                        document.getElementById('aiThinkingBaseUrl').value = savedThinkingBaseUrl || data.settings.thinking_base_url || data.settings.base_url || '';
                        document.getElementById('aiThinkingModel').value = savedThinkingModel || data.settings.thinking_model || data.settings.model || '';
                        document.getElementById('aiThinkingApiKey').value = savedThinkingApiKey || data.settings.thinking_api_key || '';
                        document.getElementById('aiThinkingPrompt').value = savedThinkingPrompt || data.settings.thinking_system_prompt || '';
                        document.getElementById('aiSettingsModal').style.display = 'block';
                        updateBaseUrlAndModel(); // Ê†πÊçÆÈÄâÊã©ÁöÑÊèê‰æõÂïÜÊõ¥Êñ∞URLÂíåÊ®°Âûã
                        updateThinkingBaseUrlAndModel();
                    }
                })
                .catch(error => {
                    console.error('Ëé∑ÂèñAIËÆæÁΩÆÂ§±Ë¥•Ôºö', error);
                    alert('Ëé∑ÂèñAIËÆæÁΩÆÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ');
                });
        }

        function closeAISettings() {
            document.getElementById('aiSettingsModal').style.display = 'none';
        }

        const PROVIDER_PRESETS = {
            'deepseek': {
                baseUrl: 'https://api.deepseek.com',
                model: 'deepseek-reasoner'
            },
            'openai': {
                baseUrl: 'https://api.openai.com/v1',
                model: 'gpt-4o-mini'
            },
            'openrouter': {
                baseUrl: 'https://openrouter.ai/api/v1',
                model: 'openai/gpt-4o-mini'
            },
            'together': {
                baseUrl: 'https://api.together.xyz/v1',
                model: 'mistralai/Mistral-7B-Instruct-v0.3'
            },
            'groq': {
                baseUrl: 'https://api.groq.com/openai/v1',
                model: 'llama-3.1-70b-versatile'
            }
        };

        // Ê†πÊçÆÈÄâÊã©ÁöÑÊèê‰æõÂïÜÊõ¥Êñ∞Âü∫Á°ÄURLÂíåÊ®°Âûã
        function applyProviderPreset(providerSelectId, baseInputId, modelInputId) {
            const providerSelect = document.getElementById(providerSelectId);
            const baseUrlInput = document.getElementById(baseInputId);
            const modelInput = document.getElementById(modelInputId);

            if (!providerSelect || !baseUrlInput || !modelInput) {
                return;
            }

            const provider = providerSelect.value;
            const preset = PROVIDER_PRESETS[provider];

            if (provider === 'custom' || !preset) {
                baseUrlInput.readOnly = false;
                modelInput.readOnly = false;
                return;
            }

            baseUrlInput.value = preset.baseUrl;
            modelInput.value = preset.model;
            baseUrlInput.readOnly = true;
            modelInput.readOnly = true;
        }

        function updateBaseUrlAndModel() {
            applyProviderPreset('aiProvider', 'aiBaseUrl', 'aiModel');
        }

        function updateThinkingBaseUrlAndModel() {
            applyProviderPreset('aiThinkingProvider', 'aiThinkingBaseUrl', 'aiThinkingModel');
        }

        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÊ∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.addEventListener('DOMContentLoaded', function() {
            const providerSelect = document.getElementById('aiProvider');
            if (providerSelect) {
                providerSelect.addEventListener('change', updateBaseUrlAndModel);
            }
            const thinkingProviderSelect = document.getElementById('aiThinkingProvider');
            if (thinkingProviderSelect) {
                thinkingProviderSelect.addEventListener('change', updateThinkingBaseUrlAndModel);
            }
        });

        function sanitizeBaseUrl(value) {
            if (!value) {
                return '';
            }
            return value.trim().replace(/\/+(chat|responses)\/(completions|streams?)\/?$/i, '');
        }

        function saveAISettings() {
            const apiKey = document.getElementById('aiApiKey').value;
            const systemPrompt = document.getElementById('aiSystemPrompt').value;
            const hasSystemPrompt = systemPrompt && systemPrompt.trim().length > 0;
            const provider = document.getElementById('aiProvider').value;

            let baseUrl = sanitizeBaseUrl(document.getElementById('aiBaseUrl').value);
            document.getElementById('aiBaseUrl').value = baseUrl;

            const model = document.getElementById('aiModel').value;
            const expectReasoning = document.getElementById('aiExpectReasoning').checked;
            const compatMode = document.getElementById('aiCompatMode').checked;
            const stripBrackets = document.getElementById('aiStripBrackets').checked;
            const thinkingEnabled = document.getElementById('aiThinkingEnabled').checked;

            const thinkingProvider = document.getElementById('aiThinkingProvider').value;
            let thinkingBaseUrl = sanitizeBaseUrl(document.getElementById('aiThinkingBaseUrl').value);
            document.getElementById('aiThinkingBaseUrl').value = thinkingBaseUrl;
            const thinkingModel = document.getElementById('aiThinkingModel').value;
            const thinkingApiKey = document.getElementById('aiThinkingApiKey').value;
            const thinkingPrompt = document.getElementById('aiThinkingPrompt').value;
            const hasThinkingPrompt = thinkingPrompt && thinkingPrompt.trim().length > 0;

            // ‰øùÂ≠òËÆæÁΩÆÂà∞localStorage
            if (apiKey) {
                localStorage.setItem('aiApiKey', apiKey);
            } else {
                localStorage.removeItem('aiApiKey');
            }

            if (hasSystemPrompt) {
                localStorage.setItem('aiSystemPrompt', systemPrompt);
            } else {
                localStorage.removeItem('aiSystemPrompt');
            }

            localStorage.setItem('aiProvider', provider);
            localStorage.setItem('aiBaseUrl', baseUrl);
            localStorage.setItem('aiModel', model);
            localStorage.setItem('aiExpectReasoning', expectReasoning);
            localStorage.setItem('aiCompatMode', compatMode);
            localStorage.setItem('aiStripBrackets', stripBrackets);
            localStorage.setItem('aiThinkingEnabled', thinkingEnabled);

            if (thinkingApiKey) {
                localStorage.setItem('aiThinkingApiKey', thinkingApiKey);
            } else {
                localStorage.removeItem('aiThinkingApiKey');
            }

            if (hasThinkingPrompt) {
                localStorage.setItem('aiThinkingPrompt', thinkingPrompt);
            } else {
                localStorage.removeItem('aiThinkingPrompt');
            }

            localStorage.setItem('aiThinkingProvider', thinkingProvider);
            if (thinkingBaseUrl) {
                localStorage.setItem('aiThinkingBaseUrl', thinkingBaseUrl);
            } else {
                localStorage.removeItem('aiThinkingBaseUrl');
            }
            if (thinkingModel) {
                localStorage.setItem('aiThinkingModel', thinkingModel);
            } else {
                localStorage.removeItem('aiThinkingModel');
            }

            fetch('/save_ai_settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    api_key: apiKey,
                    system_prompt: systemPrompt,
                    provider: provider,
                    base_url: baseUrl,
                    model: model,
                    expect_reasoning: expectReasoning,
                    compat_mode: compatMode,
                    strip_brackets: stripBrackets,
                    thinking_enabled: thinkingEnabled,
                    thinking_api_key: thinkingApiKey,
                    thinking_provider: thinkingProvider,
                    thinking_base_url: thinkingBaseUrl,
                    thinking_model: thinkingModel,
                    thinking_system_prompt: thinkingPrompt
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const resolvedSystemPrompt = data.system_prompt || '';
                    if (resolvedSystemPrompt.trim().length > 0) {
                        localStorage.setItem('aiSystemPrompt', resolvedSystemPrompt);
                        const systemPromptInput = document.getElementById('aiSystemPrompt');
                        if (systemPromptInput) {
                            systemPromptInput.value = resolvedSystemPrompt;
                        }
                    } else {
                        localStorage.removeItem('aiSystemPrompt');
                    }

                    const resolvedThinkingPrompt = data.thinking_system_prompt || '';
                    if (resolvedThinkingPrompt.trim().length > 0) {
                        localStorage.setItem('aiThinkingPrompt', resolvedThinkingPrompt);
                        const thinkingPromptInput = document.getElementById('aiThinkingPrompt');
                        if (thinkingPromptInput) {
                            thinkingPromptInput.value = resolvedThinkingPrompt;
                        }
                    } else {
                        localStorage.removeItem('aiThinkingPrompt');
                    }

                    const resolvedStripBrackets = data.strip_brackets !== undefined ? !!data.strip_brackets : false;
                    localStorage.setItem('aiStripBrackets', resolvedStripBrackets);
                    const stripBracketsInput = document.getElementById('aiStripBrackets');
                    if (stripBracketsInput) {
                        stripBracketsInput.checked = resolvedStripBrackets;
                    }

                    alert('ËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºÅ');
                    closeAISettings();
                } else {
                    alert('‰øùÂ≠òËÆæÁΩÆÂ§±Ë¥•Ôºö' + data.message);
                }
            })
            .catch(error => {
                console.error('‰øùÂ≠òAIËÆæÁΩÆÂ§±Ë¥•Ôºö', error);
                alert('‰øùÂ≠òAIËÆæÁΩÆÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ');
            });
        }

        // ÊµãËØïAIËøûÊé•
        async function probeAIConnection(mode = 'translation', btn = null) {
            const isThinking = mode === 'thinking';
            const targetLabel = isThinking ? 'ÊÄùËÄÉÊ®°Âûã' : 'ÁøªËØëÊ®°Âûã';

            const mainApiKeyInput = document.getElementById('aiApiKey');
            const mainBaseUrlInput = document.getElementById('aiBaseUrl');
            const thinkingApiKeyInput = document.getElementById('aiThinkingApiKey');
            const thinkingBaseUrlInput = document.getElementById('aiThinkingBaseUrl');

            let apiKeyInput = isThinking ? thinkingApiKeyInput : mainApiKeyInput;
            let baseUrlInput = isThinking ? thinkingBaseUrlInput : mainBaseUrlInput;

            let apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            if (!apiKey && isThinking && mainApiKeyInput) {
                apiKey = mainApiKeyInput.value.trim();
            }

            if (!apiKey) {
                alert(`ËØ∑ÂÖàÂ°´ÂÜô${targetLabel}ÁöÑAPIÂØÜÈí•`);
                return;
            }

            let baseUrl = baseUrlInput ? baseUrlInput.value.trim() : '';
            if (!baseUrl && isThinking && mainBaseUrlInput) {
                baseUrl = mainBaseUrlInput.value.trim();
            }

            if (!baseUrl) {
                alert(`ËØ∑ÂÖàÂ°´ÂÜô${targetLabel}ÁöÑBase URL`);
                return;
            }

            baseUrl = sanitizeBaseUrl(baseUrl);
            if (baseUrlInput && baseUrlInput.value.trim() !== baseUrl) {
                baseUrlInput.value = baseUrl;
            }

            const probeBtn = btn || document.querySelector(`button[data-probe="${isThinking ? 'thinking' : 'translation'}"]`);
            const originalText = probeBtn ? probeBtn.textContent : '';
            if (probeBtn) {
                probeBtn.textContent = 'ÊµãËØï‰∏≠...';
                probeBtn.disabled = true;
            }

            try {
                const response = await fetch('/probe_ai', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mode,
                        api_key: apiKey,
                        base_url: baseUrl
                    })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    const models = data.models || [];
                    const modelList = models.slice(0, 10).join('\n');
                    const moreCount = Math.max(0, models.length - 10);
                    const moreText = moreCount > 0 ? `\n...ËøòÊúâ${moreCount}‰∏™Ê®°Âûã` : '';
                    alert(`${targetLabel}ËøûÊé•ÊàêÂäüÔºÅ\nÂèØÁî®Ê®°ÂûãÔºàÂâç10‰∏™ÔºâÔºö\n${modelList || 'ÔºàÁ©∫Ôºâ'}${moreText}`);
                } else {
                    alert(`${targetLabel}ËøûÊé•Â§±Ë¥•Ôºö${data.message}`);
                }
            } catch (error) {
                console.error(`${targetLabel}ÊµãËØïËøûÊé•Â§±Ë¥•Ôºö`, error);
                alert(`${targetLabel}ÊµãËØïËøûÊé•Â§±Ë¥•ÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Ëé∑ÂèñËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ`);
            } finally {
                if (probeBtn) {
                    probeBtn.textContent = originalText;
                    probeBtn.disabled = false;
                }
            }
        }

        async function openLyricsAnimate(filename, style) {
            const fallbackOpen = (extra = {}) => {
                const params = new URLSearchParams({ file: filename, style });
                Object.entries(extra).forEach(([key, value]) => {
                    if (value) {
                        params.set(key, value);
                    }
                });
                params.set('for_player', '1');
                window.open('/lyrics-animate?' + params.toString(), '_blank');
            };

            let openWithParams = fallbackOpen;

            try {
                // 1) ËØªÂèñÊ≠åÊõ≤ JSONÔºåÊãøÂà∞Ê≠åËØçË∑ØÂæÑ
                const res = await fetch('/get_json_data?filename=' + encodeURIComponent(filename));
                const data = await res.json();
                if (data.status !== 'success') throw new Error('Ëé∑ÂèñÊ≠åÊõ≤‰ø°ÊÅØÂ§±Ë¥•');

                const meta = data.jsonData?.meta || {};

                const resolveMediaForAnimate = (value) => {
                    if (!value || value === '!') {
                        return '';
                    }
                    try {
                        const normalized = normalizeSongsUrl(value);
                        if (normalized && normalized !== '!') {
                            return normalized;
                        }
                    } catch (error) {
                        console.warn('normalizeSongsUrl Ëß£ÊûêÂ§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂÄº:', value, error);
                    }
                    return value;
                };

                const backgroundUrl = resolveMediaForAnimate(meta['Background-image']);
                const coverCandidateSources = [
                    meta.albumImgSrc,
                    meta.cover,
                    meta.coverUrl,
                    data.jsonData?.cover,
                    data.jsonData?.coverUrl
                ];
                let coverUrl = '';
                for (const candidate of coverCandidateSources) {
                    const resolved = resolveMediaForAnimate(candidate);
                    if (resolved) {
                        coverUrl = resolved;
                        break;
                    }
                }

                openWithParams = (extra = {}) => {
                    const params = new URLSearchParams({ file: filename, style });
                    if (backgroundUrl) {
                        params.set('background', backgroundUrl);
                    }
                    if (coverUrl) {
                        params.set('cover', coverUrl);
                    }
                    Object.entries(extra).forEach(([key, value]) => {
                        if (value) {
                            params.set(key, value);
                        }
                    });
                    params.set('for_player', '1');
                    window.open('/lyrics-animate?' + params.toString(), '_blank');
                };

                // ÂÖºÂÆπ‰∏§ÁßçÂÜôÊ≥ïÔºöÂçïË∑ØÂæÑ Êàñ "::Ê≠åËØç::ÁøªËØë::ÁΩóÈ©¨Èü≥::"
                let rawLyricsPath = meta.lyrics || '';
                let mainPath = '';
                if (rawLyricsPath.includes('::')) {
                    const parts = rawLyricsPath.split('::');
                    mainPath = parts[1] || '';
                } else {
                    mainPath = rawLyricsPath;
                }

                // ÂÖúÂ∫ïÔºöÊ≤°Êúâ‰∏ªÊ≠åËØçË∑ØÂæÑÔºåÁõ¥Êé•ÊâìÂºÄÂä®ÁîªÈ°µÔºà‰øùÊåÅÂéüË°å‰∏∫Ôºâ
                if (!mainPath) {
                    openWithParams();
                    return;
                }

                // 2) Â¶ÇÊûúÊòØ TTMLÔºåË∞ÉÁî®ÂêéÁ´ØËΩ¨Êç¢Êé•Âè£Ôºà‰∏ç‰øÆÊîπÂéü JSONÔºå‰ªÖÁîüÊàêËΩ¨Êç¢‰∫ßÁâ©Ôºâ
                const isTTML = mainPath.toLowerCase().endsWith('.ttml');
                if (isTTML) {
                    // Âèñ /songs/ ‰∏ãÁöÑÁõ∏ÂØπË∑ØÂæÑ‰º†ÁªôÂêéÁ´ØÔºöÊîØÊåÅ http(s)://ÂΩìÂâç‰∏ªÊú∫/songs/xxx Âíå /songs/xxx ‰∏§Áßç
                    let relative = '';
                    try {
                        if (mainPath.startsWith('http://') || mainPath.startsWith('https://')) {
                            const u = new URL(mainPath);
                            relative = u.pathname.startsWith('/songs/') ? u.pathname.slice('/songs/'.length) : u.pathname.replace(/^\//, '');
                        } else {
                            relative = mainPath.replace(/^\/?songs\//i, '');
                        }
                        relative = decodeURIComponent(relative);
                    } catch (e) {
                        console.error('Ëß£ÊûêURLÂ§±Ë¥•:', e);
                        relative = mainPath.split('/').pop();
                        relative = decodeURIComponent(relative);
                    }

                    console.log('TTMLËΩ¨Êç¢ - Êñá‰ª∂Âêç:', filename, 'Áõ∏ÂØπË∑ØÂæÑ:', relative);

                    const conv = await fetch('/convert_ttml_by_path', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ path: relative })
                    }).then(r => r.json());

                    if (conv.status === 'success' && conv.lyricPath) {
                        const extraParams = { lys: conv.lyricPath };
                        if (conv.transPath) {
                            extraParams.lrc = conv.transPath;
                        }
                        openWithParams(extraParams);
                        return;
                    } else {
                        console.error('TTMLËΩ¨Êç¢Â§±Ë¥•:', conv.message || 'Êú™Áü•ÈîôËØØ');
                        alert('TTML ËΩ¨Êç¢Â§±Ë¥•Ôºö' + (conv.message || 'ËØ∑Ê£ÄÊü•Êñá‰ª∂Ê†ºÂºè'));
                    }
                } else {
                    if (!mainPath.toLowerCase().endsWith('.lys')) {
                        alert('Ë≠¶ÂëäÔºöÂΩìÂâçÊ≠åËØçÊñá‰ª∂‰∏çÊòØ LYS Ê†ºÂºèÔºåÂèØËÉΩÊó†Ê≥ïÊ≠£Â∏∏ÊòæÁ§∫Âä®ÊÄÅÊïàÊûúÔºÅ');
                    }
                }

                // 4) ÂÖúÂ∫ïÔºöÊåâËÄÅÈÄªËæëÊâìÂºÄ
                openWithParams();

            } catch (error) {
                console.error('ÊâìÂºÄÂä®ÁîªÈ°µÂ§±Ë¥•Ôºö', error);
                openWithParams();
            }
        }

        function openAMLL() {
            window.open('/lyrics-amll', '_blank');
        }

        // Á´ØÂè£ÂàáÊç¢Áõ∏ÂÖ≥
        async function updatePortUI() {
            try {
                const res = await fetch('/get_port_status');
                const data = await res.json();
                console.log('[updatePortUI] Á´ØÂè£Áä∂ÊÄÅ', data);
                const backendPort = String(data.port);
                const isLocal = (location.hostname === '127.0.0.1' || location.hostname === 'localhost') && location.port === backendPort;
                const portBtn = document.getElementById('portSwitchBtn');

                // Ê£ÄÊü•ÊòØÂê¶‰∏∫Êú¨Âú∞Áõ¥Ëøû
                let canSwitchPort = false;
                try {
                    const ipRes = await fetch('/get_my_ip');
                    const ipData = await ipRes.json();
                    if (ipData.remote_addr === '127.0.0.1' || ipData.remote_addr === '::1') {
                        canSwitchPort = true;
                    }
                } catch (e) {}
                if (!canSwitchPort) {
                    portBtn.disabled = true;
                    portBtn.style.background = '#e9ecef';
                    portBtn.style.color = '#bbb';
                    portBtn.style.cursor = 'not-allowed';
                    portBtn.title = '‰ªÖÊú¨Êú∫ÂèØÂàáÊç¢Á´ØÂè£';
                } else {
                    portBtn.disabled = false;
                    portBtn.style.background = '';
                    portBtn.style.color = '';
                    portBtn.style.cursor = '';
                    portBtn.title = '';
                }

                // Ê≠åËØçÊ†∑ÂºèÊåâÈíÆ
                document.querySelectorAll('.am-style, .fs-style, .fslr-style').forEach(btn => {
                    console.log('[updatePortUI] Â§ÑÁêÜÊåâÈíÆ', btn, 'ÂΩìÂâçmode:', data.mode, 'classList:', btn.classList.value);
                    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ AMLL ËßÑÂàôÁºñÂÜôÊåâÈíÆÔºàÈÄöËøá onclick Â±ûÊÄßÂà§Êñ≠Ôºâ
                    const isAMLLButton = btn.getAttribute('onclick') && btn.getAttribute('onclick').includes("'amll'");

                    if (data.mode === 'random') {
                        // AMLL ËßÑÂàôÁºñÂÜôÊåâÈíÆÂú®ÈöèÊú∫Á´ØÂè£‰∏ã‰ªçÁÑ∂ÂèØÁî®
                        if (isAMLLButton) {
                            btn.disabled = false;
                            btn.classList.remove('disabled-style');
                            btn.title = '';
                            //btn.textContent = 'AMLLËßÑÂàôÁºñÂÜô';
                        } else {
                            btn.disabled = true;
                            btn.classList.add('disabled-style');
                            btn.title = 'ÈöèÊú∫Á´ØÂè£‰∏ã‰∏çÂèØÁî®';
                            btn.addEventListener('mouseenter', function() {
                                btn.textContent = '‰∏çÂèØÁî®';
                            });
                            btn.addEventListener('mouseleave', function() {
                                btn.textContent = btn.classList.contains('am-style') ? 'AMÊ≠åËØçÊ†∑Âºè' : (btn.classList.contains('fs-style') ? 'ÂÖ®Â±èÊ≠åËØçÊ†∑Âºè' : 'ÂÖ®Â±èÂØπÂî±Ê≠åËØçÊ†∑Âºè');
                            });
                        }
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('disabled-style');
                        btn.title = '';
                        if (isAMLLButton) {
                            //btn.textContent = 'AMLLËßÑÂàôÁºñÂÜô';
                        } else {
                            btn.textContent = btn.classList.contains('am-style') ? 'AMÊ≠åËØçÊ†∑Âºè' : (btn.classList.contains('fs-style') ? 'ÂÖ®Â±èÊ≠åËØçÊ†∑Âºè' : 'ÂÖ®Â±èÂØπÂî±Ê≠åËØçÊ†∑Âºè');
                        }
                    }
                    // ÂèòËâ≤ÂêéÁ´ãÂç≥ÊâìÂç∞Ê†∑Âºè
                    console.log('[updatePortUI] ÂèòËâ≤Âêé style.background:', btn.style.background, 'computed:', getComputedStyle(btn).background);
                });
                if (data.mode === 'random') {
                    portBtn.textContent = 'ÊÅ¢Â§çÁ´ØÂè£';
                } else {
                    portBtn.textContent = 'ÈöèÊú∫Á´ØÂè£';
                }
            } catch (e) {console.error('[updatePortUI] error', e);}
        }
        async function switchPortMode() {
            const portBtn = document.getElementById('portSwitchBtn');
            portBtn.disabled = true;
            portBtn.textContent = 'ÂàáÊç¢‰∏≠...';
            try {
                const res = await fetch('/get_port_status');
                const data = await res.json();
                if (data.mode === 'random') {
                    // ÊÅ¢Â§ç
                    const resp = await fetch('/restore_port', {method: 'POST'});
                    const d = await resp.json();
                    if (d.status === 'success') {
                        setTimeout(() => {
                            const target = `${window.location.protocol}//${window.location.hostname}:5000/`;
                            window.location.href = target;
                        }, 1200);
                    }
                } else {
                    // ÈöèÊú∫Á´ØÂè£
                    const resp = await fetch('/switch_port', {method: 'POST'});
                    const d = await resp.json();
                    if (d.status === 'success') {
                        setTimeout(() => {
                            const target = `${window.location.protocol}//${window.location.hostname}:${d.port}/`;
                            window.location.href = target;
                        }, 1200);
                    }
                }
            } catch (e) {
                alert('ÂàáÊç¢Á´ØÂè£Â§±Ë¥•');
            }
        }
        
        // È°µÈù¢Âä†ËΩΩÊó∂Ëá™Âä®Âà∑Êñ∞Á´ØÂè£UIÂíåÂÆâÂÖ®Áä∂ÊÄÅ
        window.addEventListener('DOMContentLoaded', function() {
            updatePortUI();
            updateSecurityUI();
            updateAuthUI();
        });

        // Êõ¥Êñ∞ÂÆâÂÖ®‰øùÊä§UIÁä∂ÊÄÅ
        async function updateSecurityUI() {
            try {
                const res = await fetch('/get_security_status');
                const data = await res.json();
                const securityBtn = document.getElementById('securityToggleBtn');
                
                if (data.security_enabled) {
                    securityBtn.textContent = 'üîí ÂÆâÂÖ®‰øùÊä§';
                    securityBtn.title = 'ÂÆâÂÖ®‰øùÊä§Â∑≤ÂºÄÂêØÔºàÁÇπÂáªÂÖ≥Èó≠Ôºâ';
                    securityBtn.style.background = '#37b24d';
                } else {
                    securityBtn.textContent = 'üîì ÂÆâÂÖ®ÂÖ≥Èó≠';
                    securityBtn.title = 'ÂÆâÂÖ®‰øùÊä§Â∑≤ÂÖ≥Èó≠ÔºàÁÇπÂáªÂºÄÂêØÔºâ';
                    securityBtn.style.background = '#f03e3e';
                }
            } catch (e) {
                console.error('Ëé∑ÂèñÂÆâÂÖ®Áä∂ÊÄÅÂ§±Ë¥•:', e);
            }
        }

        // Êõ¥Êñ∞ËÆ§ËØÅUIÁä∂ÊÄÅ
        async function updateAuthUI() {
            try {
                const res = await fetch('/auth/status');
                const data = await res.json();
                const authBtn = document.getElementById('authToggleBtn');
                
                if (data.status === 'success') {
                    if (data.trusted) {
                        authBtn.textContent = 'üîì Â∑≤Ëß£ÈîÅ';
                        authBtn.title = 'Êú¨ËÆæÂ§áÂ∑≤Ëé∑ÂæóÁºñËæëÊùÉÈôê';
                        authBtn.style.background = '#37b24d';
                    } else {
                        authBtn.textContent = 'üîë Ëß£ÈîÅËÆæÂ§á';
                        authBtn.title = 'ÁÇπÂáªËß£ÈîÅÊú¨ËÆæÂ§áÁºñËæëÊùÉÈôê';
                        authBtn.style.background = '';
                    }
                    
                    // Êõ¥Êñ∞ÂÆâÂÖ®‰øùÊä§ÊåâÈíÆÁöÑÊèêÁ§∫‰ø°ÊÅØ
                    const securityBtn = document.getElementById('securityToggleBtn');
                    if (securityBtn.title) {
                        if (data.trusted) {
                            securityBtn.title += ' | Êú¨ËÆæÂ§áÂ∑≤Ëß£ÈîÅ';
                        } else {
                            securityBtn.title += ' | Êú¨ËÆæÂ§áÊú™Ëß£ÈîÅ';
                        }
                    }
                }
            } catch (e) {
                console.error('Ëé∑ÂèñËÆ§ËØÅÁä∂ÊÄÅÂ§±Ë¥•:', e);
                const authBtn = document.getElementById('authToggleBtn');
                authBtn.textContent = 'üîë Ëß£ÈîÅËÆæÂ§á';
                authBtn.title = 'ÁÇπÂáªËß£ÈîÅÊú¨ËÆæÂ§áÁºñËæëÊùÉÈôê';
            }
        }

        // ÊâìÂºÄËÆ§ËØÅÊ®°ÊÄÅÊ°Ü
        async function toggleAuthModal() {
            const modal = document.getElementById('authModal');
            const authStatus = document.getElementById('authStatus');
            const authForm = document.getElementById('authForm');
            const authSuccess = document.getElementById('authSuccess');
            const authLogoutBtn = document.getElementById('authLogoutBtn');
            
            // ÈáçÁΩÆÊ®°ÊÄÅÊ°ÜÁä∂ÊÄÅ
            authStatus.style.display = 'block';
            authForm.style.display = 'none';
            authSuccess.style.display = 'none';
            authStatus.textContent = 'Ê≠£Âú®Ê£ÄÊü•ËÆæÂ§áÁä∂ÊÄÅ...';
            
            modal.style.display = 'block';
            
            try {
                const res = await fetch('/auth/status');
                const data = await res.json();
                
                if (data.status === 'success') {
                    if (data.trusted) {
                        // ËÆæÂ§áÂ∑≤ËÆ§ËØÅ
                        authStatus.style.display = 'none';
                        authSuccess.style.display = 'block';
                        authLogoutBtn.style.display = 'inline-block';
                    } else {
                        // ËÆæÂ§áÊú™ËÆ§ËØÅ
                        authStatus.textContent = data.has_password ? 
                            'ËØ∑ËæìÂÖ•ÂØÜÁ†ÅËß£ÈîÅÊú¨ËÆæÂ§á' : 
                            'Á≥ªÁªüÊú™ËÆæÁΩÆÂØÜÁ†ÅÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëò';
                        authStatus.style.display = 'block';
                        authForm.style.display = data.has_password ? 'block' : 'none';
                        authLogoutBtn.style.display = 'none';
                    }
                }
            } catch (e) {
                authStatus.textContent = 'Ê£ÄÊü•Áä∂ÊÄÅÂ§±Ë¥•ÔºåËØ∑ÈáçËØï';
                console.error('Ê£ÄÊü•ËÆ§ËØÅÁä∂ÊÄÅÂ§±Ë¥•:', e);
            }
        }

        // ÂÖ≥Èó≠ËÆ§ËØÅÊ®°ÊÄÅÊ°Ü
        function closeAuthModal() {
            document.getElementById('authModal').style.display = 'none';
        }

        // ËÆæÂ§áÁôªÂΩï
        async function authLogin() {
            const password = document.getElementById('authPassword').value;
            if (!password) {
                alert('ËØ∑ËæìÂÖ•ÂØÜÁ†Å');
                return;
            }
            
            const authStatus = document.getElementById('authStatus');
            authStatus.textContent = 'Ê≠£Âú®È™åËØÅÂØÜÁ†Å...';
            
            try {
                const res = await fetch('/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: password })
                });
                
                const data = await res.json();
                
                if (data.status === 'success') {
                    // ËÆ§ËØÅÊàêÂäü
                    document.getElementById('authStatus').style.display = 'none';
                    document.getElementById('authForm').style.display = 'none';
                    document.getElementById('authSuccess').style.display = 'block';
                    document.getElementById('authLogoutBtn').style.display = 'inline-block';
                    
                    // Êõ¥Êñ∞UIÁä∂ÊÄÅ
                    await updateAuthUI();
                    await updateWriteButtons();
                } else {
                    authStatus.textContent = 'ÂØÜÁ†ÅÈîôËØØÔºåËØ∑ÈáçËØï';
                    authStatus.style.color = '#f03e3e';
                    setTimeout(() => {
                        authStatus.style.color = '';
                    }, 2000);
                }
            } catch (e) {
                authStatus.textContent = 'ÁôªÂΩïÂ§±Ë¥•ÔºåËØ∑ÈáçËØï';
                console.error('ÁôªÂΩïÂ§±Ë¥•:', e);
            }
        }

        // ËÆæÂ§áÁôªÂá∫
        async function authLogout() {
            try {
                const res = await fetch('/auth/logout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await res.json();
                
                if (data.status === 'success') {
                    // ÁôªÂá∫ÊàêÂäü
                    document.getElementById('authModal').style.display = 'none';
                    
                    // Êõ¥Êñ∞UIÁä∂ÊÄÅ
                    await updateAuthUI();
                    await updateWriteButtons();
                    
                    alert('ËÆæÂ§áÂ∑≤ÁôªÂá∫');
                }
            } catch (e) {
                console.error('ÁôªÂá∫Â§±Ë¥•:', e);
                alert('ÁôªÂá∫Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
            }
        }

        // ÂàáÊç¢ÂÆâÂÖ®‰øùÊä§Ê®°Âºè
        async function toggleSecurityMode() {
            if (!confirm('‚ö†Ô∏è Ë≠¶ÂëäÔºöÂÖ≥Èó≠ÂÆâÂÖ®‰øùÊä§Â∞ÜÂÖÅËÆ∏Â§ñÈÉ®ÁΩëÁªúËÆøÈóÆÔºÅ\n\nÁ°ÆÂÆöË¶ÅÂàáÊç¢ÂÆâÂÖ®‰øùÊä§Ê®°ÂºèÂêóÔºü')) {
                return;
            }
            
            const securityBtn = document.getElementById('securityToggleBtn');
            securityBtn.disabled = true;
            securityBtn.textContent = 'ÂàáÊç¢‰∏≠...';
            
            try {
                const response = await fetch('/toggle_security', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                if (data.status === 'success') {
                    await updateSecurityUI();
                    alert(`ÂÆâÂÖ®‰øùÊä§Â∑≤${data.security_enabled ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠'}`);
                    location.reload(); // ÈáçÊñ∞Âä†ËΩΩÈ°µÈù¢‰ª•Â∫îÁî®Êñ∞ÁöÑÂÆâÂÖ®ËÆæÁΩÆ
                } else {
                    alert('ÂàáÊç¢Â§±Ë¥•: ' + data.message);
                }
            } catch (error) {
                alert('ÂàáÊç¢ÂÆâÂÖ®Ê®°ÂºèÂ§±Ë¥•: ' + error);
            } finally {
                securityBtn.disabled = false;
                await updateSecurityUI();
            }
        }

        async function updateWriteButtons() {
            try {
                const res = await fetch('/get_port_status');
                const data = await res.json();
                const backendPort = String(data.port);
                const isLocal = (location.hostname === '127.0.0.1' || location.hostname === 'localhost') && location.port === backendPort;
                
                // Ê£ÄÊü•ÂÆâÂÖ®ÈÖçÁΩÆÂíåËÆæÂ§á‰ø°‰ªªÁä∂ÊÄÅ
                const securityRes = await fetch('/get_security_status');
                const securityData = await securityRes.json();
                const securityEnabled = securityData.security_enabled;
                
                const authRes = await fetch('/auth/status');
                const authData = await authRes.json();
                const isTrusted = authData.status === 'success' && authData.trusted;
                
                // Â¶ÇÊûúÂÆâÂÖ®‰øùÊä§ÂêØÁî®‰∏î‰∏çÊòØÊú¨Âú∞ËÆøÈóÆ‰∏îËÆæÂ§á‰∏çÂèó‰ø°‰ªªÔºåÂàôÁ¶ÅÁî®‰øÆÊîπÂäüËÉΩ
                if (securityEnabled && !isLocal && !isTrusted) {
                    var selectors = [
                        '.file-actions .action-button',
                        '.style-buttons .style-button',
                        '.save-btn',
                        '.save-all-btn',
                        '.path-update-btn',
                        '.close-btn',
                        '.lyrics-action-btn',
                        '.editor-buttons button',
                        '.copy-btn',
                        '.modal-content button',
                        '.modal-content input',
                        '.modal-content textarea'
                    ];
                    selectors.forEach(function(sel){
                        document.querySelectorAll(sel).forEach(function(btn){
                            if(btn.textContent.match(/‰øÆÊîπ|‰øùÂ≠ò|ÈáçÂëΩÂêç|Âà†Èô§|‰∏ä‰º†|ÂàõÂª∫|ÂÖ≥Èó≠|ÂêàÂπ∂|ÊèêÂèñ|AI|ËΩ¨Êç¢|ÊÅ¢Â§ç|ÂØºÂá∫|Êõ¥Êñ∞|Ë∑ØÂæÑ|‰∏ãËΩΩ|ÁøªËØë/)){
                                btn.disabled = true;
                                btn.style.pointerEvents = 'none';
                                btn.style.opacity = 0.5;
                            }
                        });
                    });
                } else {
                    // ÊÅ¢Â§çÊâÄÊúâÊåâÈíÆÁä∂ÊÄÅ
                    var selectors = [
                        '.file-actions .action-button',
                        '.style-buttons .style-button',
                        '.save-btn',
                        '.save-all-btn',
                        '.path-update-btn',
                        '.close-btn',
                        '.lyrics-action-btn',
                        '.editor-buttons button',
                        '.copy-btn',
                        '.modal-content button',
                        '.modal-content input',
                        '.modal-content textarea'
                    ];
                    selectors.forEach(function(sel){
                        document.querySelectorAll(sel).forEach(function(btn){
                            btn.disabled = false;
                            btn.style.pointerEvents = '';
                            btn.style.opacity = '';
                        });
                    });
                }
            } catch (e) {}
        }
        
        // ÊòæÁ§∫Âèó‰ø°‰ªªËÆæÂ§áÂàóË°®
        async function showTrustedDevices() {
            try {
                const res = await fetch('/auth/trusted');
                const data = await res.json();
                
                if (data.status === 'success') {
                    if (data.devices.length === 0) {
                        alert('ÊöÇÊó†Âèó‰ø°‰ªªËÆæÂ§á');
                        return;
                    }
                    
                    let message = `Âèó‰ø°‰ªªËÆæÂ§áÂàóË°® (ÂÖ± ${data.total} ‰∏™):\n\n`;
                    data.devices.forEach(device => {
                        message += `ËÆæÂ§áID: ${device.device_id}\n`;
                        message += `IP: ${device.ip}\n`;
                        message += `ÂàõÂª∫Êó∂Èó¥: ${device.created_at}\n`;
                        message += `ÊúÄÂêéËÆøÈóÆ: ${device.last_seen}\n`;
                        message += `UAÂìàÂ∏å: ${device.ua_hash}\n`;
                        message += '‚îÄ'.repeat(30) + '\n';
                    });
                    
                    alert(message);
                } else {
                    alert('Ëé∑ÂèñËÆæÂ§áÂàóË°®Â§±Ë¥•');
                }
            } catch (e) {
                console.error('Ëé∑ÂèñËÆæÂ§áÂàóË°®Â§±Ë¥•:', e);
                alert('Ëé∑ÂèñËÆæÂ§áÂàóË°®Â§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊÇ®ÊúâÊùÉÈôêËÆøÈóÆ');
            }
        }
        
        // Ê∏ÖÁ©∫ÊâÄÊúâËÆæÂ§á
        async function revokeAllDevices() {
            if (!confirm('‚ö†Ô∏è Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂèó‰ø°‰ªªËÆæÂ§áÂêóÔºü\n\nÊ≠§Êìç‰ΩúÂ∞ÜÂº∫Âà∂ÊâÄÊúâËÆæÂ§áÈáçÊñ∞ËÆ§ËØÅÔºÅ')) {
                return;
            }
            
            try {
                const res = await fetch('/auth/revoke_all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await res.json();
                
                if (data.status === 'success') {
                    alert(`Â∑≤ÊàêÂäüÊ∏ÖÁ©∫ ${data.revoked_count} ‰∏™Âèó‰ø°‰ªªËÆæÂ§á`);
                    // Êõ¥Êñ∞UIÁä∂ÊÄÅ
                    await updateAuthUI();
                    await updateWriteButtons();
                } else {
                    alert('Ê∏ÖÁ©∫ËÆæÂ§áÂ§±Ë¥•');
                }
            } catch (e) {
                console.error('Ê∏ÖÁ©∫ËÆæÂ§áÂ§±Ë¥•:', e);
                alert('Ê∏ÖÁ©∫ËÆæÂ§áÂ§±Ë¥•ÔºåËØ∑Á°Æ‰øùÊÇ®ÊúâÊùÉÈôêËÆøÈóÆ');
            }
        }
        
        // ÂØÜÁ†ÅËÆæÁΩÆÁõ∏ÂÖ≥ÂäüËÉΩ
        function showSetPasswordModal() {
            document.getElementById('setPasswordModal').style.display = 'block';
            // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmPassword').value = '';
            document.getElementById('setPasswordStatus').style.display = 'none';
        }

        function closeSetPasswordModal() {
            document.getElementById('setPasswordModal').style.display = 'none';
        }

        async function setPassword() {
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            const statusDiv = document.getElementById('setPasswordStatus');
            
            // È™åËØÅÂØÜÁ†Å
            if (newPassword.length < 8) {
                statusDiv.textContent = '‚ùå ÂØÜÁ†ÅÈïøÂ∫¶Ëá≥Â∞ëÈúÄË¶Å8‰∏™Â≠óÁ¨¶';
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#ffeaea';
                return;
            }
            
            if (newPassword !== confirmPassword) {
                statusDiv.textContent = '‚ùå ‰∏§Ê¨°ËæìÂÖ•ÁöÑÂØÜÁ†Å‰∏ç‰∏ÄËá¥';
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#ffeaea';
                return;
            }
            
            try {
                const res = await fetch('/auth/set_password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        password: newPassword,
                        current_password: currentPassword || undefined
                    })
                });
                
                const data = await res.json();
                
                if (data.status === 'success') {
                    statusDiv.textContent = '‚úÖ ÂØÜÁ†ÅËÆæÁΩÆÊàêÂäüÔºÅ';
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#eaffea';
                    
                    // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
                    document.getElementById('currentPassword').value = '';
                    document.getElementById('newPassword').value = '';
                    document.getElementById('confirmPassword').value = '';
                    
                    // 3ÁßíÂêéÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
                    setTimeout(() => {
                        closeSetPasswordModal();
                    }, 3000);
                } else {
                    statusDiv.textContent = `‚ùå ${data.message || 'ÂØÜÁ†ÅËÆæÁΩÆÂ§±Ë¥•'}`;
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#ffeaea';
                }
            } catch (e) {
                console.error('ËÆæÁΩÆÂØÜÁ†ÅÂ§±Ë¥•:', e);
                statusDiv.textContent = '‚ùå ËÆæÁΩÆÂØÜÁ†ÅÂ§±Ë¥•ÔºåËØ∑ÈáçËØï';
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#ffeaea';
            }
        }

        // ËÆæÂ§áÂêäÈîÄÁõ∏ÂÖ≥ÂäüËÉΩ
        function showRevokeDeviceModal() {
            document.getElementById('revokeDeviceModal').style.display = 'block';
            loadDevicesForRevoke();
        }

        function closeRevokeDeviceModal() {
            document.getElementById('revokeDeviceModal').style.display = 'none';
        }

        async function loadDevicesForRevoke() {
            const statusDiv = document.getElementById('revokeDeviceStatus');
            const listDiv = document.getElementById('revokeDeviceList');
            
            try {
                const res = await fetch('/auth/trusted');
                const data = await res.json();
                
                if (data.status === 'success' && data.devices.length > 0) {
                    statusDiv.style.display = 'none';
                    listDiv.style.display = 'block';
                    listDiv.innerHTML = '';
                    
                    data.devices.forEach(device => {
                        const deviceCard = document.createElement('div');
                        deviceCard.style.padding = '10px';
                        deviceCard.style.border = '1px solid var(--border-color)';
                        deviceCard.style.borderRadius = '8px';
                        deviceCard.style.marginBottom = '8px';
                        deviceCard.innerHTML = `
                            <div style="font-weight: bold;">ËÆæÂ§áID: ${device.device_id}</div>
                            <div>IP: ${device.ip}</div>
                            <div>ÂàõÂª∫Êó∂Èó¥: ${device.created_at}</div>
                            <div>ÊúÄÂêéËÆøÈóÆ: ${device.last_seen}</div>
                            <button onclick="revokeDevice('${device.device_id.replace('...', '')}')" 
                                    style="margin-top: 8px; padding: 5px 10px; background: #f03e3e; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                üö´ ÂêäÈîÄÊ≠§ËÆæÂ§á
                            </button>
                        `;
                        listDiv.appendChild(deviceCard);
                    });
                } else {
                    statusDiv.textContent = 'ÊöÇÊó†Âèó‰ø°‰ªªËÆæÂ§á';
                    statusDiv.style.background = '#f8f9fa';
                }
            } catch (e) {
                console.error('Âä†ËΩΩËÆæÂ§áÂàóË°®Â§±Ë¥•:', e);
                statusDiv.textContent = 'Âä†ËΩΩËÆæÂ§áÂàóË°®Â§±Ë¥•';
                statusDiv.style.background = '#ffeaea';
            }
        }

        async function revokeDevice(deviceIdPrefix) {
            if (!confirm(`Á°ÆÂÆöË¶ÅÂêäÈîÄËÆæÂ§á ${deviceIdPrefix}... ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄÔºÅ`)) {
                return;
            }
            
            try {
                const res = await fetch('/auth/revoke', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_id: deviceIdPrefix })
                });
                
                const data = await res.json();
                
                if (data.status === 'success') {
                    alert(`‚úÖ Â∑≤ÊàêÂäüÂêäÈîÄ ${data.revoked_count} ‰∏™ËÆæÂ§á`);
                    // ÈáçÊñ∞Âä†ËΩΩËÆæÂ§áÂàóË°®
                    loadDevicesForRevoke();
                    // Êõ¥Êñ∞UIÁä∂ÊÄÅ
                    await updateAuthUI();
                    await updateWriteButtons();
                } else {
                    alert('‚ùå ÂêäÈîÄËÆæÂ§áÂ§±Ë¥•');
                }
            } catch (e) {
                console.error('ÂêäÈîÄËÆæÂ§áÂ§±Ë¥•:', e);
                alert('‚ùå ÂêäÈîÄËÆæÂ§áÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
            }
        }

        function searchDevices() {
            const searchTerm = document.getElementById('deviceSearch').value.toLowerCase();
            const deviceCards = document.getElementById('revokeDeviceList').querySelectorAll('div');
            
            deviceCards.forEach(card => {
                const deviceText = card.textContent.toLowerCase();
                if (deviceText.includes(searchTerm)) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        }

        // Ê∑ªÂä†ËÆæÂ§áÁÆ°ÁêÜ‰∏ãÊãâËèúÂçïÁöÑÊòæÁ§∫/ÈöêËóèÈÄªËæë
        document.addEventListener('DOMContentLoaded', function() {
            // ‰ΩøÁî®Êõ¥ÂèØÈù†ÁöÑÈÄâÊã©Âô®ÔºåÂü∫‰∫éÊñáÊú¨ÂÜÖÂÆπËÄåÈùûCSS‰ΩçÁΩÆ
            const manageButtons = document.querySelectorAll('.action-button');
            const manageButton = Array.from(manageButtons).find(btn => 
                btn.textContent.includes('ËÆæÂ§áÁÆ°ÁêÜ') || btn.textContent.includes('‚öôÔ∏è')
            );
            
            if (manageButton) {
                const dropdownMenu = manageButton.querySelector('.dropdown-menu');
                if (dropdownMenu) {
                    manageButton.addEventListener('click', function(e) {
                        dropdownMenu.style.display = dropdownMenu.style.display === 'none' ? 'block' : 'none';
                        e.stopPropagation();
                    });
                    
                    // ÁÇπÂáªÂÖ∂‰ªñÂú∞ÊñπÂÖ≥Èó≠‰∏ãÊãâËèúÂçï
                    document.addEventListener('click', function() {
                        dropdownMenu.style.display = 'none';
                    });
                }
            }
        });
        
        window.addEventListener('DOMContentLoaded', updateWriteButtons);
    </script>
</body>

</html>
