<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态歌词展示</title>
    <style>
        :root {
            --rcolor: 1;
            --color: 0.25;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #121212;
            color: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            cursor: pointer;
            position: relative; /* 为背景容器提供定位上下文 */
        }

        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .background-container img,
        .background-container video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 等比缩放填充，无裁切 */
            opacity: 0.2; /* 20% 不透明度 */
        }

        .player-container {
            width: 90%;
            text-align: center;
        }

        .player-container.paused-mode {
            height: 100%;
            overflow: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE 10+ */
        }

        .player-container.paused-mode::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        /* 隐藏音频控件 */
        audio {
            display: none;
        }

        .lyrics-container {
            min-height: 15em; /* 使用 min-height 保证初始高度 */
            overflow: hidden; /* 隐藏动画中可能溢出的部分 */
            position: relative; /* 为绝对定位的子元素提供基准 */
            display: -webkit-flex;
            display: flex;
            -webkit-flex-direction: column;
            flex-direction: column;
            -webkit-justify-content: center;
            justify-content: center;
            -webkit-align-items: center;
            align-items: center;
        }

        .lyric-line {
            position: relative;
            font-size: calc(4.5em * var(--lyric-scale, 1));
            font-weight: bold;
            line-height: 1.5;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.2); /* 白色 20% 不透明 */
            width: 100%;
        }

        /* 模糊层容器 */
        .blur-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-wrap: wrap;
            justify-content: inherit;
            align-items: inherit;
            z-index: -1;
            pointer-events: none;
        }

        /* 模糊文本 */
        .blur-text {
            color: white;
            opacity: 0.1;
            filter: blur(8px);
            font-size: inherit;
            font-weight: inherit;
            line-height: inherit;
        }

        .lyric-line.left-aligned {
            justify-content: flex-start;
        }

        .lyric-line.center-aligned {
            justify-content: center;
        }

        .lyric-line.right-aligned {
            justify-content: flex-end;
        }

        .lyric-line.small-font {
            font-size: 2.25em; /* 原始尺寸 4.5em 的 50% */
        }

        .syllable {
            position: relative;
            display: inline-block;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.4); /* 柔和发光效果 */
            filter: blur(0);
            -webkit-filter: blur(0);
            background-repeat: no-repeat;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
        }

        .lyric-line.active {
            /*background: rgba(255,255,255,0.08);  可选：高亮当前行 */
            border-radius: 0.2em;
        }
        /* 新增：翻译行对齐样式 */
        .translation-line.left-aligned {
            text-align: left;
        }
        .translation-line.center-aligned {
            text-align: center;
        }
        .translation-line.right-aligned {
            text-align: right;
        }

        .font-slider-container {
            display: none; /* 默认隐藏 */
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        /* 仅在手机等小屏幕设备上显示滑块 */
        @media (max-width: 768px) {
            .font-slider-container {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="player-container" id="player-container">
        <audio id="audio-player"></audio>
        <div id="lyrics-container"></div>
    </div>
    <div class="font-slider-container">
        <input type="range" min="0.5" max="1.5" value="1" step="0.05" id="fontSlider">
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const audioPlayer = document.getElementById('audio-player');
            const lyricsContainer = document.getElementById('lyrics-container');
            const playerContainer = document.getElementById('player-container');
            const fontSlider = document.getElementById('fontSlider');
            let lyricsData = [];
            let forceCenterAlign = false; // 新增
            let translationData = [];

            // 动画时长控制（前端硬编码，同时由后端解析保持一致）
            const enterDuration =600;          // 歌词行进入动画时长（毫秒）
            const moveDuration = 600;           // 歌词行移动动画时长（毫秒）
            const exitDuration = 600;           // 歌词行退出动画时长（毫秒）
            const placeholderDuration = 50;     // 占位符（消失行）延时
            const lineDisplayOffset = 0.5;      // 歌词行提前0.3秒显示
            const useComputedDisappear = false;  // 是否使用后端计算的消失时机

            async function syncAnimationConfig() {
                try {
                    await fetch('/player/animation-config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            enterDuration,
                            moveDuration,
                            exitDuration,
                            placeholderDuration,
                            lineDisplayOffset,
                            useComputedDisappear
                        })
                    });
                } catch (error) {
                    console.warn('上传动画配置失败，将使用后端的默认值', error);
                }
            }

            let displayedLines = new Map(); // 使用 Map 跟踪所有显示的行
            let placeholderLines = new Map(); // 跟踪正在消失的行的占位符
            const customEasing = 'cubic-bezier(.27,.14,0,.99)';
            let showAllLinesWhenPaused = false; // 是否暂停时展示所有歌词行
            let rafId = null; // requestAnimationFrame ID
            const SYLLABLE_FADE_RATIO = 0.3;

            const moveTransitionCleanup = new WeakMap(); // 存储当前运行的位移动画信息

            function clearMoveTransition(element) {
                if (!element) {
                    return { residualX: 0, residualY: 0, progress: 0 };
                }
                const record = moveTransitionCleanup.get(element);
                if (!record) {
                    return { residualX: 0, residualY: 0, progress: 0 };
                }

                moveTransitionCleanup.delete(element);

                let progress = 0;
                let residualX = 0;
                let residualY = 0;

                const { animation, fromX = 0, fromY = 0 } = record;
                if (animation && animation.effect && typeof animation.effect.getComputedTiming === 'function') {
                    try {
                        const timing = animation.effect.getComputedTiming();
                        if (timing && typeof timing.progress === 'number') {
                            progress = Math.max(0, Math.min(1, timing.progress));
                        }
                    } catch (e) { /* 忽略 */ }
                }

                const remaining = 1 - progress;
                residualX = fromX * remaining;
                residualY = fromY * remaining;

                try {
                    animation.cancel();
                } catch (e) { /* 忽略 */ }

                element.style.transform = '';
                element.style.willChange = '';

                return { residualX, residualY, progress };
            }

            function runFlipTransition(element, deltaX, deltaY) {
                if (!element) return;
                const { residualX, residualY, progress } = clearMoveTransition(element);

                const adjustedDeltaX = deltaX + residualX;
                const adjustedDeltaY = deltaY + residualY;

                if (Math.abs(adjustedDeltaX) <= 0.5 && Math.abs(adjustedDeltaY) <= 0.5) return;

                // 若上一段动画未完成，则缩短时长并使用线性缓动以平滑衔接
                const durationFactor = progress > 0 ? Math.max(0.35, 1 - progress * 0.6) : 1;
                const animationDuration = Math.max(180, moveDuration * durationFactor);
                const easing = progress > 0.2 ? 'linear' : customEasing;

                element.style.willChange = 'transform';
                const animation = element.animate(
                    [
                        { transform: `translate(${adjustedDeltaX}px, ${adjustedDeltaY}px)` },
                        { transform: 'translate(0, 0)' }
                    ],
                    {
                        duration: animationDuration,
                        easing,
                        fill: 'forwards',
                        composite: 'add'
                    }
                );

                const record = {
                    animation,
                    fromX: adjustedDeltaX,
                    fromY: adjustedDeltaY
                };

                const finalize = () => {
                    if (moveTransitionCleanup.get(element) !== record) return;
                    moveTransitionCleanup.delete(element);
                    element.style.transform = '';
                    element.style.willChange = '';
                };

                animation.addEventListener('finish', finalize, { once: true });
                animation.addEventListener('cancel', finalize, { once: true });


                moveTransitionCleanup.set(element, record);
            }

            function generateBackgroundFadeStyle(elementWidth, elementHeight, fadeRatio) {
                            const fadeWidth = elementHeight * fadeRatio;
                            const widthRatio = elementWidth === 0 ? 0 : fadeWidth / elementWidth;

                            const totalAspect = 2 + widthRatio;
                            const widthInTotal = totalAspect === 0 ? 0 : widthRatio / totalAspect;
                            const leftPos = (1 - widthInTotal) / 2;

                            const from = leftPos * 100;
                            const to = (leftPos + widthInTotal) * 100;

                            const backgroundImage = `linear-gradient(to right, rgba(255, 255, 255, var(--rcolor)) ${from}%, rgba(255, 255, 255, var(--color)) ${to}%)`;
                            const backgroundSize = `${totalAspect * 100}% 100%`;
                            const totalPxWidth = -(elementWidth + fadeWidth);
                            return { backgroundImage, backgroundSize, totalPxWidth };
                        }

                        function createKaraokeFrames(blocks, index, lineDuration, fadeRatio) {
                            const frames = [];
                            if (!blocks[index]) return frames;

                            const element = blocks[index].ele;
                            const elementWidth = element.offsetWidth;
                            const computed = getComputedStyle(element);
                            const elementHeight = element.offsetHeight || parseFloat(computed.fontSize) || 0;
                            const fadeWidth = elementHeight * fadeRatio;
                            const fullBlockWidth = elementWidth + fadeWidth - 2;

                            let totalDuration = Math.max(1, lineDuration);
                            if (blocks.length > 0) {
                                const lastBlockEnd = blocks[blocks.length - 1].endTime;
                                const firstBlockStart = blocks[0].startTime;
                                totalDuration = Math.max(1, lastBlockEnd - firstBlockStart);
                            }

                            let widthBeforeSelf = 0;
                            for (let i = 0; i < index; i++) {
                                widthBeforeSelf += blocks[i].ele.offsetWidth;
                            }
                            if (index > 0) {
                                widthBeforeSelf += fadeWidth;
                            }

                            const minOffset = -(fullBlockWidth);
                            const clampOffset = (value) => Math.max(minOffset, Math.min(0, value));

                            let currentPos = -widthBeforeSelf - elementWidth - fadeWidth;
                            let timeOffset = 0;
                            let lastPos = currentPos;
                            let lastTime = 0;
                            let lastTimestamp = blocks[0].startTime;

                            const pushFrame = () => {
                                let time = Math.max(0, Math.min(1, timeOffset));
                                time = Math.round(time * 1e9) / 1e9;
                                if (time < lastTime) {
                                    time = lastTime;
                                }

                                const deltaTime = time - lastTime;
                                const moveOffset = currentPos - lastPos;
                                const ratio = moveOffset !== 0 ? Math.abs(deltaTime / moveOffset) : 0;

                                if (currentPos > minOffset && lastPos < minOffset) {
                                    const staticTime = Math.abs(lastPos - minOffset) * ratio;
                                    frames.push({
                                        backgroundPosition: `${clampOffset(lastPos)}px 0`,
                                        offset: lastTime + staticTime
                                    });
                                }

                                if (currentPos > 0 && lastPos < 0) {
                                    const staticTime = Math.abs(lastPos) * ratio;
                                    frames.push({
                                        backgroundPosition: `${clampOffset(currentPos)}px 0`,
                                        offset: lastTime + staticTime
                                    });
                                }

                                frames.push({
                                    backgroundPosition: `${clampOffset(currentPos)}px 0`,
                                    offset: time
                                });

                                lastPos = currentPos;
                                lastTime = time;
                            };

                            pushFrame();

                            blocks.forEach((block, i) => {
                                const absoluteStart = block.startTime;
                                const absoluteEnd = block.endTime;

                                const staticDuration = absoluteStart - lastTimestamp;
                                if (staticDuration > 0) {
                                    timeOffset += staticDuration / totalDuration;
                                    pushFrame();
                                    lastTimestamp = absoluteStart;
                                }

                                const moveDuration = Math.max(0, absoluteEnd - absoluteStart);
                                if (moveDuration > 0) {
                                    timeOffset += moveDuration / totalDuration;
                                    currentPos += block.ele.offsetWidth;
                                    if (i === 0) {
                                        currentPos += fadeWidth * 1.5;
                                    }
                                    if (i === blocks.length - 1) {
                                        currentPos += fadeWidth * 0.5;
                                    }
                                    pushFrame();
                                    lastTimestamp = absoluteEnd;
                                }
                            });

                            if (frames.length > 0) {
                                frames[frames.length - 1].offset = 1;
                            }

                            return frames;
                        }

                        function cancelLineAnimations(lineInfo, { commit } = {}) {
                            if (!lineInfo || !lineInfo.animations) return;
                            lineInfo.animations.forEach(animation => {
                                try {
                                    if (commit && typeof animation.commitStyles === 'function') {
                                        animation.commitStyles();
                                    }
                                } catch (e) { /* 忽略 */ }
                                try {
                                    animation.cancel();
                                } catch (e) { /* 忽略 */ }
                            });
                            lineInfo.animations = [];
                        }

                        function syncLineAnimations(lineInfo) {
                            if (!lineInfo || !lineInfo.animations || lineInfo.animations.length === 0) return;
                            const currentMs = Number.isFinite(audioPlayer.currentTime) ? audioPlayer.currentTime * 1000 : 0;
                            const lineStart = lineInfo.lineStartMs ?? 0;
                            const duration = Math.max(1, lineInfo.lineDuration ?? 0);
                            const localTime = currentMs - lineStart;
                            const clampedTime = Math.max(0, Math.min(duration, localTime));
                            lineInfo.animations.forEach(animation => {
                                try {
                                    animation.currentTime = clampedTime;
                                } catch (e) { /* 忽略 */ }
                            });
                        }

                        function prepareSyllableAnimations(lineIndex, lineEl, lineInfo, lineData) {
                            if (!lineInfo || !lineEl || !lineData || !Array.isArray(lineData.syllables) || lineData.syllables.length === 0) return;

                            const spans = Array.from(lineEl.querySelectorAll('.syllable'));
                            if (spans.length === 0) return;

                            cancelLineAnimations(lineInfo);

                            const blocks = [];
                            for (let i = 0; i < lineData.syllables.length; i++) {
                                const syllable = lineData.syllables[i];
                                const span = spans[i];
                                if (!span || !syllable) continue;
                                const startMs = Math.round(parseFloat(syllable.startTime) * 1000);
                                const durationMs = Math.round(parseFloat(syllable.duration) * 1000);
                                const endMs = startMs + durationMs;
                                blocks.push({
                                    ele: span,
                                    startTime: startMs,
                                    endTime: endMs
                                });
                            }

                            if (blocks.length === 0) return;

                            const firstStart = blocks.reduce((min, block) => Math.min(min, block.startTime), Number.MAX_SAFE_INTEGER);
                            const lastEnd = blocks.reduce((max, block) => Math.max(max, block.endTime), 0);
                            const lineDuration = Math.max(1, lastEnd - firstStart);

                            lineInfo.lineStartMs = firstStart;
                            lineInfo.lineDuration = lineDuration;
                            lineInfo.animations = [];

                            blocks.forEach((block, idx) => {
                                const span = block.ele;
                                const computedStyle = getComputedStyle(span);
                                const spanWidth = span.offsetWidth || parseFloat(computedStyle.width) || 0;
                                const spanHeight = span.offsetHeight || parseFloat(computedStyle.fontSize) || 0;
                                const { backgroundImage, backgroundSize, totalPxWidth } = generateBackgroundFadeStyle(spanWidth, spanHeight, SYLLABLE_FADE_RATIO);
                                span.style.backgroundImage = backgroundImage;
                                span.style.backgroundSize = backgroundSize;
                                span.style.backgroundPosition = `${totalPxWidth}px 0`;
                                span.style.backgroundRepeat = 'no-repeat';

                                const frames = createKaraokeFrames(blocks, idx, lineDuration, SYLLABLE_FADE_RATIO);
                                const animation = span.animate(frames, {
                                    duration: lineDuration,
                                    easing: 'linear',
                                    fill: 'both'
                                });
                                animation.pause();
                                lineInfo.animations.push(animation);
                            });

                            syncLineAnimations(lineInfo);
                        }

            // 卡拉OK进度更新函数 - 只更新当前活跃行
            function updateKaraokeProgress() {
                displayedLines.forEach((lineInfo) => {
                    syncLineAnimations(lineInfo);
                });
            }

            // requestAnimationFrame 循环
            function rafLoop() {
                updateKaraokeProgress();
                rafId = requestAnimationFrame(rafLoop);
            }

            // 解析 LRC 翻译，返回 [{timeMs, content}]
            function parseLrcTranslation(content) {
                const lines = content.split('\n');
                const result = [];
                const lrcTimeRe = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
                for (const line of lines) {
                    const match = lrcTimeRe.exec(line);
                    if (match) {
                        const min = parseInt(match[1], 10);
                        const sec = parseInt(match[2], 10);
                        let ms = match[3].length === 2 ? parseInt(match[3], 10) * 10 : parseInt(match[3], 10);
                        const timeMs = min * 60 * 1000 + sec * 1000 + ms;
                        const contentText = line.replace(lrcTimeRe, '').trim();
                        if (contentText) {
                            result.push({ timeMs, content: contentText });
                        }
                    }
                }
                return result;
            }

            async function loadData() {
                try {
                    const songInfoRes = await fetch('/song-info');
                    const songInfo = await songInfoRes.json();
                    audioPlayer.src = songInfo.song;
                    
                    // 检查并加载背景图片/视频
                    if (songInfo.meta && songInfo.meta["Background-image"]) {
                        // 移除路径前的 "./"
                        const backgroundPath = songInfo.meta["Background-image"].replace(/^\.\//, '');
                        loadBackground(backgroundPath);
                    }
                    
                    // 进入页面自动播放
                    setTimeout(() => {
                        audioPlayer.play().catch(() => {});
                    }, 0);

                    const lyricsRes = await fetch('/lyrics');
                    const lyricsJson = await lyricsRes.json();
                    lyricsData = lyricsJson.lyrics || [];

                    // 判断是否所有歌词行都不是 right（没有对唱标记）
                    forceCenterAlign = lyricsData.length > 0 && lyricsData.every(line => !line.style || line.style.align !== 'right');

                    // 优先使用后端返回的 translation 字段
                    translationData = Array.isArray(lyricsJson.translation) ? lyricsJson.translation.map(t => {
                        // 转换 time 为毫秒
                        const m = /^([0-9]{2}):([0-9]{2})\.([0-9]{2,3})$/.exec(t.time);
                        if (m) {
                            let ms = m[3].length === 2 ? parseInt(m[3], 10) * 10 : parseInt(m[3], 10);
                            t.timeMs = parseInt(m[1], 10) * 60 * 1000 + parseInt(m[2], 10) * 1000 + ms;
                        } else {
                            t.timeMs = 0;
                        }
                        return t;
                    }) : [];

                    // 如果没有 translation 字段，回退到原有 LRC 解析
                    if (translationData.length === 0 && songInfo.meta && songInfo.meta.lyrics) {
                        const parts = songInfo.meta.lyrics.split('::');
                        if (parts.length >= 3 && parts[2] && parts[2] !== '!') {
                            let transPath = parts[2];
                            if (transPath.startsWith('http://127.0.0.1:5000/songs/')) {
                                transPath = transPath.replace('http://127.0.0.1:5000/songs/', '');
                            }
                            if (transPath.endsWith('.lrc')) {
                                try {
                                    const resp = await fetch(transPath.startsWith('/') ? transPath : '/' + transPath);
                                    if (resp.ok) {
                                        const lrcText = await resp.text();
                                        translationData = parseLrcTranslation(lrcText);
                                    }
                                } catch (e) { /* 忽略 */ }
                            }
                        }
                    }

                    initLyrics();
                } catch (error) {
                    lyricsContainer.textContent = '无法加载歌词。';
                    console.error('Error loading data:', error);
                }
            }
            
            function createLineElement(lineIndex) {
                const line = lyricsData[lineIndex];
                if (!line) return null;

                const lineEl = document.createElement('div');
                lineEl.classList.add('lyric-line');
                lineEl.dataset.lineIndex = lineIndex;
                
                // 应用从后端传来的样式
                if (forceCenterAlign) {
                    lineEl.classList.add('center-aligned');
                    if (line.style && line.style.fontSize === 'small') {
                        lineEl.classList.add('small-font');
                    }
                } else if (line.style) {
                    if (line.style.align === 'right') {
                        lineEl.classList.add('right-aligned');
                    } else if (line.style.align === 'center') {
                        lineEl.classList.add('center-aligned');
                    } else {
                        lineEl.classList.add('left-aligned');
                    }
                    if (line.style.fontSize === 'small') {
                        lineEl.classList.add('small-font');
                    }
                } else {
                    lineEl.classList.add('left-aligned');
                }
                
                if(line.syllables && line.syllables.length > 0) {
                    const firstSyllable = line.syllables[0];
                    const lastSyllable = line.syllables[line.syllables.length - 1];
                    lineEl.dataset.startTime = firstSyllable.startTime;
                    lineEl.dataset.endTime = parseFloat(lastSyllable.startTime) + parseFloat(lastSyllable.duration);
                }
                const isSmallFont = (line.style && line.style.fontSize === 'small');
                
                // 创建模糊层（在翻译渲染之前，以便计算正确的高度）
                const blurLayer = document.createElement('div');
                blurLayer.className = 'blur-layer';
                
                // 复制上层歌词的样式
                blurLayer.style.justifyContent = getComputedStyle(lineEl).justifyContent;
                blurLayer.style.alignItems = getComputedStyle(lineEl).alignItems;
                
                // 为每个音节创建模糊文本
                line.syllables.forEach((syllable) => {
                    const blurText = document.createElement('span');
                    blurText.className = 'blur-text';
                    blurText.textContent = syllable.text;
                    blurText.style.fontSize = getComputedStyle(lineEl).fontSize;
                    blurText.style.fontWeight = getComputedStyle(lineEl).fontWeight;
                    blurText.style.lineHeight = getComputedStyle(lineEl).lineHeight;
                    
                    // 复制间距
                    if (syllable.text && syllable.text.includes(' ')) {
                        blurText.style.marginRight = '0.28em';
                    }
                    
                    blurLayer.appendChild(blurText);
                });
                
                lineEl.appendChild(blurLayer);
                
                line.syllables.forEach((syllable) => {
                    const syllableEl = document.createElement('span');
                    syllableEl.classList.add('syllable');
                    syllableEl.textContent = syllable.text;
                    syllableEl.dataset.startTime = syllable.startTime;
                    syllableEl.dataset.duration = syllable.duration;
                    // 如果音节内容包含空格，则加右边距
                    if (syllable.text && syllable.text.includes(' ')) {
                        // 使用 em 单位，使其可以随字体大小等比缩放
                        syllableEl.style.marginRight = '0.28em';
                    }
                    lineEl.appendChild(syllableEl);
                });

                // 翻译渲染：在歌词行下方插入翻译
                if (translationData.length > 0 && line.syllables && line.syllables.length > 0) {
                    // 取第一个音节的开始时间（秒->毫秒）
                    const startMs = Math.round(parseFloat(line.syllables[0].startTime) * 1000);
                    // 找到最接近的翻译（±200ms）
                    let minDelta = 201;
                    let bestTrans = null;
                    for (const t of translationData) {
                        const delta = Math.abs(t.timeMs - startMs);
                        if (delta < minDelta) {
                            minDelta = delta;
                            bestTrans = t;
                        }
                    }
                    if (bestTrans && minDelta <= 200) {
                        const transDiv = document.createElement('div');
                        transDiv.className = 'translation-line';
                        // 字体大小：正常歌词翻译为0.5em，背景人声的翻译为0.8em
                        transDiv.style.fontSize = isSmallFont ? '0.8em' : '0.5em';
                        transDiv.style.color = '#ffffff';
                        transDiv.style.fontWeight = 'normal';
                        transDiv.style.lineHeight = '1.2';
                        transDiv.style.marginTop = '0.1em';
                        transDiv.textContent = bestTrans.content;
                        // 强制换行并允许文本对齐
                        transDiv.style.width = '100%';
                        // 翻译对齐方式与主歌词一致
                        if (lineEl.classList.contains('left-aligned')) transDiv.classList.add('left-aligned');
                        if (lineEl.classList.contains('center-aligned')) transDiv.classList.add('center-aligned');
                        if (lineEl.classList.contains('right-aligned')) transDiv.classList.add('right-aligned');
                        lineEl.appendChild(transDiv);
                        
                        // 如果有翻译，调整模糊层高度以避免重叠
                        setTimeout(() => {
                            const transHeight = transDiv.offsetHeight;
                            if (transHeight > 0 && blurLayer) {
                                blurLayer.style.height = `calc(100% - ${transHeight}px)`;
                            }
                        }, 0);
                    }
                }

                lineEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (lineEl.dataset.startTime) {
                        audioPlayer.currentTime = parseFloat(lineEl.dataset.startTime);
                        audioPlayer.play();
                    }
                });
                return lineEl;
            }

            function initLyrics() {
                lyricsContainer.innerHTML = '';
                displayedLines.clear();
                if (lyricsData.length === 0) {
                     lyricsContainer.textContent = '暂无歌词。';
                     return;
                }
            }

            function addLine(lineIndex) {
                if (displayedLines.has(lineIndex)) return;

                // 如果存在该行的占位符，立即移除，为新行让路
                if (placeholderLines.has(lineIndex)) {
                    const placeholderInfo = placeholderLines.get(lineIndex);
                    clearTimeout(placeholderInfo.removalTimer);
                    clearMoveTransition(placeholderInfo.element);
                    placeholderInfo.element.remove();
                    placeholderLines.delete(lineIndex);
                }

                const incomingLine = createLineElement(lineIndex);
                if (!incomingLine) return;

                // 并发锁：如果动画未完成，不允许重复添加
                if (incomingLine.animationLock) return;
                incomingLine.animationLock = true;

                // 找到下一个比当前 lineIndex 大的歌词行
                let inserted = false;
                const children = Array.from(lyricsContainer.children);
                for (let i = 0; i < children.length; i++) {
                    const childIndex = parseInt(children[i].dataset.lineIndex, 10);
                    if (childIndex > lineIndex) {
                        lyricsContainer.insertBefore(incomingLine, children[i]);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    lyricsContainer.appendChild(incomingLine);
                }

                const lineInfo = { element: incomingLine };
                displayedLines.set(lineIndex, lineInfo);

                const animation = safeAnimate(incomingLine, [
                    { opacity: 0, filter: 'blur(5px)', '-webkit-filter': 'blur(5px)' },
                    { opacity: 1, filter: 'blur(0)', '-webkit-filter': 'blur(0)' }
                ], {
                    duration: enterDuration,
                    easing: customEasing,
                    fill: 'forwards'
                });
                animation.onfinish = () => {
                    incomingLine.animationLock = false;
                };

                const lineData = lyricsData[lineIndex];
                if (lineData) {
                    prepareSyllableAnimations(lineIndex, incomingLine, lineInfo, lineData);
                    requestAnimationFrame(() => {
                        if (displayedLines.has(lineIndex)) {
                            prepareSyllableAnimations(lineIndex, incomingLine, lineInfo, lineData);
                        }
                    });
                }
            }

            function removeLine(lineIndex) {
                const lineInfo = displayedLines.get(lineIndex);
                if (!lineInfo) return;

                const outgoingLine = lineInfo.element;

                cancelLineAnimations(lineInfo, { commit: true });

                // 记录当前位置用于保持淡出起点
                const originalRect = outgoingLine.getBoundingClientRect();

                // 并发锁：动画未完成时禁止移除
                if (outgoingLine.animationLock) return;
                outgoingLine.animationLock = true;

                // 1. 创建并插入占位符
                const placeholderEl = document.createElement('div');
                placeholderEl.style.height = `${originalRect.height}px`; // 维持布局高度
                outgoingLine.before(placeholderEl); // 插入到原位置

                const scrollX = window.scrollX || window.pageXOffset || 0;
                const scrollY = window.scrollY || window.pageYOffset || 0;
                clearMoveTransition(outgoingLine);

                // 2. 克隆一个节点用于淡出动画，原节点立即移出布局
                const fadeLine = outgoingLine.cloneNode(true);
                fadeLine.classList.remove('active');
                fadeLine.style.position = 'absolute';
                fadeLine.style.left = `${originalRect.left + scrollX}px`;
                fadeLine.style.top = `${originalRect.top + scrollY}px`;
                fadeLine.style.width = `${originalRect.width}px`;
                fadeLine.style.margin = '0';
                fadeLine.style.pointerEvents = 'none';
                fadeLine.style.transform = '';
                fadeLine.style.willChange = '';
                document.body.appendChild(fadeLine);

                outgoingLine.remove();

                const animation = safeAnimate(fadeLine, [
                    { opacity: 1, filter: 'blur(0)', '-webkit-filter': 'blur(0)' },
                    { opacity: 0, filter: 'blur(5px)', '-webkit-filter': 'blur(5px)' }
                ], {
                    duration: exitDuration,
                    easing: customEasing,
                    fill: 'forwards'
                });
                animation.onfinish = () => {
                    outgoingLine.animationLock = false;
                    fadeLine.remove();
                };

                // 3. 100ms后再移除占位符并触发补位动画
                const removalTimer = setTimeout(() => {
                    // FLIP - FIRST: 记录所有元素在占位符消失前的位置
                    const oldPositions = new Map();
                    const recordPosition = (map, keyPrefix) => {
                        map.forEach((info, index) => {
                            // 排除即将被移除的当前占位符
                            if (keyPrefix === 'placeholder-' && index === lineIndex) return;
                            oldPositions.set(`${keyPrefix}${index}`, info.element.getBoundingClientRect());
                        });
                    };
                    recordPosition(displayedLines, 'line-');
                    recordPosition(placeholderLines, 'placeholder-');

                    // DOM 操作：移除占位符
                    clearMoveTransition(placeholderEl);
                    placeholderEl.remove();
                    placeholderLines.delete(lineIndex);

                    // FLIP - LAST: 读取新位置
                    const newPositions = new Map();
                    const readNewPosition = (map, keyPrefix) => {
                        map.forEach((info, index) => {
                            const key = `${keyPrefix}${index}`;
                            if (oldPositions.has(key)) {
                                newPositions.set(key, {
                                    element: info.element,
                                    rect: info.element.getBoundingClientRect()
                                });
                            }
                        });
                    };
                    readNewPosition(displayedLines, 'line-');
                    readNewPosition(placeholderLines, 'placeholder-');
                    
                    // FLIP - INVERT & PLAY
                    newPositions.forEach((newInfo, key) => {
                        const oldRect = oldPositions.get(key);
                        const newRect = newInfo.rect;
                        const deltaX = oldRect.left - newRect.left;
                        const deltaY = oldRect.top - newRect.top;

                        runFlipTransition(newInfo.element, deltaX, deltaY);
                    });
                }, placeholderDuration); // 100ms后再移除占位符

                placeholderLines.set(lineIndex, { element: placeholderEl, removalTimer: removalTimer });
                displayedLines.delete(lineIndex);
            }

            function updateLyricsDisplay() {
                const currentTime = audioPlayer.currentTime;
                
                // FIRST: 记录所有当前显示行和占位符的位置
                const oldPositions = new Map();
                displayedLines.forEach((lineInfo, lineIndex) => {
                    oldPositions.set(`line-${lineIndex}`, lineInfo.element.getBoundingClientRect());
                });
                placeholderLines.forEach((lineInfo, lineIndex) => {
                    oldPositions.set(`placeholder-${lineIndex}`, lineInfo.element.getBoundingClientRect());
                });

                // 歌词行显示逻辑
                if (showAllLinesWhenPaused) {
                    // 暂停时，全部歌词行都显示
                    lyricsData.forEach((line, index) => {
                        if (!displayedLines.has(index)) {
                            addLine(index);
                        }
                    });
                    // 多余的行要移除
                    Array.from(displayedLines.keys()).forEach(index => {
                        if (index >= lyricsData.length) {
                            removeLine(index);
                        }
                    });
                } else {
                    // 正常模式，使用后端计算好的消失时机
                    lyricsData.forEach((line, index) => {
                        // 确保歌词行有音节数据
                        if (!line.syllables || line.syllables.length === 0) return;

                        const startTime = parseFloat(line.syllables[0].startTime); // 单位：秒
                        const disappearTime = line.disappearTime / 1000; // 从后端获取（毫秒 -> 秒）
                        
                        const isLineDisplayed = displayedLines.has(index);

                        // 判断是否应显示/消失
                        const isLineActive = (currentTime >= startTime - lineDisplayOffset) && (currentTime < disappearTime);

                        if (isLineActive && !isLineDisplayed) {
                            addLine(index);
                        } else if (!isLineActive && isLineDisplayed) {
                            removeLine(index);
                        }
                    });
                }

                // LAST: 读取新位置
                const newPositions = [];
                displayedLines.forEach((lineInfo, lineIndex) => {
                    const key = `line-${lineIndex}`;
                    if (oldPositions.has(key)) {
                        newPositions.push({
                            key,
                            element: lineInfo.element,
                            rect: lineInfo.element.getBoundingClientRect()
                        });
                    }
                });
                placeholderLines.forEach((lineInfo, lineIndex) => {
                    const key = `placeholder-${lineIndex}`;
                    if (oldPositions.has(key)) {
                        newPositions.push({
                            key,
                            element: lineInfo.element,
                            rect: lineInfo.element.getBoundingClientRect()
                        });
                    }
                });

                // INVERT & PLAY: 为移动的元素应用动画
                newPositions.forEach(({ key, element, rect }) => {
                    const oldRect = oldPositions.get(key);
                    if (!oldRect) return;
                    const deltaX = oldRect.left - rect.left;
                    const deltaY = oldRect.top - rect.top;
                    runFlipTransition(element, deltaX, deltaY);
                });
                
                // 音节高亮逻辑 - 只处理active状态，卡拉OK进度由rafLoop处理
                if (displayedLines.size > 0) {
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        const lineEl = lineInfo.element;
                        const startTime = parseFloat(lineEl.dataset.startTime);
                        const endTime = parseFloat(lineEl.dataset.endTime);
                        // 当前播放歌词行加 active
                        if (currentTime >= startTime - lineDisplayOffset && currentTime < endTime) {
                            lineEl.classList.add('active');
                        } else {
                            lineEl.classList.remove('active');
                        }
                        syncLineAnimations(lineInfo);
                    });
                }
            }

            audioPlayer.addEventListener('timeupdate', updateLyricsDisplay);
            // 监听暂停/播放事件，切换展示模式
            audioPlayer.addEventListener('pause', () => {
                showAllLinesWhenPaused = true;
                playerContainer.classList.add('paused-mode');
                updateLyricsDisplay();
                // 滚动到当前播放的歌词行
                setTimeout(() => {
                    const currentLine = document.querySelector('.lyric-line.active');
                    if (currentLine) {
                        currentLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
                // 停止动画循环
                if (rafId != null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
            });
            audioPlayer.addEventListener('play', () => {
                showAllLinesWhenPaused = false;
                playerContainer.classList.remove('paused-mode');
                updateLyricsDisplay();
                // 启动动画循环
                if (rafId == null) {
                    rafLoop();
                }
            });
            
            function togglePlayPause() {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            }

            document.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.code === 'Space') {
                    event.preventDefault();
                    togglePlayPause();
                } else if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 5);
                } else if (event.key === 'ArrowRight') {
                    event.preventDefault();
                    audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 5);
                }
            });
            
            // 全局点击：只要不是歌词行就切换播放/暂停
            document.body.addEventListener('click', function(e) {
                // 如果点击的是歌词行或其子元素，什么都不做
                if (e.target.closest('.lyric-line')) return;
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            });

            await syncAnimationConfig();
            await loadData();
            
            // 页面加载后自动启动动画循环（如果音频正在播放）
            setTimeout(() => {
                if (!audioPlayer.paused && rafId == null) {
                    rafLoop();
                }
            }, 100);
            
            // 字体大小调整滑块逻辑
            fontSlider.addEventListener('input', (e) => {
                playerContainer.style.setProperty('--lyric-scale', e.target.value);
                // 将设置存入 localStorage
                localStorage.setItem('lyricScale', e.target.value);
                requestAnimationFrame(() => {
                    displayedLines.forEach((lineInfo, index) => {
                        const lineData = lyricsData[index];
                        if (lineInfo?.element && lineData) {
                            prepareSyllableAnimations(index, lineInfo.element, lineInfo, lineData);
                        }
                    });
                });
            });

            // 页面加载时应用缓存的字体大小
            const savedScale = localStorage.getItem('lyricScale');
            if (savedScale) {
                fontSlider.value = savedScale;
                playerContainer.style.setProperty('--lyric-scale', savedScale);
                requestAnimationFrame(() => {
                    displayedLines.forEach((lineInfo, index) => {
                        const lineData = lyricsData[index];
                        if (lineInfo?.element && lineData) {
                            prepareSyllableAnimations(index, lineInfo.element, lineInfo, lineData);
                        }
                    });
                });
            }

            // Safari animate 兼容降级
            function safeAnimate(element, keyframes, options) {
                if (element.animate) {
                    return element.animate(keyframes, options);
                } else {
                    // Safari 旧版降级：直接设置最终样式
                    Object.assign(element.style, keyframes[keyframes.length - 1]);
                    return { onfinish: () => {} };
                }
            }

            // 加载背景图片或视频
            async function loadBackground(backgroundPath) {
                // 统一成不带 "./" 的路径
                let path = backgroundPath.replace(/^\.\//, ''); // "./songs/xxx.jpg" -> "songs/xxx.jpg"

                // 如果已经是绝对 URL（含 http/https），直接用
                const isAbsolute = /^https?:\/\//i.test(path);

                // 如果是相对的 "songs/..."，在 Flask 配置下，直接加个前导斜杠即可
                const url = isAbsolute ? path : (path.startsWith('/') ? path : '/' + path);

                const container = document.createElement('div');
                container.className = 'background-container';
                document.body.appendChild(container);

                const ext = path.split('.').pop().toLowerCase();
                const isVideo = ['mp4','webm','ogg'].includes(ext);

                if (isVideo) {
                    const video = document.createElement('video');
                    video.src = url;         // ✅ 不再拼 /static，也不整体 encode
                    video.muted = true;
                    video.loop = true;
                    video.autoplay = true;
                    video.onerror = () => container.remove();
                    container.appendChild(video);
                } else {
                    const img = document.createElement('img');
                    img.src = url;           // ✅ 同上
                    img.onerror = () => container.remove();
                    container.appendChild(img);
                }
            }
        });
    </script>
</body>
</html>
