<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态歌词展示</title>
    <style>
        :root {
            --rcolor: 1;
            --color: 0.25;
            --lyric-scale: 1;
            --lyric-scale-duration: 360ms;
            --lyric-scale-easing: cubic-bezier(0.32, 0.78, 0.12, 1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #121212;
            color: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            cursor: pointer;
            position: relative; /* 为背景容器提供定位上下文 */
        }

        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .background-container img,
        .background-container video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 等比缩放填充，无裁切 */
            opacity: 0.2; /* 20% 不透明度 */
            display: block;
        }

        .background-container canvas {
            width: 100%;
            height: 100%;
            display: block;
            opacity: 0.45;
        }

        .player-container {
            width: 90%;
            text-align: center;
        }

        :where(#albumSidePanel, #amll-stub-host, body) .song-info-container {
            box-sizing: border-box;
            width: min(100%, 520px);
            max-width: min(100%, 520px);
            margin: 0 auto;
        }

        :where(#albumSidePanel, #amll-stub-host, body) #albumCoverContainer {
            width: min(320px, 60vw);
            max-width: min(320px, 60vw);
        }

        :where(#albumSidePanel, #amll-stub-host, body) #albumInfo {
            width: 100% !important;
            max-width: 100% !important;
        }

        :where(#albumSidePanel, #amll-stub-host, body) #songTitle,
        :where(#albumSidePanel, #amll-stub-host, body) #songArtist {
            display: block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-container.paused-mode {
            height: 100%;
            overflow: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE 10+ */
        }

        .player-container.paused-mode::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        /* 隐藏音频控件 */
        audio {
            display: none;
        }

        .lyrics-container {
            min-height: 15em; /* 使用 min-height 保证初始高度 */
            overflow: hidden; /* 隐藏动画中可能溢出的部分 */
            position: relative; /* 为绝对定位的子元素提供基准 */
            display: -webkit-flex;
            display: flex;
            -webkit-flex-direction: column;
            flex-direction: column;
            -webkit-justify-content: center;
            justify-content: center;
            -webkit-align-items: center;
            align-items: center;
        }

        .lyric-line {
            position: relative;
            font-size: calc(4.5em * var(--lyric-scale, 1));
            font-weight: bold;
            line-height: 1.5;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.2); /* 白色 20% 不透明 */
            width: 100%;
            word-break: keep-all;
            white-space: normal;
            overflow: hidden;
            transition:
                font-size var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1)),
                line-height var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1));
        }

        /* 对于“侵入式”连体字体，允许溢出显示，避免字形被裁 */
        .lyric-line.allow-overflow {
            overflow: visible;
        }
        .lyric-line.allow-overflow .blur-layer,
        .lyric-line.allow-overflow .syllable,
        .lyric-line.allow-overflow .blur-text,
        .lyric-line.allow-overflow .word-wrapper {
            overflow: visible !important;
        }

        /* 模糊层容器 */
        .blur-layer {
            position: absolute;
            left: 0;
            width: 100%;
            --blur-safe-pad: 24px; /* 更大的垂直安全边距以适配高 x-height 字体 */
            top: calc(var(--blur-safe-pad) * -0.5);
            height: calc(100% + var(--blur-safe-pad));
            display: flex;
            flex-wrap: wrap;
            justify-content: inherit;
            align-items: inherit;
            z-index: -1;
            pointer-events: none;
        }

        .lyric-line.allow-overflow .blur-layer {
            overflow: visible;
        }

        /* 模糊文本 */
        .blur-text {
            color: white;
            opacity: 0.1;
            filter: blur(8px);
            font-size: inherit;
            font-weight: inherit;
            line-height: inherit;
        }

        .lyric-line.left-aligned {
            justify-content: flex-start;
        }

        .lyric-line.center-aligned {
            justify-content: center;
        }

        .lyric-line.right-aligned {
            justify-content: flex-end;
        }

        .lyric-line.small-font {
            font-size: calc(2.25em * var(--lyric-scale, 1)); /* 继承缩放比，保持背景歌词更小 */
        }

        .syllable {
            position: relative;
            display: inline-block;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.4); /* 柔和发光效果 */
            filter: blur(0);
            -webkit-filter: blur(0);
            background-repeat: no-repeat;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            flex-shrink: 0;
            white-space: nowrap;
            transform: translateY(0); /* 为逐音节上浮动画设定基线 */
            will-change: transform, background-position;
            margin-top: 0.05em;
            margin-bottom: 0.05em;
        }

        /* 自定义字体行：禁用卡拉OK渐变，直接用纯色，防止字形互相遮挡 */
        .syllable.no-gradient {
            background: none !important;
            background-image: none !important;
            background-size: auto !important;
            background-position: initial !important;
            background-repeat: initial !important;
            background-clip: initial !important;
            -webkit-background-clip: initial !important;
            color: rgba(255, 255, 255, 0.95);
            -webkit-text-fill-color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.35);
        }

        .syllable.non-latin,
        .blur-text.non-latin {
            white-space: normal;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .syllable.non-latin {
            flex-shrink: 1;
        }

        .word-wrapper {
            display: inline-flex;
            flex: 0 0 auto;
            flex-wrap: nowrap;
        }

        .word-space {
            display: inline-flex;
            flex: 0 0 auto;
            white-space: pre;
        }

        .lyric-line.active {
            /*background: rgba(255,255,255,0.08);  可选：高亮当前行 */
            border-radius: 0.2em;
        }
        /* 新增：翻译行对齐样式 */
        .translation-line.left-aligned {
            text-align: left;
        }
        .translation-line.center-aligned {
            text-align: center;
        }
        .translation-line.right-aligned {
            text-align: right;
        }
        .translation-line {
            transition:
                font-size var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1)),
                line-height var(--lyric-scale-duration, 360ms) var(--lyric-scale-easing, cubic-bezier(0.32, 0.78, 0.12, 1));
        }

        .font-slider-container {
            display: none; /* 默认隐藏 */
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        #font-load-tip {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 14px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1200;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }
        
        /* 仅在手机等小屏幕设备上显示滑块 */
        @media screen and (max-width: 768px), screen and (orientation: portrait) {
            .font-slider-container {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="player-container" id="player-container">
        <audio id="audio-player"></audio>
        <div id="lyrics-container"></div>
    </div>
    <div class="font-slider-container">
        <input type="range" min="0.5" max="1.5" value="1" step="0.05" id="fontSlider">
    </div>

    <script>
        const AMLL_SETTINGS_STORAGE_KEY = 'amll_background_settings';
        const fontLoadPromises = new Map();
        const fontClassCache = new Map();
        let fontTipTimer = null;

        function showFontTip(message) {
            if (!message) return;
            let el = document.getElementById('font-load-tip');
            if (!el) {
                el = document.createElement('div');
                el.id = 'font-load-tip';
                document.body.appendChild(el);
            }
            el.textContent = message;
            el.style.opacity = '1';
            if (fontTipTimer) clearTimeout(fontTipTimer);
            fontTipTimer = setTimeout(() => {
                el.style.opacity = '0';
            }, 4000);
        }

        async function loadFontFromGoogle(fontName) {
            const encodedName = encodeURIComponent(fontName).replace(/%20/g, '+');
            const cssUrl = `https://fonts.googleapis.com/css2?family=${encodedName}:wght@400;500;600;700&display=swap`;
            const res = await fetch(cssUrl, { mode: 'cors' });
            if (!res.ok) {
                throw new Error(`Google Fonts responded ${res.status}`);
            }
            const cssText = await res.text();
            if (!cssText || !cssText.includes('@font-face')) {
                throw new Error('Google Fonts returned empty CSS');
            }
            const styleEl = document.createElement('style');
            styleEl.textContent = cssText;
            document.head.appendChild(styleEl);
        }

        async function loadFontFromCdnFonts(fontName) {
            const encodedName = encodeURIComponent(fontName);
            const cssUrl = `https://fonts.cdnfonts.com/css/${encodedName}`;
            const res = await fetch(cssUrl, { mode: 'cors' });
            if (!res.ok) {
                throw new Error(`cdnfonts responded ${res.status}`);
            }
            const cssText = await res.text();
            if (!cssText || !cssText.includes('@font-face')) {
                throw new Error('cdnfonts returned empty CSS');
            }
            const styleEl = document.createElement('style');
            styleEl.textContent = cssText;
            document.head.appendChild(styleEl);
        }

        async function tryLocalFont(fontName, aliases) {
            const encodedName = encodeURIComponent(fontName);
            const candidates = [
                `/songs/${encodedName}.woff2`,
                `/songs/${encodedName}.ttf`,
                `/songs/${encodedName}.otf`,
                `/fonts/${encodedName}.woff2`,
                `/fonts/${encodedName}.ttf`,
                `/fonts/${encodedName}.otf`
            ];
            for (const url of candidates) {
                try {
                    const res = await fetch(url, { method: 'GET', cache: 'force-cache' });
                    if (!res.ok) continue;
                    const styleEl = document.createElement('style');
                    const localParts = (aliases || [fontName]).map(a => `local('${a}')`).join(', ');
                    styleEl.textContent = `
@font-face {
    font-family: '${fontName}';
    src: ${localParts ? localParts + ',' : ''} url('${url}');
    font-display: swap;
}`;
                    document.head.appendChild(styleEl);
                    return url;
                } catch (err) {
                    console.warn('Local font fetch failed', fontName, url, err);
                }
            }
            return '';
        }

        function isFontAvailable(fontName) {
            if (!fontName || !document.fonts || !document.fonts.check) return false;
            try {
                return document.fonts.check(`1em "${fontName}"`);
            } catch (err) {
                return false;
            }
        }

        function measureFontDifference(fontName) {
            const name = (fontName || '').trim();
            if (!name) return false;
            const tester = document.createElement('span');
            tester.textContent = 'ABCDEFGHIJKLMnopqrstuvwxyz 1234567890 汉字かなカナ';
            tester.style.position = 'absolute';
            tester.style.visibility = 'hidden';
            tester.style.fontSize = '32px';
            tester.style.left = '-9999px';
            tester.style.fontFamily = 'serif';
            document.body.appendChild(tester);
            const serifWidth = tester.getBoundingClientRect().width;
            tester.style.fontFamily = `"${name}", serif`;
            const customWidth = tester.getBoundingClientRect().width;
            document.body.removeChild(tester);
            return Math.abs(customWidth - serifWidth) > 0.5;
        }

        function buildFontAliases(fontName) {
            const raw = (fontName || '').trim();
            if (!raw) return [];
            const aliases = new Set();
            aliases.add(raw);
            aliases.add(raw.replace(/[-_]+/g, ' '));
            aliases.add(raw.replace(/[-_]+/g, ''));
            const dashSplit = raw.split(/[-_ ]+/);
            if (dashSplit.length > 1) {
                aliases.add(dashSplit[0]);
            }
            return Array.from(aliases).filter(Boolean);
        }

        function parseFontStack(fontValue) {
            if (!fontValue) return [];
            return fontValue.split(',')
                .map((name) => (name || '').trim())
                .filter(Boolean);
        }

        const SCRIPT_CHECKERS = {
            ja: /[\u3040-\u30ff\u31f0-\u31ff\u4e00-\u9fff]/,
            en: /[A-Za-z]/
        };

        function detectScript(text) {
            if (!text) return '';
            if (SCRIPT_CHECKERS.ja.test(text)) return 'ja';
            if (SCRIPT_CHECKERS.en.test(text)) return 'en';
            return '';
        }

        function selectFontForText(text, fontMap, defaultFont, fallbackStack) {
            const script = detectScript(text);
            const hasMap = fontMap && script && Object.prototype.hasOwnProperty.call(fontMap, script);
            if (hasMap) {
                const mapped = fontMap[script];
                if (mapped) return mapped; // 显式指定
                return ''; // 显式空：使用系统默认
            }
            if (defaultFont && (!script || script === 'en')) return defaultFont;
            return '';
        }

        function buildFontValue(primary, fallbackList, bodyFont, allowFallback = true) {
            const esc = (v) => v.replace(/'/g, "\\'");
            const ordered = [];
            if (primary) ordered.push(`'${esc(primary)}'`);
            if (allowFallback && primary) {
                (fallbackList || []).forEach((f) => {
                    if (f && f !== primary) {
                        ordered.push(`'${esc(f)}'`);
                    }
                });
            }
            if (bodyFont) {
                ordered.push(bodyFont);
            }
            return ordered.join(', ');
        }

        function fontClassName(fontName) {
            return `custom-font-${fontName.replace(/[^a-zA-Z0-9_-]/g, '-') || 'unknown'}`;
        }

        function ensureFontClass(fontName, fontFamilyValue) {
            const name = (fontName || '').trim();
            if (!name || !fontFamilyValue) return '';
            if (fontClassCache.has(name)) return fontClassCache.get(name);
            const cls = fontClassName(name);
            const styleEl = document.createElement('style');
            styleEl.textContent = `
.${cls} {
    font-family: ${fontFamilyValue} !important;
}`;
            document.head.appendChild(styleEl);
            fontClassCache.set(name, cls);
            return cls;
        }

        function ensureFontLoaded(fontName) {
            const name = (fontName || '').trim();
            if (!name) return Promise.resolve();
            if (fontLoadPromises.has(name)) {
                return fontLoadPromises.get(name);
            }
            showFontTip(`尝试加载字体 ${name} ...`);
            const loader = (async () => {
                try {
                    let loaded = false;
                    let localUrl = '';
                    const fontStack = parseFontStack(name);
                    for (const fontCandidate of fontStack.length ? fontStack : [name]) {
                        const candidateAliases = buildFontAliases(fontCandidate);
                        const url = await tryLocalFont(fontCandidate, candidateAliases);
                        localUrl = localUrl || url;
                        if (url && document.fonts && document.fonts.load) {
                            try {
                                await document.fonts.load(`1em "${fontCandidate}"`);
                            } catch (err) {
                                console.warn('fonts.load failed', fontCandidate, err);
                            }
                        }
                    }
                    if (localUrl && isFontAvailable(name)) {
                        loaded = true;
                        showFontTip(`字体 ${name} 已加载（本地文件 ${localUrl}）`);
                    }
                    try {
                        await loadFontFromGoogle(name);
                        loaded = true;
                    } catch (err1) {
                        console.warn('Google Fonts load failed', name, err1);
                    }
                    if (!loaded) {
                        try {
                            await loadFontFromCdnFonts(name);
                            loaded = true;
                        } catch (err2) {
                            console.warn('cdnfonts load failed', name, err2);
                        }
                    }

                    // 触发一次测量，确保浏览器开始请求字体文件
                    if (document.fonts && document.fonts.load) {
                        try {
                            await document.fonts.load(`1em "${name}"`);
                        } catch (err) {
                            console.warn('fonts.load failed', name, err);
                        }
                    }

                    const finalAvailable = isFontAvailable(name);
                    const visuallyDifferent = finalAvailable && measureFontDifference(name);
                    if (finalAvailable && visuallyDifferent) {
                        const source = localUrl ? `本地文件 ${localUrl}` : (loaded ? '远程字体' : '系统/本地字体');
                        showFontTip(`字体 ${name} 已可用（${source}）`);
                    } else if (finalAvailable) {
                        showFontTip(`字体 ${name} 已检测到，但显示效果与系统字体无差异，可能未实际生效`);
                    } else {
                        showFontTip(`字体 ${name} 加载失败或未找到，请确认文件存在 /songs 或 /fonts 目录`);
                    }
                } catch (err) {
                    console.warn('Font load failed', name, err);
                    showFontTip(`字体 ${name} 加载失败，请确认已安装或手动引入`);
                }
            })();
            fontLoadPromises.set(name, loader);
            return loader;
        }

        function guardAmllSettingsStorage() {
            try {
                const storage = window.localStorage;
                if (!storage) {
                    return () => { };
                }

                const originalObject = {
                    getItem: storage.getItem,
                    setItem: storage.setItem,
                    removeItem: storage.removeItem,
                    clear: storage.clear
                };

                let mirror = originalObject.getItem
                    ? originalObject.getItem.call(storage, AMLL_SETTINGS_STORAGE_KEY)
                    : null;

                const normalizeKey = (key) => (typeof key === 'string' ? key : String(key));

                const guardedGet = function (key) {
                    if (normalizeKey(key) === AMLL_SETTINGS_STORAGE_KEY) {
                        return mirror;
                    }
                    return originalObject.getItem
                        ? originalObject.getItem.call(this, key)
                        : null;
                };

                const guardedSet = function (key, value) {
                    if (normalizeKey(key) === AMLL_SETTINGS_STORAGE_KEY) {
                        mirror = String(value);
                        return undefined;
                    }
                    return originalObject.setItem
                        ? originalObject.setItem.call(this, key, value)
                        : undefined;
                };

                const guardedRemove = function (key) {
                    if (normalizeKey(key) === AMLL_SETTINGS_STORAGE_KEY) {
                        mirror = null;
                        return undefined;
                    }
                    return originalObject.removeItem
                        ? originalObject.removeItem.call(this, key)
                        : undefined;
                };

                const guardedClear = function () {
                    if (originalObject.clear) {
                        originalObject.clear.call(this);
                    }
                    if (mirror !== null && mirror !== undefined && originalObject.setItem) {
                        try {
                            originalObject.setItem.call(this, AMLL_SETTINGS_STORAGE_KEY, mirror);
                        } catch (error) {
                            console.warn('[AMLL] 恢复 AMLL 缓存失败', error);
                        }
                    }
                };

                storage.getItem = guardedGet;
                storage.setItem = guardedSet;
                storage.removeItem = guardedRemove;
                storage.clear = guardedClear;

                return () => {
                    storage.getItem = originalObject.getItem;
                    storage.setItem = originalObject.setItem;
                    storage.removeItem = originalObject.removeItem;
                    storage.clear = originalObject.clear;
                };
            } catch (error) {
                console.warn('[AMLL] 设置缓存保护失败', error);
                return () => { };
            }
        }

        if (!window.__AMLL_DEFAULT_ALBUM__) {
            window.__AMLL_DEFAULT_ALBUM__ = "{{ url_for('static', filename='icons/icon-512x512.png') }}";
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const restoreAmllStorage = guardAmllSettingsStorage();
            window.addEventListener('beforeunload', () => {
                try {
                    restoreAmllStorage();
                } catch (error) {
                    console.warn('[AMLL] 恢复 Storage 失败', error);
                }
            }, { once: true });

            const audioPlayer = document.getElementById('audio-player');
            const lyricsContainer = document.getElementById('lyrics-container');
            const playerContainer = document.getElementById('player-container');
            const fontSlider = document.getElementById('fontSlider');
            let lyricsData = [];
            let forceCenterAlign = false; // 新增
            let translationData = [];
            let backgroundCleanup = null;

            const AMLL_MODULE_URL = "{{ url_for('static', filename='assets/amll-player.js') }}";
            const amllStubState = { patched: false, restore: null, host: null, skeleton: null };
            const amllBackgroundState = { promise: null, host: null, element: null };
            const urlParams = new URLSearchParams(window.location.search);
            const queryBackground = urlParams.get('background') || null;
            const queryCover = urlParams.get('cover') || null;
            const AMLL_SKELETON_IDS = new Set([
                'player',
                'lyricsPanel',
                'albumSidePanel',
                'songTitle',
                'songArtist',
                'albumInfo',
                'albumCoverContainer',
                'albumCoverLarge',
                'progressBar',
                'progressFill',
                'waveformCanvas'
            ]);

            function clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            const LYRIC_SCALE_MIN = 0.35;
            const LYRIC_SCALE_MAX = 1.6;
            const AUTO_SCALE_SAFETY_RATIO = 0.97;
            const AUTO_SCALE_SAFETY_PADDING = 48;
            const AUTO_SCALE_EPS = 0.01;
            const LYRIC_SCALE_EASING = 'cubic-bezier(0.32, 0.78, 0.12, 1)';
            const LYRIC_SCALE_DURATION_MS = 360;
            let userLyricScale = parseFloat(fontSlider?.value || '1') || 1;
            let appliedLyricScale = userLyricScale;
            let autoScaleRaf = null;
            let suppressAnimations = false;
            let autoScaleLocked = false;
            let lyricScaleResyncTimer = null;

            function createAmllStubElement(id) {
                if (!id) {
                    return document.createElement('div');
                }
                const normalizedId = id.toLowerCase();
                if (normalizedId === 'waveformcanvas') {
                    const canvas = document.createElement('canvas');
                    canvas.width = 0;
                    canvas.height = 0;
                    return canvas;
                }
                return document.createElement('div');
            }

            function selectById(root, id) {
                if (!root) return null;
                if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
                    return root.querySelector(`#${CSS.escape(id)}`);
                }
                return root.querySelector(`[id="${id.replace(/"/g, '\\"')}"]`);
            }

            function ensureAmllSkeleton(stubMap, host) {
                if (amllStubState.skeleton && amllStubState.skeleton.isConnected) {
                    return;
                }
                const skeleton = document.createElement('div');
                skeleton.setAttribute('data-amll-skeleton', '1');
                skeleton.style.display = 'none';
                skeleton.innerHTML = `
                    <div id="player" data-amll-stub="1">
                        <div id="albumSidePanel" data-amll-stub="1">
                            <div class="song-info-container" data-amll-stub="1">
                                <div id="albumCoverContainer" data-amll-stub="1">
                                    <img id="albumCoverLarge" data-amll-stub="1" alt="" />
                                </div>
                                <div id="albumInfo" data-amll-stub="1">
                                    <div id="songTitle" data-amll-stub="1"></div>
                                    <div id="songArtist" data-amll-stub="1"></div>
                                </div>
                            </div>
                        </div>
                        <div id="lyricsPanel" data-amll-stub="1"></div>
                    </div>
                    <div id="progressBar" data-amll-stub="1">
                        <canvas id="waveformCanvas" data-amll-stub="1"></canvas>
                        <div id="progressFill" data-amll-stub="1"></div>
                    </div>
                `;
                host.appendChild(skeleton);
                amllStubState.skeleton = skeleton;
                AMLL_SKELETON_IDS.forEach((elementId) => {
                    const el = selectById(skeleton, elementId);
                    if (el) {
                        if (elementId === 'waveformCanvas' && el instanceof HTMLCanvasElement) {
                            el.width = 0;
                            el.height = 0;
                        }
                        stubMap.set(elementId, el);
                    }
                });
            }

            function ensureAmllStubs() {
                if (amllStubState.patched) {
                    return;
                }
                const host = document.createElement('div');
                host.id = 'amll-stub-host';
                host.style.display = 'none';
                document.documentElement.appendChild(host);

                const stubMap = new Map();
                const originalGetElementById = document.getElementById.bind(document);

                document.getElementById = function (id) {
                    const existing = originalGetElementById(id);
                    if (existing) return existing;
                    if (AMLL_SKELETON_IDS.has(id)) {
                        ensureAmllSkeleton(stubMap, host);
                    }
                    if (stubMap.has(id)) return stubMap.get(id);
                    if (amllStubState.skeleton) {
                        const skeletonMatch = selectById(amllStubState.skeleton, id);
                        if (skeletonMatch) {
                            stubMap.set(id, skeletonMatch);
                            return skeletonMatch;
                        }
                    }
                    const stub = createAmllStubElement(id);
                    stub.id = id;
                    stub.setAttribute('data-amll-stub', '1');
                    host.appendChild(stub);
                    stubMap.set(id, stub);
                    return stub;
                };

                amllStubState.patched = true;
                amllStubState.host = host;
                amllStubState.restore = () => {
                    document.getElementById = originalGetElementById;
                };
            }

            function ensureMediaCapabilitiesCompat() {
                const mediaCapabilities = navigator.mediaCapabilities;
                if (!mediaCapabilities) {
                    return;
                }
                const originalEncodingInfo = mediaCapabilities.encodingInfo;
                if (typeof originalEncodingInfo !== 'function' || originalEncodingInfo.__amllPatched) {
                    return;
                }
                const wrapped = async (...args) => {
                    try {
                        return await originalEncodingInfo.apply(mediaCapabilities, args);
                    } catch (error) {
                        const message = String(error || '');
                        const isEnumError = error instanceof TypeError && message.includes('encodingInfo');
                        if (!isEnumError) {
                            console.warn('[AMLL] MediaCapabilities encodingInfo fallback applied', error);
                        }
                        return { supported: false, smooth: false, powerEfficient: false };
                    }
                };
                Object.defineProperty(wrapped, '__amllPatched', {
                    value: true,
                    writable: false
                });
                try {
                    Object.defineProperty(mediaCapabilities, 'encodingInfo', {
                        configurable: true,
                        enumerable: true,
                        value: wrapped
                    });
                } catch (error) {
                    try {
                        mediaCapabilities.encodingInfo = wrapped;
                    } catch (assignError) {
                        console.warn('[AMLL] Unable to patch MediaCapabilities.encodingInfo', assignError);
                    }
                }
            }

            function waitFor(predicate, timeout = 8000, interval = 50) {
                return new Promise((resolve, reject) => {
                    const start = Date.now();
                    const step = () => {
                        let value = null;
                        try {
                            value = predicate();
                        } catch (error) {
                            // 忽略 predicate 内部异常
                        }
                        if (value) {
                            resolve(value);
                            return;
                        }
                        if (Date.now() - start >= timeout) {
                            reject(new Error('waitFor timeout'));
                            return;
                        }
                        setTimeout(step, interval);
                    };
                    step();
                });
            }

            function removeExistingBackground() {
                if (backgroundCleanup) {
                    try {
                        backgroundCleanup();
                    } catch (e) { /* 忽略清理异常 */ }
                    backgroundCleanup = null;
                }
                document.querySelectorAll('.background-container').forEach((el) => el.remove());
            }

            function resolveMediaUrl(rawPath) {
                if (!rawPath || typeof rawPath !== 'string') {
                    return null;
                }
                const trimmed = rawPath.trim();
                if (!trimmed) {
                    return null;
                }
                const normalized = trimmed.replace(/^\.\//, '');
                if (/^https?:\/\//i.test(normalized) || normalized.startsWith('data:') || normalized.startsWith('blob:')) {
                    return normalized;
                }
                return normalized.startsWith('/') ? normalized : '/' + normalized;
            }

            async function prepareAmllBackground() {
                if (amllBackgroundState.promise) {
                    return amllBackgroundState.promise;
                }

                amllBackgroundState.promise = (async () => {
                    try {
                        ensureMediaCapabilitiesCompat();
                        ensureAmllStubs();
                        if (!window.globalBackground) {
                            await import(AMLL_MODULE_URL);
                        }
                        const background = await waitFor(() => window.globalBackground, 10000);
                        if (!background) {
                            return null;
                        }

                        if (amllStubState.restore) {
                            try {
                                amllStubState.restore();
                            } catch (error) {
                                console.warn('[AMLL] 恢复 getElementById 失败', error);
                            }
                            amllStubState.restore = null;
                        }

                        amllBackgroundState.host = amllStubState.host;
                        const element = background.getElement();
                        element.setAttribute('data-amll-background-element', '1');
                        element.style.position = 'absolute';
                        element.style.top = '0';
                        element.style.left = '0';
                        element.style.width = '100%';
                        element.style.height = '100%';
                        element.style.pointerEvents = 'none';
                        element.style.opacity = '1';
                        amllBackgroundState.element = element;

                        const audio = window.player?.getAudio?.();
                        if (audio) {
                            try {
                                audio.pause();
                            } catch (error) { /* 忽略 */ }
                            audio.remove?.();
                        }

                        return background;
                    } catch (error) {
                        console.error('[AMLL] 加载 AMLL 背景失败', error);
                        if (amllStubState.restore) {
                            try {
                                amllStubState.restore();
                            } catch (restoreError) {
                                console.warn('[AMLL] 回退 getElementById 时出错', restoreError);
                            }
                            amllStubState.restore = null;
                        }
                        return null;
                    }
                })();

                return amllBackgroundState.promise;
            }

            async function initAmllBackgroundFromAlbum(coverPath) {
                const url = resolveMediaUrl(coverPath);
                if (!url) {
                    return false;
                }

                const background = await prepareAmllBackground();
                if (!background || !amllBackgroundState.element) {
                    return false;
                }

                removeExistingBackground();

                const container = document.createElement('div');
                container.className = 'background-container';
                container.appendChild(amllBackgroundState.element);
                document.body.appendChild(container);

                backgroundCleanup = () => {
                    try {
                        background.pause();
                    } catch (error) { /* 忽略 */ }
                    if (amllBackgroundState.element.parentElement) {
                        amllBackgroundState.element.parentElement.removeChild(amllBackgroundState.element);
                    }
                    if (amllBackgroundState.host) {
                        amllBackgroundState.host.appendChild(amllBackgroundState.element);
                    }
                    container.remove();
                };

                try {
                    await background.setAlbum(url);
                    background.setStaticMode(false);
                    background.setFlowSpeed(4);
                    const dpr = window.devicePixelRatio || 1;
                    background.setRenderScale(dpr);
                    background.resume();
                    return true;
                } catch (error) {
                    console.warn('[AMLL] AMLL 背景初始化失败，将回退其他方案', error);
                    if (backgroundCleanup) {
                        backgroundCleanup();
                        backgroundCleanup = null;
                    }
                    return false;
                }
            }

            async function loadBackground(backgroundPath) {
                const url = resolveMediaUrl(backgroundPath);
                if (!url) {
                    return false;
                }

                removeExistingBackground();

                return new Promise((resolve) => {
                    const container = document.createElement('div');
                    container.className = 'background-container';
                    document.body.appendChild(container);

                    const handleFailure = () => {
                        container.remove();
                        backgroundCleanup = null;
                        resolve(false);
                    };

                    const extension = (url.split('.').pop() || '').toLowerCase();
                    const isVideo = ['mp4', 'webm', 'ogg'].includes(extension);

                    if (isVideo) {
                        const video = document.createElement('video');
                        video.src = url;
                        video.muted = true;
                        video.loop = true;
                        video.autoplay = true;
                        video.playsInline = true;
                        video.addEventListener('loadeddata', () => {
                            backgroundCleanup = () => {
                                video.pause();
                                video.removeAttribute('src');
                                video.load();
                                container.remove();
                            };
                            resolve(true);
                            video.play().catch(() => {});
                        }, { once: true });
                        video.addEventListener('error', handleFailure, { once: true });
                        container.appendChild(video);
                    } else {
                        const img = document.createElement('img');
                        img.src = url;
                        img.addEventListener('load', () => {
                            backgroundCleanup = () => {
                                container.remove();
                            };
                            resolve(true);
                        }, { once: true });
                        img.addEventListener('error', handleFailure, { once: true });
                        container.appendChild(img);
                    }
                });
            }

            // 动画时长控制（前端硬编码，同时由后端解析保持一致）
            const enterDuration = 600;           // 歌词行进入动画时长（毫秒）
            const moveDuration = 600;            // 歌词行移动动画时长（毫秒）
            const exitDuration = 600;            // 歌词行退出动画时长（毫秒）
            const placeholderDuration = 50;      // 占位符（消失行）延时
            const lineDisplayOffset = 0.5;       // 歌词行提前显示时间（秒）
            const useComputedDisappear = false;  // 是否使用后端计算的消失时机
            const SYLLABLE_FADE_RATIO = 0.3;     // 逐字渐变的淡入范围比例
            const SYLLABLE_FLOAT_ASCEND_EASING = 'cubic-bezier(0.55, 0.05, 0.85, 0.25)'; // 逐音节上浮阶段使用缓慢起步后逐渐加速的曲线
            const SYLLABLE_FLOAT_SETTLE_EASING = 'cubic-bezier(0.0, 0.6, 0.2, 1.0)';     // 逐音节悬停阶段使用深度缓出的曲线
            const SYLLABLE_FLOAT_SETTLE_TAIL_MS = 100000000000; // 逐音节悬停阶段至少保留的时长（毫秒），制造“无限趋近”感
            const SYLLABLE_FLOAT_MAX_SPEED = 0.01314520; // 像素/毫秒，逐音节上浮速度上限，可按需求调整

            async function syncAnimationConfig() {
                try {
                    await fetch('/player/animation-config', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            enterDuration,
                            moveDuration,
                            exitDuration,
                            placeholderDuration,
                            lineDisplayOffset,
                            useComputedDisappear
                        })
                    });
                } catch (error) {
                    console.warn('上传动画配置失败，将使用后端的默认值', error);
                }
            }

            let displayedLines = new Map(); // 使用 Map 跟踪所有显示的行
            let placeholderLines = new Map(); // 跟踪正在消失的行的占位符
            const customEasing = 'cubic-bezier(.27,.14,0,.99)';
            let showAllLinesWhenPaused = false; // 是否暂停时展示所有歌词行
            let rafId = null; // requestAnimationFrame ID
            const moveTransitionCleanup = new WeakMap(); // 存储当前运行的位移动画信息

            function refreshDisplayedLineAnimations() {
                requestAnimationFrame(() => {
                    displayedLines.forEach((lineInfo, index) => {
                        const lineData = lyricsData[index];
                        if (lineInfo?.element && lineData) {
                            prepareSyllableAnimations(index, lineInfo.element, lineInfo, lineData);
                        }
                    });
                });
            }

            function requestLyricAnimationResync() {
                refreshDisplayedLineAnimations();
                if (lyricScaleResyncTimer) {
                    clearTimeout(lyricScaleResyncTimer);
                }
                lyricScaleResyncTimer = setTimeout(() => {
                    lyricScaleResyncTimer = null;
                    refreshDisplayedLineAnimations();
                }, LYRIC_SCALE_DURATION_MS + 80);
            }

            function withAnimationsSuppressed(fn) {
                suppressAnimations = true;
                try {
                    fn();
                } finally {
                    suppressAnimations = false;
                }
            }

            function setLyricScale(scale) {
                const upperBound = Math.min(userLyricScale, LYRIC_SCALE_MAX);
                const clamped = clamp(scale, LYRIC_SCALE_MIN, upperBound);
                appliedLyricScale = clamped;
                if (playerContainer) {
                    playerContainer.style.setProperty('--lyric-scale', clamped);
                    playerContainer.style.setProperty('--lyric-scale-easing', LYRIC_SCALE_EASING);
                    playerContainer.style.setProperty('--lyric-scale-duration', `${LYRIC_SCALE_DURATION_MS}ms`);
                }
                requestLyricAnimationResync();
            }

            const lineMetricCache = { metrics: null };

            function measureLineMetrics() {
                const cache = lineMetricCache.metrics;
                if (cache) return cache;

                const host = document.createElement('div');
                host.style.position = 'absolute';
                host.style.left = '-9999px';
                host.style.top = '0';
                host.style.width = '1000px';
                host.style.pointerEvents = 'none';
                host.style.visibility = 'hidden';
                host.style.setProperty('--lyric-scale', '1');
                document.body.appendChild(host);

                const buildLine = (isSmall, withTranslation) => {
                    const line = document.createElement('div');
                    line.className = 'lyric-line center-aligned';
                    if (isSmall) line.classList.add('small-font');
                    const word = document.createElement('span');
                    word.className = 'word-wrapper';
                    const syllable = document.createElement('span');
                    syllable.className = 'syllable';
                    syllable.textContent = 'Sample words here';
                    word.appendChild(syllable);
                    line.appendChild(word);
                    if (withTranslation) {
                        const trans = document.createElement('div');
                        trans.className = 'translation-line center-aligned';
                        trans.style.fontSize = isSmall ? '0.8em' : '0.5em';
                        trans.style.color = '#ffffff';
                        trans.style.fontWeight = 'normal';
                        trans.style.lineHeight = '1.2';
                        trans.style.marginTop = '0.1em';
                        trans.style.width = '100%';
                        trans.style.paddingBottom = '0.2em';
                        trans.textContent = 'translation';
                        line.appendChild(trans);
                    }
                    return line;
                };

                const lines = [
                    { key: 'normal', el: buildLine(false, false) },
                    { key: 'small', el: buildLine(true, false) },
                    { key: 'normalTrans', el: buildLine(false, true) },
                    { key: 'smallTrans', el: buildLine(true, true) }
                ];

                lines.forEach(({ el }) => host.appendChild(el));

                const metrics = {};
                lines.forEach(({ key, el }) => {
                    metrics[key] = el.offsetHeight || el.getBoundingClientRect().height || 0;
                });

                host.remove();
                lineMetricCache.metrics = metrics;
                return metrics;
            }

            function computeAutoScaleTarget() {
                if (autoScaleLocked) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }
                const viewportHeight = window.innerHeight
                    || document.documentElement.clientHeight
                    || (playerContainer ? playerContainer.clientHeight : 0)
                    || 0;
                if (!viewportHeight) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }
                const availableHeight = Math.max(0, viewportHeight - AUTO_SCALE_SAFETY_PADDING);
                if (availableHeight === 0) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }

                const metrics = measureLineMetrics();
                const lines = Array.from(lyricsContainer?.querySelectorAll('.lyric-line') || []);
                if (lines.length === 0) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }

                let normal = 0;
                let small = 0;
                let normalTrans = 0;
                let smallTrans = 0;
                lines.forEach((line) => {
                    const isSmall = line.classList.contains('small-font');
                    const hasTrans = !!line.querySelector('.translation-line');
                    if (isSmall) {
                        if (hasTrans) {
                            smallTrans += 1;
                        } else {
                            small += 1;
                        }
                    } else {
                        if (hasTrans) {
                            normalTrans += 1;
                        } else {
                            normal += 1;
                        }
                    }
                });

                const baseSum =
                    normal * (metrics.normal || 0) +
                    small * (metrics.small || 0) +
                    normalTrans * (metrics.normalTrans || 0) +
                    smallTrans * (metrics.smallTrans || 0);

                if (baseSum <= 0) {
                    return clamp(userLyricScale, LYRIC_SCALE_MIN, LYRIC_SCALE_MAX);
                }

                const baselineTotal = baseSum * userLyricScale;
                const ratio = availableHeight / baselineTotal;
                const adjustedRatio = ratio * AUTO_SCALE_SAFETY_RATIO;
                const upperBound = Math.min(userLyricScale, LYRIC_SCALE_MAX);
                const target = clamp(
                    userLyricScale * adjustedRatio,
                    LYRIC_SCALE_MIN,
                    upperBound
                );
                if (Math.abs(target - appliedLyricScale) < AUTO_SCALE_EPS) {
                    return appliedLyricScale;
                }
                return target;
            }

            function scheduleAutoScale() {
                if (autoScaleLocked) return;
                if (autoScaleRaf) return;
                autoScaleRaf = requestAnimationFrame(() => {
                    autoScaleRaf = null;
                    const targetScale = computeAutoScaleTarget();
                    if (Math.abs(targetScale - appliedLyricScale) > AUTO_SCALE_EPS) {
                        setLyricScale(targetScale);
                    }
                });
            }
            setLyricScale(userLyricScale);

            function clearMoveTransition(element) {
                if (!element) {
                    return { residualX: 0, residualY: 0, progress: 0 };
                }
                const record = moveTransitionCleanup.get(element);
                if (!record) {
                    return { residualX: 0, residualY: 0, progress: 0 };
                }

                moveTransitionCleanup.delete(element);

                let progress = 0;
                let residualX = 0;
                let residualY = 0;

                const { animation, fromX = 0, fromY = 0 } = record;
                if (animation && animation.effect && typeof animation.effect.getComputedTiming === 'function') {
                    try {
                        const timing = animation.effect.getComputedTiming();
                        if (timing && typeof timing.progress === 'number') {
                            progress = Math.max(0, Math.min(1, timing.progress));
                        }
                    } catch (e) { /* 忽略 */ }
                }

                const remaining = 1 - progress;
                residualX = fromX * remaining;
                residualY = fromY * remaining;

                try {
                    animation.cancel();
                } catch (e) { /* 忽略 */ }

                element.style.transform = '';
                element.style.willChange = '';

                return { residualX, residualY, progress };
            }

            function runFlipTransition(element, deltaX, deltaY) {
                if (suppressAnimations) return;
                if (!element) return;
                const { residualX, residualY, progress } = clearMoveTransition(element);

                const adjustedDeltaX = deltaX + residualX;
                const adjustedDeltaY = deltaY + residualY;

                if (Math.abs(adjustedDeltaX) <= 0.5 && Math.abs(adjustedDeltaY) <= 0.5) return;

                // 若上一段动画未完成，则缩短时长并使用线性缓动以平滑衔接
                const durationFactor = progress > 0 ? Math.max(0.35, 1 - progress * 0.6) : 1;
                const animationDuration = Math.max(180, moveDuration * durationFactor);
                const easing = progress > 0.2 ? 'linear' : customEasing;

                element.style.willChange = 'transform';
                const animation = element.animate(
                    [
                        { transform: `translate(${adjustedDeltaX}px, ${adjustedDeltaY}px)` },
                        { transform: 'translate(0, 0)' }
                    ],
                    {
                        duration: animationDuration,
                        easing,
                        fill: 'forwards',
                        composite: 'add'
                    }
                );

                const record = {
                    animation,
                    fromX: adjustedDeltaX,
                    fromY: adjustedDeltaY
                };

                const finalize = () => {
                    if (moveTransitionCleanup.get(element) !== record) return;
                    moveTransitionCleanup.delete(element);
                    element.style.transform = '';
                    element.style.willChange = '';
                };

                animation.addEventListener('finish', finalize, { once: true });
                animation.addEventListener('cancel', finalize, { once: true });


                moveTransitionCleanup.set(element, record);
            }

            function generateBackgroundFadeStyle(elementWidth, elementHeight, fadeRatio) {
                            const fadeWidth = elementHeight * fadeRatio;
                            const widthRatio = elementWidth === 0 ? 0 : fadeWidth / elementWidth;

                            const totalAspect = 2 + widthRatio;
                            const widthInTotal = totalAspect === 0 ? 0 : widthRatio / totalAspect;
                            const leftPos = (1 - widthInTotal) / 2;

                            const from = leftPos * 100;
                            const to = (leftPos + widthInTotal) * 100;

                            const backgroundImage = `linear-gradient(to right, rgba(255, 255, 255, var(--rcolor)) ${from}%, rgba(255, 255, 255, var(--color)) ${to}%)`;
                            const backgroundSize = `${totalAspect * 100}% 100%`;
                            const totalPxWidth = -(elementWidth + fadeWidth);
                            return { backgroundImage, backgroundSize, totalPxWidth };
                        }

                        function createKaraokeFrames(blocks, index, lineDuration, fadeRatio) {
                            const frames = [];
                            if (!blocks[index]) return frames;

                            const element = blocks[index].ele;
                            const elementWidth = element.offsetWidth;
                            const computed = getComputedStyle(element);
                            const elementHeight = element.offsetHeight || parseFloat(computed.fontSize) || 0;
                            const fadeWidth = elementHeight * fadeRatio;
                            const fullBlockWidth = elementWidth + fadeWidth - 2;

                            let totalDuration = Math.max(1, lineDuration);
                            if (blocks.length > 0) {
                                const lastBlockEnd = blocks[blocks.length - 1].endTime;
                                const firstBlockStart = blocks[0].startTime;
                                totalDuration = Math.max(1, lastBlockEnd - firstBlockStart);
                            }

                            let widthBeforeSelf = 0;
                            for (let i = 0; i < index; i++) {
                                widthBeforeSelf += blocks[i].ele.offsetWidth;
                            }
                            if (index > 0) {
                                widthBeforeSelf += fadeWidth;
                            }

                            const minOffset = -(fullBlockWidth);
                            const clampOffset = (value) => Math.max(minOffset, Math.min(0, value));

                            let currentPos = -widthBeforeSelf - elementWidth - fadeWidth;
                            let timeOffset = 0;
                            let lastPos = currentPos;
                            let lastTime = 0;
                            let lastTimestamp = blocks[0].startTime;

                            const pushFrame = () => {
                                let time = Math.max(0, Math.min(1, timeOffset));
                                time = Math.round(time * 1e9) / 1e9;
                                if (time < lastTime) {
                                    time = lastTime;
                                }

                                const deltaTime = time - lastTime;
                                const moveOffset = currentPos - lastPos;
                                const ratio = moveOffset !== 0 ? Math.abs(deltaTime / moveOffset) : 0;

                                if (currentPos > minOffset && lastPos < minOffset) {
                                    const staticTime = Math.abs(lastPos - minOffset) * ratio;
                                    frames.push({
                                        backgroundPosition: `${clampOffset(lastPos)}px 0`,
                                        offset: lastTime + staticTime
                                    });
                                }

                                if (currentPos > 0 && lastPos < 0) {
                                    const staticTime = Math.abs(lastPos) * ratio;
                                    frames.push({
                                        backgroundPosition: `${clampOffset(currentPos)}px 0`,
                                        offset: lastTime + staticTime
                                    });
                                }

                                frames.push({
                                    backgroundPosition: `${clampOffset(currentPos)}px 0`,
                                    offset: time
                                });

                                lastPos = currentPos;
                                lastTime = time;
                            };

                            pushFrame();

                            blocks.forEach((block, i) => {
                                const absoluteStart = block.startTime;
                                const absoluteEnd = block.endTime;

                                const staticDuration = absoluteStart - lastTimestamp;
                                if (staticDuration > 0) {
                                    timeOffset += staticDuration / totalDuration;
                                    pushFrame();
                                    lastTimestamp = absoluteStart;
                                }

                                const moveDuration = Math.max(0, absoluteEnd - absoluteStart);
                                if (moveDuration > 0) {
                                    timeOffset += moveDuration / totalDuration;
                                    currentPos += block.ele.offsetWidth;
                                    if (i === 0) {
                                        currentPos += fadeWidth * 1.5;
                                    }
                                    if (i === blocks.length - 1) {
                                        currentPos += fadeWidth * 0.5;
                                    }
                                    pushFrame();
                                    lastTimestamp = absoluteEnd;
                                }
                            });

                            if (frames.length > 0) {
                                frames[frames.length - 1].offset = 1;
                            }

                            return frames;
                        }

                        function cancelLineAnimations(lineInfo, { commit } = {}) {
                            if (!lineInfo || !lineInfo.animations) return;
                            lineInfo.animations.forEach(animation => {
                                try {
                                    if (commit && typeof animation.commitStyles === 'function') {
                                        animation.commitStyles();
                                    }
                                } catch (e) { /* 忽略 */ }
                                try {
                                    animation.cancel();
                                } catch (e) { /* 忽略 */ }
                            });
                            lineInfo.animations = [];
                        }

                        function syncLineAnimations(lineInfo) {
                            if (!lineInfo || !lineInfo.animations || lineInfo.animations.length === 0) return;
                            const currentMs = Number.isFinite(audioPlayer.currentTime) ? audioPlayer.currentTime * 1000 : 0;
                            const lineStart = lineInfo.lineStartMs ?? 0;
                            const duration = Math.max(1, lineInfo.lineDuration ?? 0);
                            const localTime = currentMs - lineStart;
                            const clampedTime = Math.max(0, Math.min(duration, localTime));
                            lineInfo.animations.forEach(animation => {
                                try {
                                    const mapper = animation && animation.__mapTime;
                                    const mappedTime = typeof mapper === 'function' ? mapper(clampedTime) : clampedTime;
                                    animation.currentTime = mappedTime;
                                } catch (e) { /* 忽略 */ }
                            });
                        }

            function prepareSyllableAnimations(lineIndex, lineEl, lineInfo, lineData) {
                if (!lineInfo || !lineEl || !lineData || !Array.isArray(lineData.syllables) || lineData.syllables.length === 0) return;

                const spans = Array.from(lineEl.querySelectorAll('.syllable'));
                if (spans.length === 0) return;
                const isSpecialFont = lineEl.dataset.specialFont === '1';
                const opacityOnly = isSpecialFont;

                cancelLineAnimations(lineInfo);

                            const blocks = [];
                            for (let i = 0; i < lineData.syllables.length; i++) {
                                const syllable = lineData.syllables[i];
                                const span = spans[i];
                                if (!span || !syllable) continue;
                                const startMs = Math.round(parseFloat(syllable.startTime) * 1000);
                                const durationMs = Math.round(parseFloat(syllable.duration) * 1000);
                                const endMs = startMs + durationMs;
                                blocks.push({
                                    ele: span,
                                    startTime: startMs,
                                    endTime: endMs,
                                    // 特殊字体不再基于时长限制上浮，统一允许；非特殊字体沿用默认行为
                                    allowFloat: true
                                });
                            }

                            if (blocks.length === 0) return;

                            const firstStart = blocks.reduce((min, block) => Math.min(min, block.startTime), Number.MAX_SAFE_INTEGER);
                            const lastEnd = blocks.reduce((max, block) => Math.max(max, block.endTime), 0);
                            const originalLineDuration = Math.max(1, lastEnd - firstStart);
                            let extendedLineDuration = originalLineDuration;
                            const blockMetrics = [];

                            blocks.forEach((block) => {
                                const span = block.ele;
                                const computedStyle = getComputedStyle(span);
                                const spanWidth = span.offsetWidth || parseFloat(computedStyle.width) || 0;
                                const spanHeight = span.offsetHeight || parseFloat(computedStyle.fontSize) || 0;
                                const fadeStyle = opacityOnly
                                    ? { backgroundImage: 'none', backgroundSize: '', totalPxWidth: 0 }
                                    : generateBackgroundFadeStyle(spanWidth, spanHeight, SYLLABLE_FADE_RATIO);
                                const { backgroundImage, backgroundSize, totalPxWidth } = fadeStyle;
                                const allowFloat = Boolean(block.allowFloat);
                                const floatDistance = allowFloat ? Math.max(1, spanHeight * 0.1) : 0;
                                const floatOffset = allowFloat ? -(Math.round(floatDistance * 100) / 100) : 0;
                                const syllableDurationMs = Math.max(1, block.endTime - block.startTime);
                                const ascendStartMs = block.startTime;
                                const requiredAscendMs = allowFloat ? Math.max(syllableDurationMs, floatDistance / SYLLABLE_FLOAT_MAX_SPEED) : syllableDurationMs;
                                const ascendEndMs = ascendStartMs + requiredAscendMs;
                                const settleTailMs = allowFloat
                                    ? Math.max(
                                        SYLLABLE_FLOAT_SETTLE_TAIL_MS,
                                        Math.min(requiredAscendMs * 0.35, 600)
                                    )
                                    : 0;
                                const settleEndMs = ascendEndMs + settleTailMs;

                                extendedLineDuration = Math.max(extendedLineDuration, settleEndMs - firstStart);

                                blockMetrics.push({
                                    span,
                                    block,
                                    spanWidth,
                                    spanHeight,
                                    backgroundImage,
                                    backgroundSize,
                                    totalPxWidth,
                                    floatDistance,
                                    floatOffset,
                                    ascendStartMs,
                                    ascendEndMs,
                                    settleEndMs
                                });
                            });

                            lineInfo.lineStartMs = firstStart;
                            lineInfo.lineDuration = extendedLineDuration;
                            lineInfo.originalLineDuration = originalLineDuration;
                            lineInfo.animations = [];

                            blockMetrics.forEach((metric, idx) => {
                                const span = metric.span;
                                const block = metric.block;
                                const spanWidth = metric.spanWidth;
                                const spanHeight = metric.spanHeight;
                                const backgroundImage = metric.backgroundImage;
                                const backgroundSize = metric.backgroundSize;
                                const totalPxWidth = metric.totalPxWidth;

                                span.style.backgroundImage = backgroundImage;
                                span.style.backgroundSize = backgroundSize;
                                span.style.backgroundPosition = `${totalPxWidth}px 0`;
                                span.style.backgroundRepeat = 'no-repeat';
                                span.style.transform = 'translateY(0)';
                                if (opacityOnly) {
                                    span.style.color = 'rgba(255,255,255,0.95)';
                                    span.style.webkitTextFillColor = 'rgba(255,255,255,0.95)';
                                    span.style.opacity = '0.25';
                                }

                                const frames = opacityOnly
                                    ? (() => {
                                        const startRel = Math.max(0, Math.min(1, (block.startTime - firstStart) / originalLineDuration));
                                        const endRel = Math.max(startRel, Math.min(1, (block.endTime - firstStart) / originalLineDuration));
                                        return [
                                            { offset: 0, opacity: 0.25 },
                                            { offset: startRel, opacity: 0.25 },
                                            { offset: endRel, opacity: 1 },
                                            { offset: 1, opacity: 1 }
                                        ];
                                    })()
                                    : createKaraokeFrames(blocks, idx, originalLineDuration, SYLLABLE_FADE_RATIO);
                                const animation = span.animate(frames, {
                                    duration: originalLineDuration,
                                    easing: 'linear',
                                    fill: 'both'
                                });
                                animation.pause();
                                animation.__mapTime = (time) => Math.min(time, originalLineDuration);
                                lineInfo.animations.push(animation);

                                if (metric.floatDistance > 0) {
                                    const floatDistance = metric.floatDistance;
                                    const floatOffset = metric.floatOffset;
                                    const ascendStartOffset = Math.max(0, Math.min(1, (metric.ascendStartMs - firstStart) / extendedLineDuration));
                                    const ascendEndOffset = Math.max(
                                        ascendStartOffset,
                                        Math.min(1, (metric.ascendEndMs - firstStart) / extendedLineDuration)
                                    );
                                    const settleEndOffset = Math.max(
                                        ascendEndOffset,
                                        Math.min(1, (metric.settleEndMs - firstStart) / extendedLineDuration)
                                    );

                                    const floatFrames = [];
                                    floatFrames.push({ offset: 0, transform: 'translateY(0)' });
                                    if (ascendStartOffset > 0) {
                                        floatFrames.push({ offset: ascendStartOffset, transform: 'translateY(0)' });
                                    }
                                    floatFrames.push({
                                        offset: ascendEndOffset,
                                        transform: `translateY(${floatOffset}px)`,
                                        easing: SYLLABLE_FLOAT_ASCEND_EASING
                                    });
                                    if (settleEndOffset > ascendEndOffset) {
                                        floatFrames.push({
                                            offset: settleEndOffset,
                                            transform: `translateY(${floatOffset}px)`,
                                            easing: SYLLABLE_FLOAT_SETTLE_EASING
                                        });
                                        if (settleEndOffset < 1) {
                                            floatFrames.push({
                                                offset: 1,
                                                transform: `translateY(${floatOffset}px)`
                                            });
                                        }
                                    } else if (ascendEndOffset < 1) {
                                        floatFrames.push({
                                            offset: 1,
                                            transform: `translateY(${floatOffset}px)`,
                                            easing: SYLLABLE_FLOAT_SETTLE_EASING
                                        });
                                    } else {
                                        const lastFrame = floatFrames[floatFrames.length - 1];
                                        lastFrame.easing = SYLLABLE_FLOAT_SETTLE_EASING;
                                    }
                                    const floatAnimation = span.animate(floatFrames, {
                                        duration: extendedLineDuration,
                                        easing: 'linear',
                                        fill: 'both'
                                    });
                                    floatAnimation.pause();
                                    lineInfo.animations.push(floatAnimation);
                                }
                            });

                            syncLineAnimations(lineInfo);
                        }

            // 卡拉OK进度更新函数 - 只更新当前活跃行
            function updateKaraokeProgress() {
                displayedLines.forEach((lineInfo) => {
                    syncLineAnimations(lineInfo);
                });
            }

            // requestAnimationFrame 循环
            function rafLoop() {
                updateKaraokeProgress();
                rafId = requestAnimationFrame(rafLoop);
            }

            // 解析 LRC 翻译，返回 [{timeMs, content}]
            function parseLrcTranslation(content) {
                const lines = content.split('\n');
                const result = [];
                const lrcTimeRe = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
                for (const line of lines) {
                    const match = lrcTimeRe.exec(line);
                    if (match) {
                        const min = parseInt(match[1], 10);
                        const sec = parseInt(match[2], 10);
                        let ms = match[3].length === 2 ? parseInt(match[3], 10) * 10 : parseInt(match[3], 10);
                        const timeMs = min * 60 * 1000 + sec * 1000 + ms;
                        const contentText = line.replace(lrcTimeRe, '').trim();
                        if (contentText) {
                            result.push({ timeMs, content: contentText });
                        }
                    }
                }
                return result;
            }

            // 将持续时间超过 1s 的英文词拆分为逐字符的子音节，按等份时间平分
        function splitLongWordSyllables(lines, minDurationSec = 1, predicate = () => true) {
            if (!Array.isArray(lines)) return [];

            return lines.map((line) => {
                if (!predicate(line)) return line;
                if (!line || !Array.isArray(line.syllables)) {
                    return line;
                }

                    const newSyllables = [];
                    line.syllables.forEach((syllable) => {
                        if (!syllable) return;
                        const rawText = syllable.text || '';
                        const text = rawText.trim();
                        const duration = Number.parseFloat(syllable.duration);
                        const start = Number.parseFloat(syllable.startTime);
                        const looksLikeWord = /^[A-Za-z][A-Za-z,'-]*[A-Za-z]?[.,!?]?$/.test(text) && !text.includes(' ');

                        if (
                            Number.isFinite(duration) &&
                            Number.isFinite(start) &&
                            duration > minDurationSec &&
                            text.length > 1 &&
                            looksLikeWord
                        ) {
                            const chars = Array.from(rawText);
                            const partDuration = duration / chars.length;
                            chars.forEach((char, idx) => {
                                const splitStart = start + partDuration * idx;
                                newSyllables.push({
                                    ...syllable,
                                    text: char,
                                    startTime: splitStart,
                                    duration: partDuration
                                });
                            });
                        } else {
                            newSyllables.push(syllable);
                        }
                    });

                    return { ...line, syllables: newSyllables };
            });
        }

        function isLineUsingSpecialFont(line) {
            if (!line) return false;
            const hasLineFont = Boolean(line.style && line.style.fontFamily);
            const hasSyllableFont =
                Array.isArray(line.syllables) && line.syllables.some((sy) => sy && sy.fontFamily);
            return hasLineFont || hasSyllableFont;
        }

        function mergeSpecialFontWords(lines) {
            if (!Array.isArray(lines)) return [];
            const isSeparator = (text = '') => {
                if (!text) return true;
                if (/\s/.test(text)) return true;
                return /^[.,;!?:，。？！、：；]+$/.test(text);
            };
            const isLatinWord = (text = '') => /[A-Za-z]/.test(text);

            return lines.map((line) => {
                if (!line || !line.style || !line.style.fontFamily || !Array.isArray(line.syllables)) {
                    return line;
                }
                const merged = [];
                let current = null;

                const pushCurrent = () => {
                    if (current) {
                        current.duration = Math.max(0, current.endTime - current.startTime);
                        delete current.endTime;
                        merged.push(current);
                        current = null;
                    }
                };

                line.syllables.forEach((sy) => {
                    if (!sy) return;
                    const text = sy.text || '';
                    const start = parseFloat(sy.startTime) || 0;
                    const dur = parseFloat(sy.duration) || 0;
                    const end = start + dur;
                    const fontFamily = sy.fontFamily;

                    if (isSeparator(text) || !isLatinWord(text)) {
                        pushCurrent();
                        merged.push({
                            text,
                            startTime: start,
                            duration: dur,
                            fontFamily
                        });
                        return;
                    }

                    if (!current || current.fontFamily !== fontFamily) {
                        current = {
                            text,
                            startTime: start,
                            endTime: end,
                            fontFamily
                        };
                    } else {
                        current.text += text;
                        current.endTime = end;
                    }
                });

                pushCurrent();

                return {
                    ...line,
                    syllables: merged,
                    line: merged.map((s) => s.text || '').join('')
                };
            });
        }

            async function loadData() {
                try {
                    const songInfoRes = await fetch('/song-info');
                    const songInfo = await songInfoRes.json();
                    audioPlayer.src = songInfo.song;

                    if (!songInfo.meta || typeof songInfo.meta !== 'object') {
                        songInfo.meta = {};
                    }

                    if (queryBackground) {
                        songInfo.meta['Background-image'] = queryBackground;
                    }

                    if (queryCover && queryCover !== '!') {
                        songInfo.meta.albumImgSrc = queryCover;
                        songInfo.meta.cover = queryCover;
                        songInfo.meta.coverUrl = queryCover;
                        songInfo.cover = queryCover;
                        songInfo.coverUrl = queryCover;
                    }

                    removeExistingBackground();

                    // 检查并加载背景图片/视频
                    let backgroundApplied = false;
                    if (songInfo.meta && songInfo.meta["Background-image"]) {
                        backgroundApplied = await loadBackground(songInfo.meta["Background-image"]);
                    }

                    if (!backgroundApplied) {
                        const coverCandidates = [
                            queryCover,
                            songInfo.meta?.albumImgSrc,
                            songInfo.meta?.cover,
                            songInfo.meta?.coverUrl,
                            songInfo.cover,
                            songInfo.coverUrl
                        ];
                        const coverSource = coverCandidates.find((candidate) => candidate && candidate !== '!');
                        if (coverSource) {
                            backgroundApplied = await initAmllBackgroundFromAlbum(coverSource);
                        }
                    }
                    
                    // 进入页面自动播放
                    setTimeout(() => {
                        audioPlayer.play().catch(() => {});
                    }, 0);

                    const lyricsRes = await fetch('/lyrics');
                    const lyricsJson = await lyricsRes.json();
                    lyricsData = lyricsJson.lyrics || [];
                    // 长词拆分仅应用于非自定义字体行或音节，避免特殊字体被拆成单字符
                    lyricsData = splitLongWordSyllables(
                        lyricsData,
                        1,
                        (line) => !isLineUsingSpecialFont(line)
                    );
                    // 对特殊字体行：按单词合并音节（空格/标点分词），避免跨词遮挡
                    lyricsData = mergeSpecialFontWords(lyricsData);

                    // 判断是否所有歌词行都不是 right（没有对唱标记）
                    forceCenterAlign = lyricsData.length > 0 && lyricsData.every(line => !line.style || line.style.align !== 'right');

                    // 优先使用后端返回的 translation 字段
                    translationData = Array.isArray(lyricsJson.translation) ? lyricsJson.translation.map(t => {
                        // 转换 time 为毫秒
                        const m = /^([0-9]{2}):([0-9]{2})\.([0-9]{2,3})$/.exec(t.time);
                        if (m) {
                            let ms = m[3].length === 2 ? parseInt(m[3], 10) * 10 : parseInt(m[3], 10);
                            t.timeMs = parseInt(m[1], 10) * 60 * 1000 + parseInt(m[2], 10) * 1000 + ms;
                        } else {
                            t.timeMs = 0;
                        }
                        return t;
                    }) : [];

                    // 如果没有 translation 字段，回退到原有 LRC 解析
                    if (translationData.length === 0 && songInfo.meta && songInfo.meta.lyrics) {
                        const parts = songInfo.meta.lyrics.split('::');
                        if (parts.length >= 3 && parts[2] && parts[2] !== '!') {
                            let transPath = parts[2];
                            if (transPath.startsWith('http://127.0.0.1:5000/songs/')) {
                                transPath = transPath.replace('http://127.0.0.1:5000/songs/', '');
                            }
                            if (transPath.endsWith('.lrc')) {
                                try {
                                    const resp = await fetch(transPath.startsWith('/') ? transPath : '/' + transPath);
                                    if (resp.ok) {
                                        const lrcText = await resp.text();
                                        translationData = parseLrcTranslation(lrcText);
                                    }
                                } catch (e) { /* 忽略 */ }
                            }
                        }
                    }

                    initLyrics();
                } catch (error) {
                    lyricsContainer.textContent = '无法加载歌词。';
                    console.error('Error loading data:', error);
                }
            }

            function groupSyllablesIntoWords(container, itemClass = 'syllable') {
                if (!container) return;

                const hasWrapper = Array.from(container.children).some(
                    (child) => child.classList && child.classList.contains('word-wrapper')
                );
                if (hasWrapper) return;

                const targetElements = Array.from(container.children).filter(
                    (child) => child.classList && child.classList.contains(itemClass)
                );
                if (targetElements.length === 0) return;

                const hasCJK = (text) => /[\u3040-\u30FF\u3100-\u312F\u31A0-\u31BF\u3130-\u318F\u3300-\u33FF\u3400-\u4DBF\u4E00-\u9FFF\uAC00-\uD7AF\u1100-\u11FF]/.test(text);
                const hasLatin = (text) => /[A-Za-z0-9]/.test(text);

                let currentWrapper = null;
                targetElements.forEach((element) => {
                    const text = element.textContent || '';
                    const trimmed = text.replace(/\s+/g, '');
                    const hasVisibleChar = trimmed.length > 0;
                    const endsWithSpace = /\s$/.test(text);
                    const isWhitespaceOnly = !hasVisibleChar;
                    const isLatinSegment = hasLatin(trimmed) && !hasCJK(trimmed);

                    if (isWhitespaceOnly) {
                        currentWrapper = null;
                        element.classList.add('word-space');
                        element.classList.remove('non-latin');
                        return;
                    }

                    element.classList.remove('word-space');

                    if (!isLatinSegment) {
                        currentWrapper = null;
                        element.classList.add('non-latin');
                        return;
                    }

                    element.classList.remove('non-latin');

                    if (!currentWrapper) {
                        currentWrapper = document.createElement('span');
                        currentWrapper.classList.add('word-wrapper');
                        container.insertBefore(currentWrapper, element);
                    }

                    currentWrapper.appendChild(element);

                    if (endsWithSpace) {
                        currentWrapper = null;
                    }
                });
            }
            
            function createLineElement(lineIndex) {
                const line = lyricsData[lineIndex];
                if (!line) return null;

                const lineStyle = line.style || {};
                const bodyFont = window.getComputedStyle(document.body).fontFamily;
                const syllableFonts = Array.isArray(line.syllables)
                    ? line.syllables
                        .map((s) => (s && s.fontFamily ? String(s.fontFamily) : ''))
                        .filter((name) => name && name.trim().length > 0)
                    : [];
                const uniqueFonts = Array.from(new Set(syllableFonts));
                const aliasList = uniqueFonts.flatMap((name) => buildFontAliases(name));
                const dedupAliases = Array.from(new Set(aliasList));
                uniqueFonts.forEach((f) => ensureFontLoaded(f));
                const hasAnySpecialFont = uniqueFonts.length > 0;
                const disableBlurLayer = hasAnySpecialFont;

                const lineEl = document.createElement('div');
                lineEl.classList.add('lyric-line');
                if (hasAnySpecialFont) {
                    lineEl.classList.add('allow-overflow');
                    lineEl.dataset.specialFont = '1';
                    lineEl.dataset.maxFloatMs = '1000';
                    lineEl.style.fontWeight = 'normal';
                }
                lineEl.dataset.lineIndex = lineIndex;
                
                // 应用从后端传来的样式
                if (forceCenterAlign) {
                    lineEl.classList.add('center-aligned');
                    if (lineStyle.fontSize === 'small') {
                        lineEl.classList.add('small-font');
                    }
                } else if (line.style) {
                    if (lineStyle.align === 'right') {
                        lineEl.classList.add('right-aligned');
                    } else if (lineStyle.align === 'center') {
                        lineEl.classList.add('center-aligned');
                    } else {
                        lineEl.classList.add('left-aligned');
                    }
                    if (lineStyle.fontSize === 'small') {
                        lineEl.classList.add('small-font');
                    }
                } else {
                    lineEl.classList.add('left-aligned');
                }
                
                if(line.syllables && line.syllables.length > 0) {
                    const firstSyllable = line.syllables[0];
                    const lastSyllable = line.syllables[line.syllables.length - 1];
                    lineEl.dataset.startTime = firstSyllable.startTime;
                    lineEl.dataset.endTime = parseFloat(lastSyllable.startTime) + parseFloat(lastSyllable.duration);
                }
                const isSmallFont = (lineStyle.fontSize === 'small');
                
                // 创建模糊层（在翻译渲染之前，以便计算正确的高度）
                let blurLayer = null;
                if (!disableBlurLayer) {
                    blurLayer = document.createElement('div');
                    blurLayer.className = 'blur-layer';
                    
                    // 复制上层歌词的样式
                    blurLayer.style.justifyContent = getComputedStyle(lineEl).justifyContent;
                    blurLayer.style.alignItems = getComputedStyle(lineEl).alignItems;
                    
                    // 为每个音节创建模糊文本
                    line.syllables.forEach((syllable) => {
                        const blurText = document.createElement('span');
                        blurText.className = 'blur-text';
                        blurText.textContent = syllable.text;
                        blurText.style.fontSize = getComputedStyle(lineEl).fontSize;
                        blurText.style.fontWeight = getComputedStyle(lineEl).fontWeight;
                        blurText.style.lineHeight = getComputedStyle(lineEl).lineHeight;
                        const hasPresetFont = Object.prototype.hasOwnProperty.call(syllable, 'fontFamily');
                        const presetFont = hasPresetFont ? (syllable.fontFamily || '') : '';
                        const chosenFont = hasPresetFont ? presetFont : '';
                        const allowFallback = Boolean(chosenFont);
                        const blurFontValue = buildFontValue(chosenFont, dedupAliases, bodyFont, allowFallback);
                        if (blurFontValue) {
                            blurText.style.fontFamily = blurFontValue;
                            const chosenClass = chosenFont ? ensureFontClass(chosenFont, blurFontValue) : '';
                            if (chosenClass) blurText.classList.add(chosenClass);
                        }
                        
                        // 复制间距
                        if (syllable.text && syllable.text.includes(' ')) {
                            blurText.style.marginRight = '0.28em';
                        }
                        
                        blurLayer.appendChild(blurText);
                    });
                    
                    lineEl.appendChild(blurLayer);
                }
                
                line.syllables.forEach((syllable) => {
                    const syllableEl = document.createElement('span');
                    syllableEl.classList.add('syllable');
                    syllableEl.textContent = syllable.text;
                    syllableEl.dataset.startTime = syllable.startTime;
                    syllableEl.dataset.duration = syllable.duration;
                    const hasPresetFont = Object.prototype.hasOwnProperty.call(syllable, 'fontFamily');
                    const presetFont = hasPresetFont ? (syllable.fontFamily || '') : '';
                    const chosenFont = hasPresetFont ? presetFont : '';
                    const allowFallback = Boolean(chosenFont);
                    const syllableFontValue = buildFontValue(chosenFont, dedupAliases, bodyFont, allowFallback);
                    if (syllableFontValue) {
                        syllableEl.style.fontFamily = syllableFontValue;
                        const chosenClass = chosenFont ? ensureFontClass(chosenFont, syllableFontValue) : '';
                        if (chosenClass) syllableEl.classList.add(chosenClass);
                    }
                    // 如果音节内容包含空格，则加右边距
                    if (syllable.text && syllable.text.includes(' ')) {
                        // 使用 em 单位，使其可以随字体大小等比缩放
                        syllableEl.style.marginRight = '0.28em';
                    }
                    lineEl.appendChild(syllableEl);
                });

                groupSyllablesIntoWords(blurLayer, 'blur-text');
                groupSyllablesIntoWords(lineEl);

                // 翻译渲染：在歌词行下方插入翻译
                if (translationData.length > 0 && line.syllables && line.syllables.length > 0) {
                    // 取第一个音节的开始时间（秒->毫秒）
                    const startMs = Math.round(parseFloat(line.syllables[0].startTime) * 1000);
                    // 找到最接近的翻译（±200ms）
                    let minDelta = 201;
                    let bestTrans = null;
                    for (const t of translationData) {
                        const delta = Math.abs(t.timeMs - startMs);
                        if (delta < minDelta) {
                            minDelta = delta;
                            bestTrans = t;
                        }
                    }
                    if (bestTrans && minDelta <= 200) {
                        const transDiv = document.createElement('div');
                        transDiv.className = 'translation-line';
                        // 字体大小：正常歌词翻译为0.5em，背景人声的翻译为0.8em
                        transDiv.style.fontSize = isSmallFont ? '0.8em' : '0.5em';
                        transDiv.style.color = '#ffffff';
                        transDiv.style.fontWeight = 'normal';
                        transDiv.style.lineHeight = '1.2';
                        transDiv.style.marginTop = '0.1em';
                        transDiv.textContent = bestTrans.content;
                        // 强制换行并允许文本对齐
                        transDiv.style.width = '100%';
                        transDiv.style.paddingBottom = '0.2em'; // 给模糊层留下空间
                        // 翻译对齐方式与主歌词一致
                        if (lineEl.classList.contains('left-aligned')) transDiv.classList.add('left-aligned');
                        if (lineEl.classList.contains('center-aligned')) transDiv.classList.add('center-aligned');
                        if (lineEl.classList.contains('right-aligned')) transDiv.classList.add('right-aligned');
                        lineEl.appendChild(transDiv);
                        
                        // 如果有翻译，调整模糊层高度以避免重叠
                        setTimeout(() => {
                            const transHeight = transDiv.offsetHeight;
                            if (transHeight > 0 && blurLayer) {
                                blurLayer.style.height = `calc(100% - ${transHeight}px + var(--blur-safe-pad))`;
                            }
                        }, 0);
                    }
                }

                lineEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (lineEl.dataset.startTime) {
                        audioPlayer.currentTime = parseFloat(lineEl.dataset.startTime);
                        audioPlayer.play();
                    }
                });
                return lineEl;
            }

            function initLyrics() {
                lyricsContainer.innerHTML = '';
                displayedLines.clear();
                if (lyricsData.length === 0) {
                     lyricsContainer.textContent = '暂无歌词。';
                     return;
                }
            }

            function addLine(lineIndex) {
                if (displayedLines.has(lineIndex)) return;

                // 如果存在该行的占位符，立即移除，为新行让路
                if (placeholderLines.has(lineIndex)) {
                    const placeholderInfo = placeholderLines.get(lineIndex);
                    clearTimeout(placeholderInfo.removalTimer);
                    clearMoveTransition(placeholderInfo.element);
                    placeholderInfo.element.remove();
                    placeholderLines.delete(lineIndex);
                }

                const incomingLine = createLineElement(lineIndex);
                if (!incomingLine) return;

                // 并发锁：如果动画未完成，不允许重复添加
                if (incomingLine.animationLock) return;
                incomingLine.animationLock = true;

                // 找到下一个比当前 lineIndex 大的歌词行
                let inserted = false;
                const children = Array.from(lyricsContainer.children);
                for (let i = 0; i < children.length; i++) {
                    const childIndex = parseInt(children[i].dataset.lineIndex, 10);
                    if (childIndex > lineIndex) {
                        lyricsContainer.insertBefore(incomingLine, children[i]);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    lyricsContainer.appendChild(incomingLine);
                }

                const lineInfo = { element: incomingLine };
                displayedLines.set(lineIndex, lineInfo);

                if (!suppressAnimations) {
                    const animation = safeAnimate(incomingLine, [
                        { opacity: 0, filter: 'blur(5px)', '-webkit-filter': 'blur(5px)' },
                        { opacity: 1, filter: 'blur(0)', '-webkit-filter': 'blur(0)' }
                    ], {
                        duration: enterDuration,
                        easing: customEasing,
                        fill: 'forwards'
                    });
                    animation.onfinish = () => {
                        incomingLine.animationLock = false;
                    };
                } else {
                    incomingLine.style.opacity = '1';
                    incomingLine.style.filter = 'none';
                    incomingLine.style.webkitFilter = 'none';
                    incomingLine.animationLock = false;
                }

                const lineData = lyricsData[lineIndex];
                if (lineData) {
                    prepareSyllableAnimations(lineIndex, incomingLine, lineInfo, lineData);
                    requestAnimationFrame(() => {
                        if (displayedLines.has(lineIndex)) {
                            prepareSyllableAnimations(lineIndex, incomingLine, lineInfo, lineData);
                        }
                    });
                }
                scheduleAutoScale();
            }

            function removeLine(lineIndex) {
                const lineInfo = displayedLines.get(lineIndex);
                if (!lineInfo) return;

                const outgoingLine = lineInfo.element;

                cancelLineAnimations(lineInfo, { commit: true });

                if (suppressAnimations) {
                    if (outgoingLine && outgoingLine.parentElement) {
                        outgoingLine.remove();
                    }
                    displayedLines.delete(lineIndex);
                    return;
                }

                // 记录当前位置用于保持淡出起点
                const originalRect = outgoingLine.getBoundingClientRect();

                // 并发锁：动画未完成时禁止移除
                if (outgoingLine.animationLock) return;
                outgoingLine.animationLock = true;

                // 1. 创建并插入占位符
                const placeholderEl = document.createElement('div');
                placeholderEl.style.height = `${originalRect.height}px`; // 维持布局高度
                outgoingLine.before(placeholderEl); // 插入到原位置

                const scrollX = window.scrollX || window.pageXOffset || 0;
                const scrollY = window.scrollY || window.pageYOffset || 0;
                clearMoveTransition(outgoingLine);

                // 2. 克隆一个节点用于淡出动画，原节点立即移出布局
                const fadeLine = outgoingLine.cloneNode(true);
                fadeLine.classList.remove('active');
                fadeLine.style.position = 'absolute';
                fadeLine.style.left = `${originalRect.left + scrollX}px`;
                fadeLine.style.top = `${originalRect.top + scrollY}px`;
                fadeLine.style.width = `${originalRect.width}px`;
                fadeLine.style.margin = '0';
                fadeLine.style.pointerEvents = 'none';
                fadeLine.style.transform = '';
                fadeLine.style.willChange = '';
                const computedStyle = window.getComputedStyle(outgoingLine);
                const lyricScale = computedStyle.getPropertyValue('--lyric-scale');
                fadeLine.style.fontSize = computedStyle.fontSize;
                fadeLine.style.lineHeight = computedStyle.lineHeight;
                fadeLine.style.fontWeight = computedStyle.fontWeight;
                if (lyricScale) {
                    fadeLine.style.setProperty('--lyric-scale', lyricScale.trim());
                }
                document.body.appendChild(fadeLine);

                outgoingLine.remove();

                const animation = safeAnimate(fadeLine, [
                    { opacity: 1, filter: 'blur(0)', '-webkit-filter': 'blur(0)' },
                    { opacity: 0, filter: 'blur(5px)', '-webkit-filter': 'blur(5px)' }
                ], {
                    duration: exitDuration,
                    easing: customEasing,
                    fill: 'forwards'
                });
                animation.onfinish = () => {
                    outgoingLine.animationLock = false;
                    fadeLine.remove();
                };

                // 3. 100ms后再移除占位符并触发补位动画
                const removalTimer = setTimeout(() => {
                    // FLIP - FIRST: 记录所有元素在占位符消失前的位置
                    const oldPositions = new Map();
                    const recordPosition = (map, keyPrefix) => {
                        map.forEach((info, index) => {
                            // 排除即将被移除的当前占位符
                            if (keyPrefix === 'placeholder-' && index === lineIndex) return;
                            oldPositions.set(`${keyPrefix}${index}`, info.element.getBoundingClientRect());
                        });
                    };
                    recordPosition(displayedLines, 'line-');
                    recordPosition(placeholderLines, 'placeholder-');

                    // DOM 操作：移除占位符
                    clearMoveTransition(placeholderEl);
                    placeholderEl.remove();
                    placeholderLines.delete(lineIndex);

                    // FLIP - LAST: 读取新位置
                    const newPositions = new Map();
                    const readNewPosition = (map, keyPrefix) => {
                        map.forEach((info, index) => {
                            const key = `${keyPrefix}${index}`;
                            if (oldPositions.has(key)) {
                                newPositions.set(key, {
                                    element: info.element,
                                    rect: info.element.getBoundingClientRect()
                                });
                            }
                        });
                    };
                    readNewPosition(displayedLines, 'line-');
                    readNewPosition(placeholderLines, 'placeholder-');
                    
                    // FLIP - INVERT & PLAY
                    newPositions.forEach((newInfo, key) => {
                        const oldRect = oldPositions.get(key);
                        const newRect = newInfo.rect;
                        const deltaX = oldRect.left - newRect.left;
                        const deltaY = oldRect.top - newRect.top;

                        runFlipTransition(newInfo.element, deltaX, deltaY);
                    });
                }, placeholderDuration); // 100ms后再移除占位符

                placeholderLines.set(lineIndex, { element: placeholderEl, removalTimer: removalTimer });
                displayedLines.delete(lineIndex);
                scheduleAutoScale();
            }

            function updateLyricsDisplay() {
                const currentTime = audioPlayer.currentTime;
                const oldPositions = suppressAnimations ? new Map() : new Map();
                if (!suppressAnimations) {
                    // FIRST: 记录所有当前显示行和占位符的位置
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        oldPositions.set(`line-${lineIndex}`, lineInfo.element.getBoundingClientRect());
                    });
                    placeholderLines.forEach((lineInfo, lineIndex) => {
                        oldPositions.set(`placeholder-${lineIndex}`, lineInfo.element.getBoundingClientRect());
                    });
                }

                // 歌词行显示逻辑
                if (showAllLinesWhenPaused) {
                    // 暂停时，全部歌词行都显示
                    lyricsData.forEach((line, index) => {
                        if (!displayedLines.has(index)) {
                            addLine(index);
                        }
                    });
                    // 多余的行要移除
                    Array.from(displayedLines.keys()).forEach(index => {
                        if (index >= lyricsData.length) {
                            removeLine(index);
                        }
                    });
                } else {
                    // 正常模式，使用后端计算好的消失时机
                    lyricsData.forEach((line, index) => {
                        // 确保歌词行有音节数据
                        if (!line.syllables || line.syllables.length === 0) return;

                        const startTime = parseFloat(line.syllables[0].startTime); // 单位：秒
                        const disappearTime = line.disappearTime / 1000; // 从后端获取（毫秒 -> 秒）
                        
                        const isLineDisplayed = displayedLines.has(index);

                        // 判断是否应显示/消失
                        const isLineActive = (currentTime >= startTime - lineDisplayOffset) && (currentTime < disappearTime);

                        if (isLineActive && !isLineDisplayed) {
                            addLine(index);
                        } else if (!isLineActive && isLineDisplayed) {
                            removeLine(index);
                        }
                    });
                }

                if (!suppressAnimations) {
                    // LAST: 读取新位置
                    const newPositions = [];
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        const key = `line-${lineIndex}`;
                        if (oldPositions.has(key)) {
                            newPositions.push({
                                key,
                                element: lineInfo.element,
                                rect: lineInfo.element.getBoundingClientRect()
                            });
                        }
                    });
                    placeholderLines.forEach((lineInfo, lineIndex) => {
                        const key = `placeholder-${lineIndex}`;
                        if (oldPositions.has(key)) {
                            newPositions.push({
                                key,
                                element: lineInfo.element,
                                rect: lineInfo.element.getBoundingClientRect()
                            });
                        }
                    });

                    // INVERT & PLAY: 为移动的元素应用动画
                    newPositions.forEach(({ key, element, rect }) => {
                        const oldRect = oldPositions.get(key);
                        if (!oldRect) return;
                        const deltaX = oldRect.left - rect.left;
                        const deltaY = oldRect.top - rect.top;
                        runFlipTransition(element, deltaX, deltaY);
                    });
                }
                
                // 音节高亮逻辑 - 只处理active状态，卡拉OK进度由rafLoop处理
                if (displayedLines.size > 0) {
                    displayedLines.forEach((lineInfo, lineIndex) => {
                        const lineEl = lineInfo.element;
                        const startTime = parseFloat(lineEl.dataset.startTime);
                        const endTime = parseFloat(lineEl.dataset.endTime);
                        // 当前播放歌词行加 active
                        if (currentTime >= startTime - lineDisplayOffset && currentTime < endTime) {
                            lineEl.classList.add('active');
                        } else {
                            lineEl.classList.remove('active');
                        }
                        syncLineAnimations(lineInfo);
                    });
                }
            }

            audioPlayer.addEventListener('timeupdate', updateLyricsDisplay);
            // 监听暂停/播放事件，切换展示模式
            audioPlayer.addEventListener('pause', () => {
                showAllLinesWhenPaused = true;
                autoScaleLocked = true;
                if (autoScaleRaf) {
                    cancelAnimationFrame(autoScaleRaf);
                    autoScaleRaf = null;
                }
                playerContainer.classList.add('paused-mode');
                withAnimationsSuppressed(() => {
                    updateLyricsDisplay();
                });
                // 滚动到当前播放的歌词行
                setTimeout(() => {
                    const currentLine = document.querySelector('.lyric-line.active');
                    if (currentLine) {
                        currentLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
                // 停止动画循环
                if (rafId != null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
            });
            audioPlayer.addEventListener('play', () => {
                showAllLinesWhenPaused = false;
                autoScaleLocked = false;
                playerContainer.classList.remove('paused-mode');
                withAnimationsSuppressed(() => {
                    updateLyricsDisplay();
                });
                scheduleAutoScale();
                // 启动动画循环
                if (rafId == null) {
                    rafLoop();
                }
            });
            
            function togglePlayPause() {
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            }

            document.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.code === 'Space') {
                    event.preventDefault();
                    togglePlayPause();
                } else if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 5);
                } else if (event.key === 'ArrowRight') {
                    event.preventDefault();
                    audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 5);
                }
            });
            
            // 全局点击：只要不是歌词行就切换播放/暂停
            document.body.addEventListener('click', function(e) {
                // 如果点击的是歌词行或其子元素，什么都不做
                if (e.target.closest('.lyric-line')) return;
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            });
            window.addEventListener('resize', scheduleAutoScale);

            await syncAnimationConfig();
            await loadData();
            scheduleAutoScale();
            
            // 页面加载后自动启动动画循环（如果音频正在播放）
            setTimeout(() => {
                if (!audioPlayer.paused && rafId == null) {
                    rafLoop();
                }
            }, 100);
            
            // 字体大小调整滑块逻辑
            fontSlider.addEventListener('input', (e) => {
                const nextScale = parseFloat(e.target.value) || 1;
                userLyricScale = nextScale;
                localStorage.setItem('lyricScale', nextScale);
                setLyricScale(computeAutoScaleTarget());
                scheduleAutoScale();
            });

            // 页面加载时应用缓存的字体大小
            const savedScale = localStorage.getItem('lyricScale');
            if (savedScale) {
                const parsedScale = parseFloat(savedScale);
                if (!Number.isNaN(parsedScale)) {
                    userLyricScale = parsedScale;
                    fontSlider.value = savedScale;
                    setLyricScale(computeAutoScaleTarget());
                }
            }

            // Safari animate 兼容降级
            function safeAnimate(element, keyframes, options) {
                if (element.animate) {
                    return element.animate(keyframes, options);
                } else {
                    // Safari 旧版降级：直接设置最终样式
                    Object.assign(element.style, keyframes[keyframes.length - 1]);
                    return { onfinish: () => {} };
                }
            }

            // 加载背景图片或视频
        });
    </script>
</body>
</html>
